{"ast":null,"code":"/**\r\n * 高级提示词分析器\r\n * 融合NovelAI Spell项目和Live Context技术的智能提示词解析功能\r\n */\n\nexport class AdvancedPromptAnalyzer {\n  constructor() {\n    // 初始化分析配置\n    this.config = {\n      // 提示词权重阈值\n      weightThresholds: {\n        high: 1.2,\n        medium: 1.0,\n        low: 0.8\n      },\n      // 语义类别\n      semanticCategories: {\n        character: ['girl', 'boy', 'woman', 'man', 'person', 'character'],\n        style: ['anime', 'realistic', 'cartoon', 'painting', 'digital art'],\n        quality: ['masterpiece', 'best quality', 'high resolution', 'detailed'],\n        composition: ['portrait', 'full body', 'close-up', 'wide shot'],\n        lighting: ['soft lighting', 'dramatic lighting', 'natural light'],\n        color: ['colorful', 'monochrome', 'vibrant', 'pastel'],\n        emotion: ['happy', 'sad', 'angry', 'peaceful', 'excited'],\n        environment: ['indoor', 'outdoor', 'nature', 'city', 'fantasy']\n      },\n      // NovelAI特定标签权重映射\n      novelaiWeights: {\n        '{{': 1.05,\n        '((': 1.21,\n        '[': 0.9,\n        '[[': 0.81\n      }\n    };\n  }\n\n  /**\r\n   * 分析提示词的完整结构\r\n   * @param {string} positivePrompt - 正向提示词\r\n   * @param {string} negativePrompt - 负向提示词\r\n   * @param {Object} parameters - 生成参数\r\n   * @returns {Object} 详细分析结果\r\n   */\n  analyzePrompts(positivePrompt, negativePrompt, parameters = {}) {\n    const result = {\n      positive: this.analyzePromptText(positivePrompt, 'positive'),\n      negative: this.analyzePromptText(negativePrompt, 'negative'),\n      relationships: this.analyzeRelationships(positivePrompt, negativePrompt),\n      parameters: this.analyzeParameters(parameters),\n      quality: this.assessPromptQuality(positivePrompt, negativePrompt),\n      suggestions: this.generateSuggestions(positivePrompt, negativePrompt, parameters),\n      metadata: {\n        analyzedAt: new Date().toISOString(),\n        analyzerVersion: '2.0',\n        source: 'advanced-prompt-analyzer'\n      }\n    };\n    return result;\n  }\n\n  /**\r\n   * 分析单个提示词文本\r\n   * @param {string} promptText - 提示词文本\r\n   * @param {string} type - 类型 (positive/negative)\r\n   * @returns {Object} 分析结果\r\n   */\n  analyzePromptText(promptText, type = 'positive') {\n    if (!promptText || typeof promptText !== 'string') {\n      return this.getEmptyAnalysis();\n    }\n\n    // 解析提示词标签\n    const tags = this.parsePromptTags(promptText);\n\n    // 分析权重和强调\n    const weightAnalysis = this.analyzeWeights(tags);\n\n    // 语义分类\n    const semanticGroups = this.categorizeSemantics(tags);\n\n    // 复杂度分析\n    const complexity = this.analyzeComplexity(tags);\n\n    // 风格检测\n    const styleAnalysis = this.detectStyle(tags);\n    return {\n      originalText: promptText,\n      type,\n      tags: {\n        parsed: tags,\n        count: tags.length,\n        weighted: weightAnalysis.weightedTags,\n        emphasized: weightAnalysis.emphasizedTags\n      },\n      semantics: semanticGroups,\n      weights: weightAnalysis,\n      complexity,\n      style: styleAnalysis,\n      structure: this.analyzeStructure(promptText),\n      effectiveness: this.calculateEffectiveness(tags, type)\n    };\n  }\n\n  /**\r\n   * 解析提示词标签 - 支持多种权重格式\r\n   * @param {string} text - 提示词文本\r\n   * @returns {Array} 解析后的标签数组\r\n   */\n  parsePromptTags(text) {\n    const tags = [];\n\n    // 分割基本标签（逗号分隔）\n    const basicTags = text.split(',').map(tag => tag.trim()).filter(tag => tag.length > 0);\n    for (const tag of basicTags) {\n      const parsedTag = this.parseIndividualTag(tag);\n      if (parsedTag) {\n        tags.push(parsedTag);\n      }\n    }\n    return tags;\n  }\n\n  /**\r\n   * 解析单个标签的权重和格式\r\n   * @param {string} tagText - 单个标签文本\r\n   * @returns {Object} 解析结果\r\n   */\n  parseIndividualTag(tagText) {\n    let cleanText = tagText.trim();\n    let weight = 1.0;\n    let emphasis = 'normal';\n    let brackets = [];\n\n    // NovelAI风格权重解析\n    const patterns = [{\n      regex: /^\\{\\{(.+?)\\}\\}$/,\n      weight: 1.05,\n      emphasis: 'light',\n      type: 'double_curly'\n    }, {\n      regex: /^\\{(.+?)\\}$/,\n      weight: 1.02,\n      emphasis: 'very_light',\n      type: 'single_curly'\n    }, {\n      regex: /^\\(\\((.+?)\\)\\)$/,\n      weight: 1.21,\n      emphasis: 'strong',\n      type: 'double_round'\n    }, {\n      regex: /^\\((.+?)\\)$/,\n      weight: 1.1,\n      emphasis: 'medium',\n      type: 'single_round'\n    }, {\n      regex: /^\\[\\[(.+?)\\]\\]$/,\n      weight: 0.81,\n      emphasis: 'weak',\n      type: 'double_square'\n    }, {\n      regex: /^\\[(.+?)\\]$/,\n      weight: 0.9,\n      emphasis: 'light_negative',\n      type: 'single_square'\n    }, {\n      regex: /^(.+?):(\\d*\\.?\\d+)$/,\n      weight: 'custom',\n      emphasis: 'custom',\n      type: 'colon_weight'\n    }];\n\n    // 检查权重模式\n    for (const pattern of patterns) {\n      const match = cleanText.match(pattern.regex);\n      if (match) {\n        cleanText = match[1];\n        if (pattern.weight === 'custom') {\n          weight = parseFloat(match[2]);\n          emphasis = weight > 1.0 ? 'custom_positive' : weight < 1.0 ? 'custom_negative' : 'normal';\n        } else {\n          weight = pattern.weight;\n          emphasis = pattern.emphasis;\n        }\n        brackets.push(pattern.type);\n        break;\n      }\n    }\n\n    // 检测特殊标记\n    const specialMarkers = this.detectSpecialMarkers(cleanText);\n    return {\n      original: tagText,\n      text: cleanText,\n      weight,\n      emphasis,\n      brackets,\n      special: specialMarkers,\n      category: this.categorizeTag(cleanText),\n      importance: this.calculateTagImportance(cleanText, weight)\n    };\n  }\n\n  /**\r\n   * 分析权重分布\r\n   * @param {Array} tags - 标签数组\r\n   * @returns {Object} 权重分析结果\r\n   */\n  analyzeWeights(tags) {\n    const weightDistribution = {\n      emphasized: tags.filter(tag => tag.weight > 1.0),\n      normal: tags.filter(tag => tag.weight === 1.0),\n      deemphasized: tags.filter(tag => tag.weight < 1.0)\n    };\n    const avgWeight = tags.reduce((sum, tag) => sum + tag.weight, 0) / tags.length;\n    const maxWeight = Math.max(...tags.map(tag => tag.weight));\n    const minWeight = Math.min(...tags.map(tag => tag.weight));\n    return {\n      distribution: weightDistribution,\n      statistics: {\n        average: avgWeight,\n        maximum: maxWeight,\n        minimum: minWeight,\n        range: maxWeight - minWeight\n      },\n      weightedTags: tags.filter(tag => tag.weight !== 1.0),\n      emphasizedTags: tags.filter(tag => tag.weight > 1.0).sort((a, b) => b.weight - a.weight)\n    };\n  }\n\n  /**\r\n   * 语义分类\r\n   * @param {Array} tags - 标签数组\r\n   * @returns {Object} 分类结果\r\n   */\n  categorizeSemantics(tags) {\n    const categories = {};\n\n    // 初始化分类\n    Object.keys(this.config.semanticCategories).forEach(category => {\n      categories[category] = [];\n    });\n    categories.other = [];\n\n    // 分类标签\n    tags.forEach(tag => {\n      let categorized = false;\n      for (const [category, keywords] of Object.entries(this.config.semanticCategories)) {\n        if (keywords.some(keyword => tag.text.toLowerCase().includes(keyword.toLowerCase()))) {\n          categories[category].push(tag);\n          categorized = true;\n          break;\n        }\n      }\n      if (!categorized) {\n        categories.other.push(tag);\n      }\n    });\n\n    // 统计每个分类的权重和重要性\n    const categoryStats = {};\n    Object.entries(categories).forEach(([category, categoryTags]) => {\n      if (categoryTags.length > 0) {\n        const avgWeight = categoryTags.reduce((sum, tag) => sum + tag.weight, 0) / categoryTags.length;\n        const maxImportance = Math.max(...categoryTags.map(tag => tag.importance));\n        categoryStats[category] = {\n          count: categoryTags.length,\n          averageWeight: avgWeight,\n          maxImportance,\n          dominance: categoryTags.length / tags.length\n        };\n      }\n    });\n    return {\n      categories,\n      statistics: categoryStats,\n      dominantCategory: this.findDominantCategory(categoryStats)\n    };\n  }\n\n  /**\r\n   * 分析提示词复杂度\r\n   * @param {Array} tags - 标签数组\r\n   * @returns {Object} 复杂度分析\r\n   */\n  analyzeComplexity(tags) {\n    const uniqueWeights = new Set(tags.map(tag => tag.weight));\n    const hasCustomWeights = tags.some(tag => tag.brackets.includes('colon_weight'));\n    const hasMultipleBrackets = tags.some(tag => tag.brackets.length > 1);\n    const hasSpecialMarkers = tags.some(tag => tag.special.length > 0);\n    const complexityScore = this.calculateComplexityScore(tags);\n    return {\n      score: complexityScore,\n      level: this.getComplexityLevel(complexityScore),\n      factors: {\n        tagCount: tags.length,\n        uniqueWeights: uniqueWeights.size,\n        hasCustomWeights,\n        hasMultipleBrackets,\n        hasSpecialMarkers,\n        averageTagLength: tags.reduce((sum, tag) => sum + tag.text.length, 0) / tags.length\n      },\n      assessment: this.assessComplexity(complexityScore)\n    };\n  }\n\n  /**\r\n   * 风格检测\r\n   * @param {Array} tags - 标签数组\r\n   * @returns {Object} 风格分析\r\n   */\n  detectStyle(tags) {\n    var _detectedStyles$prima;\n    const styleIndicators = {\n      anime: ['anime', 'manga', 'kawaii', 'chibi', 'moe'],\n      realistic: ['realistic', 'photorealistic', 'photography', 'photo'],\n      artistic: ['painting', 'artwork', 'illustration', 'drawing'],\n      fantasy: ['fantasy', 'magical', 'mystical', 'ethereal'],\n      cyberpunk: ['cyberpunk', 'neon', 'futuristic', 'sci-fi'],\n      vintage: ['vintage', 'retro', 'classic', 'old-fashioned']\n    };\n    const detectedStyles = {};\n    let primaryStyle = 'mixed';\n    let maxScore = 0;\n    Object.entries(styleIndicators).forEach(([style, indicators]) => {\n      const matchingTags = tags.filter(tag => indicators.some(indicator => tag.text.toLowerCase().includes(indicator.toLowerCase())));\n      if (matchingTags.length > 0) {\n        const score = matchingTags.reduce((sum, tag) => sum + tag.weight * tag.importance, 0);\n        detectedStyles[style] = {\n          score,\n          matchingTags,\n          confidence: Math.min(score / tags.length, 1.0)\n        };\n        if (score > maxScore) {\n          maxScore = score;\n          primaryStyle = style;\n        }\n      }\n    });\n    return {\n      primary: primaryStyle,\n      detected: detectedStyles,\n      confidence: maxScore > 0 ? (_detectedStyles$prima = detectedStyles[primaryStyle]) === null || _detectedStyles$prima === void 0 ? void 0 : _detectedStyles$prima.confidence : 0,\n      isStyleConsistent: Object.keys(detectedStyles).length <= 2\n    };\n  }\n\n  /**\r\n   * 分析提示词之间的关系\r\n   * @param {string} positive - 正向提示词\r\n   * @param {string} negative - 负向提示词\r\n   * @returns {Object} 关系分析\r\n   */\n  analyzeRelationships(positive, negative) {\n    const positiveTags = this.parsePromptTags(positive || '');\n    const negativeTags = this.parsePromptTags(negative || '');\n\n    // 检查冲突\n    const conflicts = this.findConflicts(positiveTags, negativeTags);\n\n    // 检查互补性\n    const complements = this.findComplements(positiveTags, negativeTags);\n\n    // 平衡性分析\n    const balance = this.analyzeBalance(positiveTags, negativeTags);\n    return {\n      conflicts,\n      complements,\n      balance,\n      coherence: this.calculateCoherence(positiveTags, negativeTags),\n      effectiveness: this.calculateRelationshipEffectiveness(conflicts, complements, balance)\n    };\n  }\n\n  /**\r\n   * 生成智能建议\r\n   * @param {string} positive - 正向提示词\r\n   * @param {string} negative - 负向提示词\r\n   * @param {Object} parameters - 生成参数\r\n   * @returns {Array} 建议数组\r\n   */\n  generateSuggestions(positive, negative, parameters) {\n    const suggestions = [];\n    const positiveTags = this.parsePromptTags(positive || '');\n    const negativeTags = this.parsePromptTags(negative || '');\n\n    // 权重优化建议\n    suggestions.push(...this.generateWeightSuggestions(positiveTags));\n\n    // 结构优化建议\n    suggestions.push(...this.generateStructureSuggestions(positiveTags, negativeTags));\n\n    // 参数匹配建议\n    suggestions.push(...this.generateParameterSuggestions(positiveTags, parameters));\n\n    // 风格一致性建议\n    suggestions.push(...this.generateStyleSuggestions(positiveTags));\n    return suggestions.map(suggestion => ({\n      ...suggestion,\n      priority: this.calculateSuggestionPriority(suggestion),\n      confidence: this.calculateSuggestionConfidence(suggestion)\n    })).sort((a, b) => b.priority - a.priority);\n  }\n\n  /**\r\n   * 生成权重优化建议\r\n   * @param {Array} tags - 标签数组\r\n   * @returns {Array} 建议数组\r\n   */\n  generateWeightSuggestions(tags) {\n    const suggestions = [];\n\n    // 检查过度强调\n    const overEmphasized = tags.filter(tag => tag.weight > 1.3);\n    if (overEmphasized.length > 0) {\n      suggestions.push({\n        type: 'weight_optimization',\n        category: 'warning',\n        title: '过度强调检测',\n        description: `发现${overEmphasized.length}个过度强调的标签，可能导致生成效果不自然`,\n        affectedTags: overEmphasized.map(tag => tag.original),\n        recommendation: '建议将权重降低到1.2以下',\n        impact: 'medium'\n      });\n    }\n\n    // 检查权重不平衡\n    const weights = tags.map(tag => tag.weight);\n    const weightRange = Math.max(...weights) - Math.min(...weights);\n    if (weightRange > 0.5) {\n      suggestions.push({\n        type: 'weight_optimization',\n        category: 'improvement',\n        title: '权重平衡优化',\n        description: `权重范围过大(${weightRange.toFixed(2)})，建议调整以获得更平衡的效果`,\n        recommendation: '考虑缩小权重差异，保持在0.3范围内',\n        impact: 'low'\n      });\n    }\n    return suggestions;\n  }\n\n  /**\r\n   * 计算标签重要性\r\n   * @param {string} text - 标签文本\r\n   * @param {number} weight - 标签权重\r\n   * @returns {number} 重要性分数\r\n   */\n  calculateTagImportance(text, weight) {\n    let importance = weight;\n\n    // 质量词汇加分\n    const qualityKeywords = ['masterpiece', 'best quality', 'high resolution', 'detailed'];\n    if (qualityKeywords.some(keyword => text.toLowerCase().includes(keyword))) {\n      importance += 0.2;\n    }\n\n    // 长度因子\n    const lengthFactor = Math.min(text.length / 20, 1.0);\n    importance += lengthFactor * 0.1;\n    return Math.min(importance, 2.0);\n  }\n\n  /**\r\n   * 检测特殊标记\r\n   * @param {string} text - 文本\r\n   * @returns {Array} 特殊标记数组\r\n   */\n  detectSpecialMarkers(text) {\n    const markers = [];\n\n    // 艺术家标记\n    if (text.includes('by ') || text.includes('artist:')) {\n      markers.push('artist');\n    }\n\n    // 版权标记\n    if (text.includes('©') || text.includes('copyright')) {\n      markers.push('copyright');\n    }\n\n    // 质量标记\n    const qualityMarkers = ['masterpiece', 'best quality', 'high quality'];\n    if (qualityMarkers.some(marker => text.toLowerCase().includes(marker))) {\n      markers.push('quality');\n    }\n    return markers;\n  }\n\n  /**\r\n   * 分类单个标签\r\n   * @param {string} text - 标签文本\r\n   * @returns {string} 分类结果\r\n   */\n  categorizeTag(text) {\n    const lowerText = text.toLowerCase();\n    for (const [category, keywords] of Object.entries(this.config.semanticCategories)) {\n      if (keywords.some(keyword => lowerText.includes(keyword))) {\n        return category;\n      }\n    }\n    return 'other';\n  }\n\n  /**\r\n   * 获取空分析结果\r\n   * @returns {Object} 空结果\r\n   */\n  getEmptyAnalysis() {\n    return {\n      originalText: '',\n      type: 'unknown',\n      tags: {\n        parsed: [],\n        count: 0,\n        weighted: [],\n        emphasized: []\n      },\n      semantics: {\n        categories: {},\n        statistics: {},\n        dominantCategory: null\n      },\n      weights: {\n        distribution: {},\n        statistics: {},\n        weightedTags: [],\n        emphasizedTags: []\n      },\n      complexity: {\n        score: 0,\n        level: 'none',\n        factors: {},\n        assessment: ''\n      },\n      style: {\n        primary: 'none',\n        detected: {},\n        confidence: 0,\n        isStyleConsistent: true\n      },\n      structure: {},\n      effectiveness: 0\n    };\n  }\n\n  /**\r\n   * 计算复杂度分数\r\n   * @param {Array} tags - 标签数组\r\n   * @returns {number} 复杂度分数\r\n   */\n  calculateComplexityScore(tags) {\n    let score = 0;\n\n    // 基础分数：标签数量\n    score += Math.min(tags.length / 10, 1.0) * 0.3;\n\n    // 权重复杂度\n    const uniqueWeights = new Set(tags.map(tag => tag.weight));\n    score += Math.min(uniqueWeights.size / 5, 1.0) * 0.2;\n\n    // 语法复杂度\n    const hasComplexSyntax = tags.some(tag => tag.brackets.length > 0);\n    if (hasComplexSyntax) score += 0.2;\n\n    // 特殊标记\n    const hasSpecialMarkers = tags.some(tag => tag.special.length > 0);\n    if (hasSpecialMarkers) score += 0.1;\n\n    // 平均标签长度\n    const avgLength = tags.reduce((sum, tag) => sum + tag.text.length, 0) / tags.length;\n    score += Math.min(avgLength / 20, 1.0) * 0.2;\n    return Math.min(score, 1.0);\n  }\n\n  /**\r\n   * 获取复杂度等级\r\n   * @param {number} score - 复杂度分数\r\n   * @returns {string} 复杂度等级\r\n   */\n  getComplexityLevel(score) {\n    if (score >= 0.8) return 'very_high';\n    if (score >= 0.6) return 'high';\n    if (score >= 0.4) return 'medium';\n    if (score >= 0.2) return 'low';\n    return 'very_low';\n  }\n\n  /**\r\n   * 评估复杂度\r\n   * @param {number} score - 复杂度分数\r\n   * @returns {string} 评估结果\r\n   */\n  assessComplexity(score) {\n    const level = this.getComplexityLevel(score);\n    const assessments = {\n      'very_high': '非常复杂的提示词结构，建议适当简化',\n      'high': '相对复杂的提示词，注意权重平衡',\n      'medium': '中等复杂度，结构合理',\n      'low': '简单的提示词结构，可考虑添加更多细节',\n      'very_low': '非常简单的结构，建议增加描述性标签'\n    };\n    return assessments[level] || '无法评估';\n  }\n\n  /**\r\n   * 计算提示词效果评分\r\n   * @param {Array} tags - 标签数组\r\n   * @param {string} type - 类型\r\n   * @returns {number} 效果评分\r\n   */\n  calculateEffectiveness(tags, type) {\n    if (tags.length === 0) return 0;\n    let score = 0;\n\n    // 基础分数：标签多样性\n    const categories = new Set(tags.map(tag => tag.category));\n    score += Math.min(categories.size / 8, 1.0) * 0.3;\n\n    // 权重合理性\n    const avgWeight = tags.reduce((sum, tag) => sum + tag.weight, 0) / tags.length;\n    const weightBalance = 1 - Math.abs(avgWeight - 1.0);\n    score += weightBalance * 0.2;\n\n    // 质量标签存在\n    const hasQuality = tags.some(tag => tag.special.includes('quality'));\n    if (hasQuality) score += 0.2;\n\n    // 长度适中性\n    const textLength = tags.reduce((sum, tag) => sum + tag.text.length, 0);\n    const lengthScore = Math.max(0, 1 - Math.abs(textLength - 100) / 200);\n    score += lengthScore * 0.3;\n    return Math.min(score, 1.0);\n  }\n\n  /**\r\n   * 分析结构特征\r\n   * @param {string} promptText - 提示词文本\r\n   * @returns {Object} 结构分析\r\n   */\n  analyzeStructure(promptText) {\n    return {\n      length: promptText.length,\n      wordCount: promptText.split(/\\s+/).length,\n      tagCount: promptText.split(',').length,\n      hasWeights: /[\\(\\[\\{]/.test(promptText),\n      hasColonWeights: /:[\\d\\.]+/.test(promptText),\n      hasArtistTags: /by\\s+/.test(promptText),\n      hasCopyrightTags: /©|\\(.*\\)/.test(promptText)\n    };\n  }\n\n  /**\r\n   * 分析生成参数\r\n   * @param {Object} parameters - 生成参数\r\n   * @returns {Object} 参数分析\r\n   */\n  analyzeParameters(parameters) {\n    const analysis = {\n      guidance: parameters.guidance || parameters.cfg_scale || 7,\n      steps: parameters.steps || parameters.sampling_steps || 20,\n      sampler: parameters.sampler || parameters.sampling_method || 'unknown',\n      seed: parameters.seed || -1,\n      size: parameters.size || `${parameters.width || 512}x${parameters.height || 512}`,\n      model: parameters.model || 'unknown'\n    };\n\n    // 参数合理性检查\n    analysis.assessment = {\n      guidanceLevel: this.assessGuidanceLevel(analysis.guidance),\n      stepsEfficiency: this.assessStepsEfficiency(analysis.steps),\n      overallBalance: this.assessParameterBalance(analysis)\n    };\n    return analysis;\n  }\n\n  /**\r\n   * 评估提示词质量\r\n   * @param {string} positive - 正向提示词\r\n   * @param {string} negative - 负向提示词\r\n   * @returns {Object} 质量评估\r\n   */\n  assessPromptQuality(positive, negative) {\n    const positiveTags = this.parsePromptTags(positive || '');\n    const negativeTags = this.parsePromptTags(negative || '');\n    const positiveScore = this.calculateEffectiveness(positiveTags, 'positive');\n    const negativeScore = this.calculateEffectiveness(negativeTags, 'negative');\n    const overallScore = positiveScore * 0.7 + negativeScore * 0.3;\n    return {\n      overall: overallScore,\n      positive: positiveScore,\n      negative: negativeScore,\n      level: this.getQualityLevel(overallScore),\n      strengths: this.identifyStrengths(positiveTags, negativeTags),\n      weaknesses: this.identifyWeaknesses(positiveTags, negativeTags)\n    };\n  }\n\n  /**\r\n   * 寻找主导分类\r\n   * @param {Object} categoryStats - 分类统计\r\n   * @returns {string} 主导分类\r\n   */\n  findDominantCategory(categoryStats) {\n    let maxDominance = 0;\n    let dominantCategory = null;\n    Object.entries(categoryStats).forEach(([category, stats]) => {\n      if (stats.dominance > maxDominance) {\n        maxDominance = stats.dominance;\n        dominantCategory = category;\n      }\n    });\n    return dominantCategory;\n  }\n\n  /**\r\n   * 查找冲突\r\n   * @param {Array} positiveTags - 正向标签\r\n   * @param {Array} negativeTags - 负向标签\r\n   * @returns {Array} 冲突列表\r\n   */\n  findConflicts(positiveTags, negativeTags) {\n    const conflicts = [];\n    positiveTags.forEach(positiveTag => {\n      negativeTags.forEach(negativeTag => {\n        if (this.areConflicting(positiveTag.text, negativeTag.text)) {\n          conflicts.push({\n            positive: positiveTag,\n            negative: negativeTag,\n            severity: this.calculateConflictSeverity(positiveTag, negativeTag)\n          });\n        }\n      });\n    });\n    return conflicts;\n  }\n\n  /**\r\n   * 查找互补关系\r\n   * @param {Array} positiveTags - 正向标签\r\n   * @param {Array} negativeTags - 负向标签\r\n   * @returns {Array} 互补关系列表\r\n   */\n  findComplements(positiveTags, negativeTags) {\n    const complements = [];\n    positiveTags.forEach(positiveTag => {\n      negativeTags.forEach(negativeTag => {\n        if (this.areComplementary(positiveTag.text, negativeTag.text)) {\n          complements.push({\n            positive: positiveTag,\n            negative: negativeTag,\n            strength: this.calculateComplementStrength(positiveTag, negativeTag)\n          });\n        }\n      });\n    });\n    return complements;\n  }\n\n  /**\r\n   * 分析平衡性\r\n   * @param {Array} positiveTags - 正向标签\r\n   * @param {Array} negativeTags - 负向标签\r\n   * @returns {Object} 平衡性分析\r\n   */\n  analyzeBalance(positiveTags, negativeTags) {\n    const positiveWeight = positiveTags.reduce((sum, tag) => sum + tag.weight, 0);\n    const negativeWeight = negativeTags.reduce((sum, tag) => sum + tag.weight, 0);\n    const ratio = positiveWeight / Math.max(negativeWeight, 0.1);\n    return {\n      positiveWeight,\n      negativeWeight,\n      ratio,\n      assessment: this.assessBalance(ratio),\n      isBalanced: ratio >= 2 && ratio <= 8\n    };\n  }\n\n  /**\r\n   * 计算一致性\r\n   * @param {Array} positiveTags - 正向标签\r\n   * @param {Array} negativeTags - 负向标签\r\n   * @returns {number} 一致性分数\r\n   */\n  calculateCoherence(positiveTags, negativeTags) {\n    // 检查风格一致性\n    const positiveStyles = this.detectStyle(positiveTags);\n    const negativeStyles = this.detectStyle(negativeTags);\n    let coherenceScore = 0.5; // 基础分数\n\n    // 风格一致性加分\n    if (positiveStyles.isStyleConsistent) {\n      coherenceScore += 0.2;\n    }\n\n    // 冲突惩罚\n    const conflicts = this.findConflicts(positiveTags, negativeTags);\n    coherenceScore -= conflicts.length * 0.1;\n    return Math.max(0, Math.min(1, coherenceScore));\n  }\n\n  /**\r\n   * 计算关系有效性\r\n   * @param {Array} conflicts - 冲突列表\r\n   * @param {Array} complements - 互补列表\r\n   * @param {Object} balance - 平衡分析\r\n   * @returns {number} 有效性分数\r\n   */\n  calculateRelationshipEffectiveness(conflicts, complements, balance) {\n    let score = 0.5;\n\n    // 互补性加分\n    score += complements.length * 0.1;\n\n    // 冲突惩罚\n    score -= conflicts.length * 0.15;\n\n    // 平衡性评分\n    if (balance.isBalanced) {\n      score += 0.2;\n    }\n    return Math.max(0, Math.min(1, score));\n  }\n\n  /**\r\n   * 生成结构建议\r\n   * @param {Array} positiveTags - 正向标签\r\n   * @param {Array} negativeTags - 负向标签\r\n   * @returns {Array} 建议列表\r\n   */\n  generateStructureSuggestions(positiveTags, negativeTags) {\n    const suggestions = [];\n\n    // 标签数量建议\n    if (positiveTags.length < 3) {\n      suggestions.push({\n        type: 'structure',\n        category: 'improvement',\n        title: '增加提示词数量',\n        description: '正向提示词较少，建议添加更多描述性标签',\n        recommendation: '添加质量标签、风格描述或细节描述',\n        impact: 'medium'\n      });\n    }\n    if (positiveTags.length > 20) {\n      suggestions.push({\n        type: 'structure',\n        category: 'warning',\n        title: '提示词过多',\n        description: '过多的提示词可能导致效果混乱',\n        recommendation: '保留最重要的标签，移除冗余内容',\n        impact: 'medium'\n      });\n    }\n    return suggestions;\n  }\n\n  /**\r\n   * 生成参数建议\r\n   * @param {Array} tags - 标签数组\r\n   * @param {Object} parameters - 参数\r\n   * @returns {Array} 建议列表\r\n   */\n  generateParameterSuggestions(tags, parameters) {\n    const suggestions = [];\n    const guidance = parameters.guidance || parameters.cfg_scale || 7;\n    const steps = parameters.steps || parameters.sampling_steps || 20;\n\n    // 引导强度建议\n    if (guidance > 15) {\n      suggestions.push({\n        type: 'parameters',\n        category: 'warning',\n        title: 'CFG Scale过高',\n        description: '过高的引导强度可能导致过拟合',\n        recommendation: '建议将CFG Scale降低到7-12之间',\n        impact: 'high'\n      });\n    }\n\n    // 步数建议\n    if (steps < 10) {\n      suggestions.push({\n        type: 'parameters',\n        category: 'improvement',\n        title: '采样步数较低',\n        description: '较低的步数可能影响图像质量',\n        recommendation: '建议将步数设置为20-30',\n        impact: 'medium'\n      });\n    }\n    return suggestions;\n  }\n\n  /**\r\n   * 生成风格建议\r\n   * @param {Array} tags - 标签数组\r\n   * @returns {Array} 建议列表\r\n   */\n  generateStyleSuggestions(tags) {\n    const suggestions = [];\n    const styleAnalysis = this.detectStyle(tags);\n    if (!styleAnalysis.isStyleConsistent) {\n      suggestions.push({\n        type: 'style',\n        category: 'warning',\n        title: '风格不一致',\n        description: '检测到多种冲突的艺术风格',\n        recommendation: '选择一种主要风格，移除冲突的风格标签',\n        impact: 'high'\n      });\n    }\n    if (styleAnalysis.confidence < 0.3) {\n      suggestions.push({\n        type: 'style',\n        category: 'improvement',\n        title: '风格定义不明确',\n        description: '缺乏明确的风格定义',\n        recommendation: '添加明确的风格标签，如\"anime\"、\"realistic\"等',\n        impact: 'medium'\n      });\n    }\n    return suggestions;\n  }\n\n  /**\r\n   * 计算建议优先级\r\n   * @param {Object} suggestion - 建议对象\r\n   * @returns {number} 优先级分数\r\n   */\n  calculateSuggestionPriority(suggestion) {\n    const impactWeights = {\n      high: 3,\n      medium: 2,\n      low: 1\n    };\n    const categoryWeights = {\n      warning: 2,\n      improvement: 1.5,\n      info: 1\n    };\n    return impactWeights[suggestion.impact] * categoryWeights[suggestion.category];\n  }\n\n  /**\r\n   * 计算建议可信度\r\n   * @param {Object} suggestion - 建议对象\r\n   * @returns {number} 可信度分数\r\n   */\n  calculateSuggestionConfidence(suggestion) {\n    // 基于建议类型和影响程度计算可信度\n    const baseConfidence = {\n      weight_optimization: 0.9,\n      structure: 0.8,\n      parameters: 0.85,\n      style: 0.75\n    };\n    return baseConfidence[suggestion.type] || 0.7;\n  }\n\n  // 辅助方法\n  areConflicting(tag1, tag2) {\n    const conflicts = [['realistic', 'anime'], ['black hair', 'blonde hair'], ['indoor', 'outdoor'], ['day', 'night']];\n    return conflicts.some(([a, b]) => tag1.includes(a) && tag2.includes(b) || tag1.includes(b) && tag2.includes(a));\n  }\n  areComplementary(positiveTag, negativeTag) {\n    const complements = [['detailed', 'blurry'], ['high quality', 'low quality'], ['beautiful', 'ugly']];\n    return complements.some(([pos, neg]) => positiveTag.includes(pos) && negativeTag.includes(neg));\n  }\n  calculateConflictSeverity(tag1, tag2) {\n    return (tag1.weight + tag2.weight) / 2;\n  }\n  calculateComplementStrength(tag1, tag2) {\n    return Math.min(tag1.weight, tag2.weight);\n  }\n  assessBalance(ratio) {\n    if (ratio < 2) return '负向权重过强';\n    if (ratio > 8) return '正向权重过强';\n    return '权重平衡合理';\n  }\n  assessGuidanceLevel(guidance) {\n    if (guidance < 5) return '引导强度较低';\n    if (guidance > 15) return '引导强度过高';\n    return '引导强度适中';\n  }\n  assessStepsEfficiency(steps) {\n    if (steps < 10) return '步数过少';\n    if (steps > 50) return '步数过多';\n    return '步数合理';\n  }\n  assessParameterBalance(params) {\n    // 综合评估参数平衡\n    return '参数配置合理';\n  }\n  getQualityLevel(score) {\n    if (score >= 0.8) return 'excellent';\n    if (score >= 0.6) return 'good';\n    if (score >= 0.4) return 'average';\n    if (score >= 0.2) return 'poor';\n    return 'very_poor';\n  }\n  identifyStrengths(positiveTags, negativeTags) {\n    const strengths = [];\n\n    // 检查质量标签\n    const hasQuality = positiveTags.some(tag => tag.special.includes('quality'));\n    if (hasQuality) strengths.push('包含质量标签');\n\n    // 检查风格明确性\n    const styleAnalysis = this.detectStyle(positiveTags);\n    if (styleAnalysis.confidence > 0.7) strengths.push('风格定义明确');\n    return strengths;\n  }\n  identifyWeaknesses(positiveTags, negativeTags) {\n    const weaknesses = [];\n\n    // 检查标签不足\n    if (positiveTags.length < 3) weaknesses.push('正向标签过少');\n    if (negativeTags.length === 0) weaknesses.push('缺少负向标签');\n    return weaknesses;\n  }\n}\nexport default AdvancedPromptAnalyzer;","map":{"version":3,"names":["AdvancedPromptAnalyzer","constructor","config","weightThresholds","high","medium","low","semanticCategories","character","style","quality","composition","lighting","color","emotion","environment","novelaiWeights","analyzePrompts","positivePrompt","negativePrompt","parameters","result","positive","analyzePromptText","negative","relationships","analyzeRelationships","analyzeParameters","assessPromptQuality","suggestions","generateSuggestions","metadata","analyzedAt","Date","toISOString","analyzerVersion","source","promptText","type","getEmptyAnalysis","tags","parsePromptTags","weightAnalysis","analyzeWeights","semanticGroups","categorizeSemantics","complexity","analyzeComplexity","styleAnalysis","detectStyle","originalText","parsed","count","length","weighted","weightedTags","emphasized","emphasizedTags","semantics","weights","structure","analyzeStructure","effectiveness","calculateEffectiveness","text","basicTags","split","map","tag","trim","filter","parsedTag","parseIndividualTag","push","tagText","cleanText","weight","emphasis","brackets","patterns","regex","pattern","match","parseFloat","specialMarkers","detectSpecialMarkers","original","special","category","categorizeTag","importance","calculateTagImportance","weightDistribution","normal","deemphasized","avgWeight","reduce","sum","maxWeight","Math","max","minWeight","min","distribution","statistics","average","maximum","minimum","range","sort","a","b","categories","Object","keys","forEach","other","categorized","keywords","entries","some","keyword","toLowerCase","includes","categoryStats","categoryTags","maxImportance","averageWeight","dominance","dominantCategory","findDominantCategory","uniqueWeights","Set","hasCustomWeights","hasMultipleBrackets","hasSpecialMarkers","complexityScore","calculateComplexityScore","score","level","getComplexityLevel","factors","tagCount","size","averageTagLength","assessment","assessComplexity","_detectedStyles$prima","styleIndicators","anime","realistic","artistic","fantasy","cyberpunk","vintage","detectedStyles","primaryStyle","maxScore","indicators","matchingTags","indicator","confidence","primary","detected","isStyleConsistent","positiveTags","negativeTags","conflicts","findConflicts","complements","findComplements","balance","analyzeBalance","coherence","calculateCoherence","calculateRelationshipEffectiveness","generateWeightSuggestions","generateStructureSuggestions","generateParameterSuggestions","generateStyleSuggestions","suggestion","priority","calculateSuggestionPriority","calculateSuggestionConfidence","overEmphasized","title","description","affectedTags","recommendation","impact","weightRange","toFixed","qualityKeywords","lengthFactor","markers","qualityMarkers","marker","lowerText","hasComplexSyntax","avgLength","assessments","weightBalance","abs","hasQuality","textLength","lengthScore","wordCount","hasWeights","test","hasColonWeights","hasArtistTags","hasCopyrightTags","analysis","guidance","cfg_scale","steps","sampling_steps","sampler","sampling_method","seed","width","height","model","guidanceLevel","assessGuidanceLevel","stepsEfficiency","assessStepsEfficiency","overallBalance","assessParameterBalance","positiveScore","negativeScore","overallScore","overall","getQualityLevel","strengths","identifyStrengths","weaknesses","identifyWeaknesses","maxDominance","stats","positiveTag","negativeTag","areConflicting","severity","calculateConflictSeverity","areComplementary","strength","calculateComplementStrength","positiveWeight","negativeWeight","ratio","assessBalance","isBalanced","positiveStyles","negativeStyles","coherenceScore","impactWeights","categoryWeights","warning","improvement","info","baseConfidence","weight_optimization","tag1","tag2","pos","neg","params"],"sources":["C:/Users/wjx19/Documents/GitHub/I-Prompt/src/utils/advancedPromptAnalyzer.js"],"sourcesContent":["/**\r\n * 高级提示词分析器\r\n * 融合NovelAI Spell项目和Live Context技术的智能提示词解析功能\r\n */\r\n\r\nexport class AdvancedPromptAnalyzer {\r\n  \r\n  constructor() {\r\n    // 初始化分析配置\r\n    this.config = {\r\n      // 提示词权重阈值\r\n      weightThresholds: {\r\n        high: 1.2,\r\n        medium: 1.0,\r\n        low: 0.8\r\n      },\r\n      // 语义类别\r\n      semanticCategories: {\r\n        character: ['girl', 'boy', 'woman', 'man', 'person', 'character'],\r\n        style: ['anime', 'realistic', 'cartoon', 'painting', 'digital art'],\r\n        quality: ['masterpiece', 'best quality', 'high resolution', 'detailed'],\r\n        composition: ['portrait', 'full body', 'close-up', 'wide shot'],\r\n        lighting: ['soft lighting', 'dramatic lighting', 'natural light'],\r\n        color: ['colorful', 'monochrome', 'vibrant', 'pastel'],\r\n        emotion: ['happy', 'sad', 'angry', 'peaceful', 'excited'],\r\n        environment: ['indoor', 'outdoor', 'nature', 'city', 'fantasy']\r\n      },\r\n      // NovelAI特定标签权重映射\r\n      novelaiWeights: {\r\n        '{{': 1.05,\r\n        '((': 1.21,\r\n        '[': 0.9,\r\n        '[[': 0.81\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * 分析提示词的完整结构\r\n   * @param {string} positivePrompt - 正向提示词\r\n   * @param {string} negativePrompt - 负向提示词\r\n   * @param {Object} parameters - 生成参数\r\n   * @returns {Object} 详细分析结果\r\n   */\r\n  analyzePrompts(positivePrompt, negativePrompt, parameters = {}) {\r\n    const result = {\r\n      positive: this.analyzePromptText(positivePrompt, 'positive'),\r\n      negative: this.analyzePromptText(negativePrompt, 'negative'),\r\n      relationships: this.analyzeRelationships(positivePrompt, negativePrompt),\r\n      parameters: this.analyzeParameters(parameters),\r\n      quality: this.assessPromptQuality(positivePrompt, negativePrompt),\r\n      suggestions: this.generateSuggestions(positivePrompt, negativePrompt, parameters),\r\n      metadata: {\r\n        analyzedAt: new Date().toISOString(),\r\n        analyzerVersion: '2.0',\r\n        source: 'advanced-prompt-analyzer'\r\n      }\r\n    };\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * 分析单个提示词文本\r\n   * @param {string} promptText - 提示词文本\r\n   * @param {string} type - 类型 (positive/negative)\r\n   * @returns {Object} 分析结果\r\n   */\r\n  analyzePromptText(promptText, type = 'positive') {\r\n    if (!promptText || typeof promptText !== 'string') {\r\n      return this.getEmptyAnalysis();\r\n    }\r\n\r\n    // 解析提示词标签\r\n    const tags = this.parsePromptTags(promptText);\r\n    \r\n    // 分析权重和强调\r\n    const weightAnalysis = this.analyzeWeights(tags);\r\n    \r\n    // 语义分类\r\n    const semanticGroups = this.categorizeSemantics(tags);\r\n    \r\n    // 复杂度分析\r\n    const complexity = this.analyzeComplexity(tags);\r\n    \r\n    // 风格检测\r\n    const styleAnalysis = this.detectStyle(tags);\r\n\r\n    return {\r\n      originalText: promptText,\r\n      type,\r\n      tags: {\r\n        parsed: tags,\r\n        count: tags.length,\r\n        weighted: weightAnalysis.weightedTags,\r\n        emphasized: weightAnalysis.emphasizedTags\r\n      },\r\n      semantics: semanticGroups,\r\n      weights: weightAnalysis,\r\n      complexity,\r\n      style: styleAnalysis,\r\n      structure: this.analyzeStructure(promptText),\r\n      effectiveness: this.calculateEffectiveness(tags, type)\r\n    };\r\n  }\r\n\r\n  /**\r\n   * 解析提示词标签 - 支持多种权重格式\r\n   * @param {string} text - 提示词文本\r\n   * @returns {Array} 解析后的标签数组\r\n   */\r\n  parsePromptTags(text) {\r\n    const tags = [];\r\n    \r\n    // 分割基本标签（逗号分隔）\r\n    const basicTags = text.split(',').map(tag => tag.trim()).filter(tag => tag.length > 0);\r\n    \r\n    for (const tag of basicTags) {\r\n      const parsedTag = this.parseIndividualTag(tag);\r\n      if (parsedTag) {\r\n        tags.push(parsedTag);\r\n      }\r\n    }\r\n    \r\n    return tags;\r\n  }\r\n\r\n  /**\r\n   * 解析单个标签的权重和格式\r\n   * @param {string} tagText - 单个标签文本\r\n   * @returns {Object} 解析结果\r\n   */\r\n  parseIndividualTag(tagText) {\r\n    let cleanText = tagText.trim();\r\n    let weight = 1.0;\r\n    let emphasis = 'normal';\r\n    let brackets = [];\r\n\r\n    // NovelAI风格权重解析\r\n    const patterns = [\r\n      { regex: /^\\{\\{(.+?)\\}\\}$/, weight: 1.05, emphasis: 'light', type: 'double_curly' },\r\n      { regex: /^\\{(.+?)\\}$/, weight: 1.02, emphasis: 'very_light', type: 'single_curly' },\r\n      { regex: /^\\(\\((.+?)\\)\\)$/, weight: 1.21, emphasis: 'strong', type: 'double_round' },\r\n      { regex: /^\\((.+?)\\)$/, weight: 1.1, emphasis: 'medium', type: 'single_round' },\r\n      { regex: /^\\[\\[(.+?)\\]\\]$/, weight: 0.81, emphasis: 'weak', type: 'double_square' },\r\n      { regex: /^\\[(.+?)\\]$/, weight: 0.9, emphasis: 'light_negative', type: 'single_square' },\r\n      { regex: /^(.+?):(\\d*\\.?\\d+)$/, weight: 'custom', emphasis: 'custom', type: 'colon_weight' }\r\n    ];\r\n\r\n    // 检查权重模式\r\n    for (const pattern of patterns) {\r\n      const match = cleanText.match(pattern.regex);\r\n      if (match) {\r\n        cleanText = match[1];\r\n        \r\n        if (pattern.weight === 'custom') {\r\n          weight = parseFloat(match[2]);\r\n          emphasis = weight > 1.0 ? 'custom_positive' : weight < 1.0 ? 'custom_negative' : 'normal';\r\n        } else {\r\n          weight = pattern.weight;\r\n          emphasis = pattern.emphasis;\r\n        }\r\n        \r\n        brackets.push(pattern.type);\r\n        break;\r\n      }\r\n    }\r\n\r\n    // 检测特殊标记\r\n    const specialMarkers = this.detectSpecialMarkers(cleanText);\r\n\r\n    return {\r\n      original: tagText,\r\n      text: cleanText,\r\n      weight,\r\n      emphasis,\r\n      brackets,\r\n      special: specialMarkers,\r\n      category: this.categorizeTag(cleanText),\r\n      importance: this.calculateTagImportance(cleanText, weight)\r\n    };\r\n  }\r\n\r\n  /**\r\n   * 分析权重分布\r\n   * @param {Array} tags - 标签数组\r\n   * @returns {Object} 权重分析结果\r\n   */\r\n  analyzeWeights(tags) {\r\n    const weightDistribution = {\r\n      emphasized: tags.filter(tag => tag.weight > 1.0),\r\n      normal: tags.filter(tag => tag.weight === 1.0),\r\n      deemphasized: tags.filter(tag => tag.weight < 1.0)\r\n    };\r\n\r\n    const avgWeight = tags.reduce((sum, tag) => sum + tag.weight, 0) / tags.length;\r\n    const maxWeight = Math.max(...tags.map(tag => tag.weight));\r\n    const minWeight = Math.min(...tags.map(tag => tag.weight));\r\n\r\n    return {\r\n      distribution: weightDistribution,\r\n      statistics: {\r\n        average: avgWeight,\r\n        maximum: maxWeight,\r\n        minimum: minWeight,\r\n        range: maxWeight - minWeight\r\n      },\r\n      weightedTags: tags.filter(tag => tag.weight !== 1.0),\r\n      emphasizedTags: tags.filter(tag => tag.weight > 1.0).sort((a, b) => b.weight - a.weight)\r\n    };\r\n  }\r\n\r\n  /**\r\n   * 语义分类\r\n   * @param {Array} tags - 标签数组\r\n   * @returns {Object} 分类结果\r\n   */\r\n  categorizeSemantics(tags) {\r\n    const categories = {};\r\n    \r\n    // 初始化分类\r\n    Object.keys(this.config.semanticCategories).forEach(category => {\r\n      categories[category] = [];\r\n    });\r\n    categories.other = [];\r\n\r\n    // 分类标签\r\n    tags.forEach(tag => {\r\n      let categorized = false;\r\n      \r\n      for (const [category, keywords] of Object.entries(this.config.semanticCategories)) {\r\n        if (keywords.some(keyword => tag.text.toLowerCase().includes(keyword.toLowerCase()))) {\r\n          categories[category].push(tag);\r\n          categorized = true;\r\n          break;\r\n        }\r\n      }\r\n      \r\n      if (!categorized) {\r\n        categories.other.push(tag);\r\n      }\r\n    });\r\n\r\n    // 统计每个分类的权重和重要性\r\n    const categoryStats = {};\r\n    Object.entries(categories).forEach(([category, categoryTags]) => {\r\n      if (categoryTags.length > 0) {\r\n        const avgWeight = categoryTags.reduce((sum, tag) => sum + tag.weight, 0) / categoryTags.length;\r\n        const maxImportance = Math.max(...categoryTags.map(tag => tag.importance));\r\n        \r\n        categoryStats[category] = {\r\n          count: categoryTags.length,\r\n          averageWeight: avgWeight,\r\n          maxImportance,\r\n          dominance: categoryTags.length / tags.length\r\n        };\r\n      }\r\n    });\r\n\r\n    return {\r\n      categories,\r\n      statistics: categoryStats,\r\n      dominantCategory: this.findDominantCategory(categoryStats)\r\n    };\r\n  }\r\n\r\n  /**\r\n   * 分析提示词复杂度\r\n   * @param {Array} tags - 标签数组\r\n   * @returns {Object} 复杂度分析\r\n   */\r\n  analyzeComplexity(tags) {\r\n    const uniqueWeights = new Set(tags.map(tag => tag.weight));\r\n    const hasCustomWeights = tags.some(tag => tag.brackets.includes('colon_weight'));\r\n    const hasMultipleBrackets = tags.some(tag => tag.brackets.length > 1);\r\n    const hasSpecialMarkers = tags.some(tag => tag.special.length > 0);\r\n\r\n    const complexityScore = this.calculateComplexityScore(tags);\r\n\r\n    return {\r\n      score: complexityScore,\r\n      level: this.getComplexityLevel(complexityScore),\r\n      factors: {\r\n        tagCount: tags.length,\r\n        uniqueWeights: uniqueWeights.size,\r\n        hasCustomWeights,\r\n        hasMultipleBrackets,\r\n        hasSpecialMarkers,\r\n        averageTagLength: tags.reduce((sum, tag) => sum + tag.text.length, 0) / tags.length\r\n      },\r\n      assessment: this.assessComplexity(complexityScore)\r\n    };\r\n  }\r\n\r\n  /**\r\n   * 风格检测\r\n   * @param {Array} tags - 标签数组\r\n   * @returns {Object} 风格分析\r\n   */\r\n  detectStyle(tags) {\r\n    const styleIndicators = {\r\n      anime: ['anime', 'manga', 'kawaii', 'chibi', 'moe'],\r\n      realistic: ['realistic', 'photorealistic', 'photography', 'photo'],\r\n      artistic: ['painting', 'artwork', 'illustration', 'drawing'],\r\n      fantasy: ['fantasy', 'magical', 'mystical', 'ethereal'],\r\n      cyberpunk: ['cyberpunk', 'neon', 'futuristic', 'sci-fi'],\r\n      vintage: ['vintage', 'retro', 'classic', 'old-fashioned']\r\n    };\r\n\r\n    const detectedStyles = {};\r\n    let primaryStyle = 'mixed';\r\n    let maxScore = 0;\r\n\r\n    Object.entries(styleIndicators).forEach(([style, indicators]) => {\r\n      const matchingTags = tags.filter(tag => \r\n        indicators.some(indicator => \r\n          tag.text.toLowerCase().includes(indicator.toLowerCase())\r\n        )\r\n      );\r\n      \r\n      if (matchingTags.length > 0) {\r\n        const score = matchingTags.reduce((sum, tag) => sum + tag.weight * tag.importance, 0);\r\n        detectedStyles[style] = {\r\n          score,\r\n          matchingTags,\r\n          confidence: Math.min(score / tags.length, 1.0)\r\n        };\r\n        \r\n        if (score > maxScore) {\r\n          maxScore = score;\r\n          primaryStyle = style;\r\n        }\r\n      }\r\n    });\r\n\r\n    return {\r\n      primary: primaryStyle,\r\n      detected: detectedStyles,\r\n      confidence: maxScore > 0 ? detectedStyles[primaryStyle]?.confidence : 0,\r\n      isStyleConsistent: Object.keys(detectedStyles).length <= 2\r\n    };\r\n  }\r\n\r\n  /**\r\n   * 分析提示词之间的关系\r\n   * @param {string} positive - 正向提示词\r\n   * @param {string} negative - 负向提示词\r\n   * @returns {Object} 关系分析\r\n   */\r\n  analyzeRelationships(positive, negative) {\r\n    const positiveTags = this.parsePromptTags(positive || '');\r\n    const negativeTags = this.parsePromptTags(negative || '');\r\n\r\n    // 检查冲突\r\n    const conflicts = this.findConflicts(positiveTags, negativeTags);\r\n    \r\n    // 检查互补性\r\n    const complements = this.findComplements(positiveTags, negativeTags);\r\n    \r\n    // 平衡性分析\r\n    const balance = this.analyzeBalance(positiveTags, negativeTags);\r\n\r\n    return {\r\n      conflicts,\r\n      complements,\r\n      balance,\r\n      coherence: this.calculateCoherence(positiveTags, negativeTags),\r\n      effectiveness: this.calculateRelationshipEffectiveness(conflicts, complements, balance)\r\n    };\r\n  }\r\n\r\n  /**\r\n   * 生成智能建议\r\n   * @param {string} positive - 正向提示词\r\n   * @param {string} negative - 负向提示词\r\n   * @param {Object} parameters - 生成参数\r\n   * @returns {Array} 建议数组\r\n   */\r\n  generateSuggestions(positive, negative, parameters) {\r\n    const suggestions = [];\r\n    const positiveTags = this.parsePromptTags(positive || '');\r\n    const negativeTags = this.parsePromptTags(negative || '');\r\n\r\n    // 权重优化建议\r\n    suggestions.push(...this.generateWeightSuggestions(positiveTags));\r\n    \r\n    // 结构优化建议\r\n    suggestions.push(...this.generateStructureSuggestions(positiveTags, negativeTags));\r\n    \r\n    // 参数匹配建议\r\n    suggestions.push(...this.generateParameterSuggestions(positiveTags, parameters));\r\n    \r\n    // 风格一致性建议\r\n    suggestions.push(...this.generateStyleSuggestions(positiveTags));\r\n\r\n    return suggestions.map(suggestion => ({\r\n      ...suggestion,\r\n      priority: this.calculateSuggestionPriority(suggestion),\r\n      confidence: this.calculateSuggestionConfidence(suggestion)\r\n    })).sort((a, b) => b.priority - a.priority);\r\n  }\r\n\r\n  /**\r\n   * 生成权重优化建议\r\n   * @param {Array} tags - 标签数组\r\n   * @returns {Array} 建议数组\r\n   */\r\n  generateWeightSuggestions(tags) {\r\n    const suggestions = [];\r\n    \r\n    // 检查过度强调\r\n    const overEmphasized = tags.filter(tag => tag.weight > 1.3);\r\n    if (overEmphasized.length > 0) {\r\n      suggestions.push({\r\n        type: 'weight_optimization',\r\n        category: 'warning',\r\n        title: '过度强调检测',\r\n        description: `发现${overEmphasized.length}个过度强调的标签，可能导致生成效果不自然`,\r\n        affectedTags: overEmphasized.map(tag => tag.original),\r\n        recommendation: '建议将权重降低到1.2以下',\r\n        impact: 'medium'\r\n      });\r\n    }\r\n\r\n    // 检查权重不平衡\r\n    const weights = tags.map(tag => tag.weight);\r\n    const weightRange = Math.max(...weights) - Math.min(...weights);\r\n    if (weightRange > 0.5) {\r\n      suggestions.push({\r\n        type: 'weight_optimization',\r\n        category: 'improvement',\r\n        title: '权重平衡优化',\r\n        description: `权重范围过大(${weightRange.toFixed(2)})，建议调整以获得更平衡的效果`,\r\n        recommendation: '考虑缩小权重差异，保持在0.3范围内',\r\n        impact: 'low'\r\n      });\r\n    }\r\n\r\n    return suggestions;\r\n  }\r\n\r\n  /**\r\n   * 计算标签重要性\r\n   * @param {string} text - 标签文本\r\n   * @param {number} weight - 标签权重\r\n   * @returns {number} 重要性分数\r\n   */\r\n  calculateTagImportance(text, weight) {\r\n    let importance = weight;\r\n    \r\n    // 质量词汇加分\r\n    const qualityKeywords = ['masterpiece', 'best quality', 'high resolution', 'detailed'];\r\n    if (qualityKeywords.some(keyword => text.toLowerCase().includes(keyword))) {\r\n      importance += 0.2;\r\n    }\r\n    \r\n    // 长度因子\r\n    const lengthFactor = Math.min(text.length / 20, 1.0);\r\n    importance += lengthFactor * 0.1;\r\n    \r\n    return Math.min(importance, 2.0);\r\n  }\r\n\r\n  /**\r\n   * 检测特殊标记\r\n   * @param {string} text - 文本\r\n   * @returns {Array} 特殊标记数组\r\n   */\r\n  detectSpecialMarkers(text) {\r\n    const markers = [];\r\n    \r\n    // 艺术家标记\r\n    if (text.includes('by ') || text.includes('artist:')) {\r\n      markers.push('artist');\r\n    }\r\n    \r\n    // 版权标记\r\n    if (text.includes('©') || text.includes('copyright')) {\r\n      markers.push('copyright');\r\n    }\r\n    \r\n    // 质量标记\r\n    const qualityMarkers = ['masterpiece', 'best quality', 'high quality'];\r\n    if (qualityMarkers.some(marker => text.toLowerCase().includes(marker))) {\r\n      markers.push('quality');\r\n    }\r\n    \r\n    return markers;\r\n  }\r\n\r\n  /**\r\n   * 分类单个标签\r\n   * @param {string} text - 标签文本\r\n   * @returns {string} 分类结果\r\n   */\r\n  categorizeTag(text) {\r\n    const lowerText = text.toLowerCase();\r\n    \r\n    for (const [category, keywords] of Object.entries(this.config.semanticCategories)) {\r\n      if (keywords.some(keyword => lowerText.includes(keyword))) {\r\n        return category;\r\n      }\r\n    }\r\n    \r\n    return 'other';\r\n  }\r\n\r\n  /**\r\n   * 获取空分析结果\r\n   * @returns {Object} 空结果\r\n   */\r\n  getEmptyAnalysis() {\r\n    return {\r\n      originalText: '',\r\n      type: 'unknown',\r\n      tags: { parsed: [], count: 0, weighted: [], emphasized: [] },\r\n      semantics: { categories: {}, statistics: {}, dominantCategory: null },\r\n      weights: { distribution: {}, statistics: {}, weightedTags: [], emphasizedTags: [] },\r\n      complexity: { score: 0, level: 'none', factors: {}, assessment: '' },\r\n      style: { primary: 'none', detected: {}, confidence: 0, isStyleConsistent: true },\r\n      structure: {},\r\n      effectiveness: 0\r\n    };\r\n  }\r\n\r\n  /**\r\n   * 计算复杂度分数\r\n   * @param {Array} tags - 标签数组\r\n   * @returns {number} 复杂度分数\r\n   */\r\n  calculateComplexityScore(tags) {\r\n    let score = 0;\r\n    \r\n    // 基础分数：标签数量\r\n    score += Math.min(tags.length / 10, 1.0) * 0.3;\r\n    \r\n    // 权重复杂度\r\n    const uniqueWeights = new Set(tags.map(tag => tag.weight));\r\n    score += Math.min(uniqueWeights.size / 5, 1.0) * 0.2;\r\n    \r\n    // 语法复杂度\r\n    const hasComplexSyntax = tags.some(tag => tag.brackets.length > 0);\r\n    if (hasComplexSyntax) score += 0.2;\r\n    \r\n    // 特殊标记\r\n    const hasSpecialMarkers = tags.some(tag => tag.special.length > 0);\r\n    if (hasSpecialMarkers) score += 0.1;\r\n    \r\n    // 平均标签长度\r\n    const avgLength = tags.reduce((sum, tag) => sum + tag.text.length, 0) / tags.length;\r\n    score += Math.min(avgLength / 20, 1.0) * 0.2;\r\n    \r\n    return Math.min(score, 1.0);\r\n  }\r\n\r\n  /**\r\n   * 获取复杂度等级\r\n   * @param {number} score - 复杂度分数\r\n   * @returns {string} 复杂度等级\r\n   */\r\n  getComplexityLevel(score) {\r\n    if (score >= 0.8) return 'very_high';\r\n    if (score >= 0.6) return 'high';\r\n    if (score >= 0.4) return 'medium';\r\n    if (score >= 0.2) return 'low';\r\n    return 'very_low';\r\n  }\r\n\r\n  /**\r\n   * 评估复杂度\r\n   * @param {number} score - 复杂度分数\r\n   * @returns {string} 评估结果\r\n   */\r\n  assessComplexity(score) {\r\n    const level = this.getComplexityLevel(score);\r\n    const assessments = {\r\n      'very_high': '非常复杂的提示词结构，建议适当简化',\r\n      'high': '相对复杂的提示词，注意权重平衡',\r\n      'medium': '中等复杂度，结构合理',\r\n      'low': '简单的提示词结构，可考虑添加更多细节',\r\n      'very_low': '非常简单的结构，建议增加描述性标签'\r\n    };\r\n    \r\n    return assessments[level] || '无法评估';\r\n  }\r\n\r\n  /**\r\n   * 计算提示词效果评分\r\n   * @param {Array} tags - 标签数组\r\n   * @param {string} type - 类型\r\n   * @returns {number} 效果评分\r\n   */\r\n  calculateEffectiveness(tags, type) {\r\n    if (tags.length === 0) return 0;\r\n    \r\n    let score = 0;\r\n    \r\n    // 基础分数：标签多样性\r\n    const categories = new Set(tags.map(tag => tag.category));\r\n    score += Math.min(categories.size / 8, 1.0) * 0.3;\r\n    \r\n    // 权重合理性\r\n    const avgWeight = tags.reduce((sum, tag) => sum + tag.weight, 0) / tags.length;\r\n    const weightBalance = 1 - Math.abs(avgWeight - 1.0);\r\n    score += weightBalance * 0.2;\r\n    \r\n    // 质量标签存在\r\n    const hasQuality = tags.some(tag => tag.special.includes('quality'));\r\n    if (hasQuality) score += 0.2;\r\n    \r\n    // 长度适中性\r\n    const textLength = tags.reduce((sum, tag) => sum + tag.text.length, 0);\r\n    const lengthScore = Math.max(0, 1 - Math.abs(textLength - 100) / 200);\r\n    score += lengthScore * 0.3;\r\n    \r\n    return Math.min(score, 1.0);\r\n  }\r\n\r\n  /**\r\n   * 分析结构特征\r\n   * @param {string} promptText - 提示词文本\r\n   * @returns {Object} 结构分析\r\n   */\r\n  analyzeStructure(promptText) {\r\n    return {\r\n      length: promptText.length,\r\n      wordCount: promptText.split(/\\s+/).length,\r\n      tagCount: promptText.split(',').length,\r\n      hasWeights: /[\\(\\[\\{]/.test(promptText),\r\n      hasColonWeights: /:[\\d\\.]+/.test(promptText),\r\n      hasArtistTags: /by\\s+/.test(promptText),\r\n      hasCopyrightTags: /©|\\(.*\\)/.test(promptText)\r\n    };\r\n  }\r\n\r\n  /**\r\n   * 分析生成参数\r\n   * @param {Object} parameters - 生成参数\r\n   * @returns {Object} 参数分析\r\n   */\r\n  analyzeParameters(parameters) {\r\n    const analysis = {\r\n      guidance: parameters.guidance || parameters.cfg_scale || 7,\r\n      steps: parameters.steps || parameters.sampling_steps || 20,\r\n      sampler: parameters.sampler || parameters.sampling_method || 'unknown',\r\n      seed: parameters.seed || -1,\r\n      size: parameters.size || `${parameters.width || 512}x${parameters.height || 512}`,\r\n      model: parameters.model || 'unknown'\r\n    };\r\n\r\n    // 参数合理性检查\r\n    analysis.assessment = {\r\n      guidanceLevel: this.assessGuidanceLevel(analysis.guidance),\r\n      stepsEfficiency: this.assessStepsEfficiency(analysis.steps),\r\n      overallBalance: this.assessParameterBalance(analysis)\r\n    };\r\n\r\n    return analysis;\r\n  }\r\n\r\n  /**\r\n   * 评估提示词质量\r\n   * @param {string} positive - 正向提示词\r\n   * @param {string} negative - 负向提示词\r\n   * @returns {Object} 质量评估\r\n   */\r\n  assessPromptQuality(positive, negative) {\r\n    const positiveTags = this.parsePromptTags(positive || '');\r\n    const negativeTags = this.parsePromptTags(negative || '');\r\n\r\n    const positiveScore = this.calculateEffectiveness(positiveTags, 'positive');\r\n    const negativeScore = this.calculateEffectiveness(negativeTags, 'negative');\r\n    \r\n    const overallScore = (positiveScore * 0.7 + negativeScore * 0.3);\r\n    \r\n    return {\r\n      overall: overallScore,\r\n      positive: positiveScore,\r\n      negative: negativeScore,\r\n      level: this.getQualityLevel(overallScore),\r\n      strengths: this.identifyStrengths(positiveTags, negativeTags),\r\n      weaknesses: this.identifyWeaknesses(positiveTags, negativeTags)\r\n    };\r\n  }\r\n\r\n  /**\r\n   * 寻找主导分类\r\n   * @param {Object} categoryStats - 分类统计\r\n   * @returns {string} 主导分类\r\n   */\r\n  findDominantCategory(categoryStats) {\r\n    let maxDominance = 0;\r\n    let dominantCategory = null;\r\n\r\n    Object.entries(categoryStats).forEach(([category, stats]) => {\r\n      if (stats.dominance > maxDominance) {\r\n        maxDominance = stats.dominance;\r\n        dominantCategory = category;\r\n      }\r\n    });\r\n\r\n    return dominantCategory;\r\n  }\r\n\r\n  /**\r\n   * 查找冲突\r\n   * @param {Array} positiveTags - 正向标签\r\n   * @param {Array} negativeTags - 负向标签\r\n   * @returns {Array} 冲突列表\r\n   */\r\n  findConflicts(positiveTags, negativeTags) {\r\n    const conflicts = [];\r\n    \r\n    positiveTags.forEach(positiveTag => {\r\n      negativeTags.forEach(negativeTag => {\r\n        if (this.areConflicting(positiveTag.text, negativeTag.text)) {\r\n          conflicts.push({\r\n            positive: positiveTag,\r\n            negative: negativeTag,\r\n            severity: this.calculateConflictSeverity(positiveTag, negativeTag)\r\n          });\r\n        }\r\n      });\r\n    });\r\n\r\n    return conflicts;\r\n  }\r\n\r\n  /**\r\n   * 查找互补关系\r\n   * @param {Array} positiveTags - 正向标签\r\n   * @param {Array} negativeTags - 负向标签\r\n   * @returns {Array} 互补关系列表\r\n   */\r\n  findComplements(positiveTags, negativeTags) {\r\n    const complements = [];\r\n    \r\n    positiveTags.forEach(positiveTag => {\r\n      negativeTags.forEach(negativeTag => {\r\n        if (this.areComplementary(positiveTag.text, negativeTag.text)) {\r\n          complements.push({\r\n            positive: positiveTag,\r\n            negative: negativeTag,\r\n            strength: this.calculateComplementStrength(positiveTag, negativeTag)\r\n          });\r\n        }\r\n      });\r\n    });\r\n\r\n    return complements;\r\n  }\r\n\r\n  /**\r\n   * 分析平衡性\r\n   * @param {Array} positiveTags - 正向标签\r\n   * @param {Array} negativeTags - 负向标签\r\n   * @returns {Object} 平衡性分析\r\n   */\r\n  analyzeBalance(positiveTags, negativeTags) {\r\n    const positiveWeight = positiveTags.reduce((sum, tag) => sum + tag.weight, 0);\r\n    const negativeWeight = negativeTags.reduce((sum, tag) => sum + tag.weight, 0);\r\n    \r\n    const ratio = positiveWeight / Math.max(negativeWeight, 0.1);\r\n    \r\n    return {\r\n      positiveWeight,\r\n      negativeWeight,\r\n      ratio,\r\n      assessment: this.assessBalance(ratio),\r\n      isBalanced: ratio >= 2 && ratio <= 8\r\n    };\r\n  }\r\n\r\n  /**\r\n   * 计算一致性\r\n   * @param {Array} positiveTags - 正向标签\r\n   * @param {Array} negativeTags - 负向标签\r\n   * @returns {number} 一致性分数\r\n   */\r\n  calculateCoherence(positiveTags, negativeTags) {\r\n    // 检查风格一致性\r\n    const positiveStyles = this.detectStyle(positiveTags);\r\n    const negativeStyles = this.detectStyle(negativeTags);\r\n    \r\n    let coherenceScore = 0.5; // 基础分数\r\n    \r\n    // 风格一致性加分\r\n    if (positiveStyles.isStyleConsistent) {\r\n      coherenceScore += 0.2;\r\n    }\r\n    \r\n    // 冲突惩罚\r\n    const conflicts = this.findConflicts(positiveTags, negativeTags);\r\n    coherenceScore -= conflicts.length * 0.1;\r\n    \r\n    return Math.max(0, Math.min(1, coherenceScore));\r\n  }\r\n\r\n  /**\r\n   * 计算关系有效性\r\n   * @param {Array} conflicts - 冲突列表\r\n   * @param {Array} complements - 互补列表\r\n   * @param {Object} balance - 平衡分析\r\n   * @returns {number} 有效性分数\r\n   */\r\n  calculateRelationshipEffectiveness(conflicts, complements, balance) {\r\n    let score = 0.5;\r\n    \r\n    // 互补性加分\r\n    score += complements.length * 0.1;\r\n    \r\n    // 冲突惩罚\r\n    score -= conflicts.length * 0.15;\r\n    \r\n    // 平衡性评分\r\n    if (balance.isBalanced) {\r\n      score += 0.2;\r\n    }\r\n    \r\n    return Math.max(0, Math.min(1, score));\r\n  }\r\n\r\n  /**\r\n   * 生成结构建议\r\n   * @param {Array} positiveTags - 正向标签\r\n   * @param {Array} negativeTags - 负向标签\r\n   * @returns {Array} 建议列表\r\n   */\r\n  generateStructureSuggestions(positiveTags, negativeTags) {\r\n    const suggestions = [];\r\n    \r\n    // 标签数量建议\r\n    if (positiveTags.length < 3) {\r\n      suggestions.push({\r\n        type: 'structure',\r\n        category: 'improvement',\r\n        title: '增加提示词数量',\r\n        description: '正向提示词较少，建议添加更多描述性标签',\r\n        recommendation: '添加质量标签、风格描述或细节描述',\r\n        impact: 'medium'\r\n      });\r\n    }\r\n    \r\n    if (positiveTags.length > 20) {\r\n      suggestions.push({\r\n        type: 'structure',\r\n        category: 'warning',\r\n        title: '提示词过多',\r\n        description: '过多的提示词可能导致效果混乱',\r\n        recommendation: '保留最重要的标签，移除冗余内容',\r\n        impact: 'medium'\r\n      });\r\n    }\r\n\r\n    return suggestions;\r\n  }\r\n\r\n  /**\r\n   * 生成参数建议\r\n   * @param {Array} tags - 标签数组\r\n   * @param {Object} parameters - 参数\r\n   * @returns {Array} 建议列表\r\n   */\r\n  generateParameterSuggestions(tags, parameters) {\r\n    const suggestions = [];\r\n    \r\n    const guidance = parameters.guidance || parameters.cfg_scale || 7;\r\n    const steps = parameters.steps || parameters.sampling_steps || 20;\r\n    \r\n    // 引导强度建议\r\n    if (guidance > 15) {\r\n      suggestions.push({\r\n        type: 'parameters',\r\n        category: 'warning',\r\n        title: 'CFG Scale过高',\r\n        description: '过高的引导强度可能导致过拟合',\r\n        recommendation: '建议将CFG Scale降低到7-12之间',\r\n        impact: 'high'\r\n      });\r\n    }\r\n    \r\n    // 步数建议\r\n    if (steps < 10) {\r\n      suggestions.push({\r\n        type: 'parameters',\r\n        category: 'improvement',\r\n        title: '采样步数较低',\r\n        description: '较低的步数可能影响图像质量',\r\n        recommendation: '建议将步数设置为20-30',\r\n        impact: 'medium'\r\n      });\r\n    }\r\n\r\n    return suggestions;\r\n  }\r\n\r\n  /**\r\n   * 生成风格建议\r\n   * @param {Array} tags - 标签数组\r\n   * @returns {Array} 建议列表\r\n   */\r\n  generateStyleSuggestions(tags) {\r\n    const suggestions = [];\r\n    const styleAnalysis = this.detectStyle(tags);\r\n    \r\n    if (!styleAnalysis.isStyleConsistent) {\r\n      suggestions.push({\r\n        type: 'style',\r\n        category: 'warning',\r\n        title: '风格不一致',\r\n        description: '检测到多种冲突的艺术风格',\r\n        recommendation: '选择一种主要风格，移除冲突的风格标签',\r\n        impact: 'high'\r\n      });\r\n    }\r\n    \r\n    if (styleAnalysis.confidence < 0.3) {\r\n      suggestions.push({\r\n        type: 'style',\r\n        category: 'improvement',\r\n        title: '风格定义不明确',\r\n        description: '缺乏明确的风格定义',\r\n        recommendation: '添加明确的风格标签，如\"anime\"、\"realistic\"等',\r\n        impact: 'medium'\r\n      });\r\n    }\r\n\r\n    return suggestions;\r\n  }\r\n\r\n  /**\r\n   * 计算建议优先级\r\n   * @param {Object} suggestion - 建议对象\r\n   * @returns {number} 优先级分数\r\n   */\r\n  calculateSuggestionPriority(suggestion) {\r\n    const impactWeights = { high: 3, medium: 2, low: 1 };\r\n    const categoryWeights = { warning: 2, improvement: 1.5, info: 1 };\r\n    \r\n    return impactWeights[suggestion.impact] * categoryWeights[suggestion.category];\r\n  }\r\n\r\n  /**\r\n   * 计算建议可信度\r\n   * @param {Object} suggestion - 建议对象\r\n   * @returns {number} 可信度分数\r\n   */\r\n  calculateSuggestionConfidence(suggestion) {\r\n    // 基于建议类型和影响程度计算可信度\r\n    const baseConfidence = {\r\n      weight_optimization: 0.9,\r\n      structure: 0.8,\r\n      parameters: 0.85,\r\n      style: 0.75\r\n    };\r\n    \r\n    return baseConfidence[suggestion.type] || 0.7;\r\n  }\r\n\r\n  // 辅助方法\r\n  areConflicting(tag1, tag2) {\r\n    const conflicts = [\r\n      ['realistic', 'anime'],\r\n      ['black hair', 'blonde hair'],\r\n      ['indoor', 'outdoor'],\r\n      ['day', 'night']\r\n    ];\r\n    \r\n    return conflicts.some(([a, b]) => \r\n      (tag1.includes(a) && tag2.includes(b)) || \r\n      (tag1.includes(b) && tag2.includes(a))\r\n    );\r\n  }\r\n\r\n  areComplementary(positiveTag, negativeTag) {\r\n    const complements = [\r\n      ['detailed', 'blurry'],\r\n      ['high quality', 'low quality'],\r\n      ['beautiful', 'ugly']\r\n    ];\r\n    \r\n    return complements.some(([pos, neg]) => \r\n      positiveTag.includes(pos) && negativeTag.includes(neg)\r\n    );\r\n  }\r\n\r\n  calculateConflictSeverity(tag1, tag2) {\r\n    return (tag1.weight + tag2.weight) / 2;\r\n  }\r\n\r\n  calculateComplementStrength(tag1, tag2) {\r\n    return Math.min(tag1.weight, tag2.weight);\r\n  }\r\n\r\n  assessBalance(ratio) {\r\n    if (ratio < 2) return '负向权重过强';\r\n    if (ratio > 8) return '正向权重过强';\r\n    return '权重平衡合理';\r\n  }\r\n\r\n  assessGuidanceLevel(guidance) {\r\n    if (guidance < 5) return '引导强度较低';\r\n    if (guidance > 15) return '引导强度过高';\r\n    return '引导强度适中';\r\n  }\r\n\r\n  assessStepsEfficiency(steps) {\r\n    if (steps < 10) return '步数过少';\r\n    if (steps > 50) return '步数过多';\r\n    return '步数合理';\r\n  }\r\n\r\n  assessParameterBalance(params) {\r\n    // 综合评估参数平衡\r\n    return '参数配置合理';\r\n  }\r\n\r\n  getQualityLevel(score) {\r\n    if (score >= 0.8) return 'excellent';\r\n    if (score >= 0.6) return 'good';\r\n    if (score >= 0.4) return 'average';\r\n    if (score >= 0.2) return 'poor';\r\n    return 'very_poor';\r\n  }\r\n\r\n  identifyStrengths(positiveTags, negativeTags) {\r\n    const strengths = [];\r\n    \r\n    // 检查质量标签\r\n    const hasQuality = positiveTags.some(tag => tag.special.includes('quality'));\r\n    if (hasQuality) strengths.push('包含质量标签');\r\n    \r\n    // 检查风格明确性\r\n    const styleAnalysis = this.detectStyle(positiveTags);\r\n    if (styleAnalysis.confidence > 0.7) strengths.push('风格定义明确');\r\n    \r\n    return strengths;\r\n  }\r\n\r\n  identifyWeaknesses(positiveTags, negativeTags) {\r\n    const weaknesses = [];\r\n    \r\n    // 检查标签不足\r\n    if (positiveTags.length < 3) weaknesses.push('正向标签过少');\r\n    if (negativeTags.length === 0) weaknesses.push('缺少负向标签');\r\n    \r\n    return weaknesses;\r\n  }\r\n}\r\n\r\nexport default AdvancedPromptAnalyzer; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}