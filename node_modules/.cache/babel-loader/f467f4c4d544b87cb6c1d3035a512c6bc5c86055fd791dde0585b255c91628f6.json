{"ast":null,"code":"import exifr from 'exifr';\n\n/**\n * 专业级图像元数据提取器 v2.0\n * 基于stable-diffusion-inspector、auto1111-pnginfo等开源项目的最佳实践\n * 专门解决PNG文本块解析、字符编码和提示词截断问题\n */\nexport class ImageMetadataExtractor {\n  /**\n   * 主提取方法\n   */\n  async extractMetadata(file) {\n    console.log('🚀 开始专业级元数据提取...');\n    const result = {\n      success: false,\n      filename: file.name,\n      extractedData: {},\n      standardizedData: null,\n      errors: []\n    };\n    try {\n      // 并行运行多种提取方法\n      const extractionPromises = [this.extractFromEXIF(file), file.type === 'image/png' ? this.extractFromPNGChunks(file) : null].filter(Boolean);\n      const extractionResults = await Promise.allSettled(extractionPromises);\n\n      // 整合结果\n      extractionResults.forEach((promiseResult, index) => {\n        if (promiseResult.status === 'fulfilled' && promiseResult.value) {\n          const methodNames = ['EXIF', 'PNG_Chunks'];\n          const methodName = methodNames[index];\n          result.extractedData[methodName] = promiseResult.value;\n        }\n      });\n\n      // 标准化数据\n      result.standardizedData = this.standardizeExtractedData(result.extractedData);\n      result.success = Object.keys(result.extractedData).length > 0;\n      return result;\n    } catch (error) {\n      console.error('❌ 元数据提取失败:', error);\n      result.errors.push(`总体错误: ${error.message}`);\n      throw new Error(`元数据提取失败: ${error.message}`);\n    }\n  }\n\n  /**\n   * 专业级PNG文本块提取器 - 修复特殊字符截断问题\n   */\n  async extractFromPNGChunks(file) {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.onload = e => {\n        try {\n          const buffer = e.target.result;\n          const view = new DataView(buffer);\n\n          // PNG签名验证\n          const pngSignature = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A];\n          for (let i = 0; i < 8; i++) {\n            if (view.getUint8(i) !== pngSignature[i]) {\n              throw new Error('不是有效的PNG文件');\n            }\n          }\n          const chunks = this.parsePNGChunks(buffer);\n          const metadata = this.extractAIMetadataFromChunks(chunks);\n          resolve({\n            type: 'PNG_Chunks',\n            confidence: metadata.confidence || 'high',\n            data: metadata\n          });\n        } catch (error) {\n          reject(error);\n        }\n      };\n      reader.onerror = () => reject(new Error('文件读取失败'));\n      reader.readAsArrayBuffer(file);\n    });\n  }\n\n  /**\n   * 高级PNG块解析器 - 安全处理所有字符\n   */\n  parsePNGChunks(buffer) {\n    const view = new DataView(buffer);\n    const chunks = [];\n    let offset = 8; // 跳过PNG签名\n\n    while (offset < buffer.byteLength - 8) {\n      try {\n        // 读取块长度 (big-endian)\n        const length = view.getUint32(offset);\n        if (length > buffer.byteLength - offset) break; // 安全检查\n        offset += 4;\n\n        // 读取块类型\n        const type = this.readChunkType(view, offset);\n        offset += 4;\n\n        // 读取块数据\n        const data = new Uint8Array(buffer, offset, length);\n        offset += length;\n\n        // 读取CRC\n        const crc = view.getUint32(offset);\n        offset += 4;\n        chunks.push({\n          type,\n          length,\n          data,\n          crc\n        });\n        if (type === 'IEND') break;\n      } catch (error) {\n        console.warn('PNG块解析警告:', error);\n        break;\n      }\n    }\n    return chunks;\n  }\n\n  /**\n   * 安全的块类型读取\n   */\n  readChunkType(view, offset) {\n    const bytes = [];\n    for (let i = 0; i < 4; i++) {\n      bytes.push(view.getUint8(offset + i));\n    }\n    return String.fromCharCode(...bytes);\n  }\n\n  /**\n   * 从PNG块提取AI元数据 - 专门处理SD生成的图像\n   */\n  extractAIMetadataFromChunks(chunks) {\n    const textChunks = chunks.filter(chunk => ['tEXt', 'iTXt', 'zTXt'].includes(chunk.type));\n    const metadata = {\n      confidence: 'low',\n      generationTool: 'Unknown',\n      positive: '',\n      negative: '',\n      parameters: {}\n    };\n    for (const chunk of textChunks) {\n      const textData = this.parseTextChunk(chunk);\n      if (!textData.keyword || !textData.text) continue;\n      console.log('解析PNG文本块:', textData.keyword, '长度:', textData.text.length);\n\n      // 检测不同AI工具的数据格式\n      if (this.isAutomatic1111Format(textData)) {\n        Object.assign(metadata, this.parseAutomatic1111Data(textData.text));\n        metadata.generationTool = 'AUTOMATIC1111';\n        metadata.confidence = 'high';\n      } else if (this.isComfyUIFormat(textData)) {\n        Object.assign(metadata, this.parseComfyUIData(textData.text));\n        metadata.generationTool = 'ComfyUI';\n        metadata.confidence = 'high';\n      } else if (this.isNovelAIFormat(textData)) {\n        Object.assign(metadata, this.parseNovelAIData(textData.text));\n        metadata.generationTool = 'NovelAI';\n        metadata.confidence = 'high';\n      } else if (this.containsPromptLikeText(textData.text)) {\n        metadata.positive = textData.text;\n        metadata.confidence = 'medium';\n      }\n    }\n    return metadata;\n  }\n\n  /**\n   * 高级文本块解析器 - 正确处理所有编码和特殊字符\n   */\n  parseTextChunk(chunk) {\n    try {\n      const data = chunk.data;\n      if (chunk.type === 'tEXt') {\n        return this.parseTEXt(data);\n      } else if (chunk.type === 'iTXt') {\n        return this.parseITXt(data);\n      } else if (chunk.type === 'zTXt') {\n        return this.parseZTXt(data);\n      }\n      return {};\n    } catch (error) {\n      console.warn('文本块解析失败:', error);\n      return {};\n    }\n  }\n\n  /**\n   * 解析tEXt块 - Latin-1编码，安全处理特殊字符\n   */\n  parseTEXt(data) {\n    const nullIndex = data.indexOf(0);\n    if (nullIndex === -1) return {};\n    const keyword = this.decodeLatin1(data.slice(0, nullIndex));\n    const text = this.decodeLatin1(data.slice(nullIndex + 1));\n    return {\n      keyword,\n      text\n    };\n  }\n\n  /**\n   * 解析iTXt块 - UTF-8编码\n   */\n  parseITXt(data) {\n    try {\n      const nullIndices = [];\n      for (let i = 0; i < data.length; i++) {\n        if (data[i] === 0) {\n          nullIndices.push(i);\n          if (nullIndices.length >= 4) break;\n        }\n      }\n      if (nullIndices.length < 4) return {};\n      const keyword = this.decodeUTF8(data.slice(0, nullIndices[0]));\n      const text = this.decodeUTF8(data.slice(nullIndices[3] + 1));\n      return {\n        keyword,\n        text\n      };\n    } catch (error) {\n      console.warn('iTXt解析失败:', error);\n      return {};\n    }\n  }\n\n  /**\n   * 解析zTXt块 - 压缩文本\n   */\n  parseZTXt(data) {\n    try {\n      const nullIndex = data.indexOf(0);\n      if (nullIndex === -1) return {};\n      const keyword = this.decodeLatin1(data.slice(0, nullIndex));\n      const compression = data[nullIndex + 1];\n      if (compression !== 0) {\n        return {\n          keyword,\n          text: '[压缩文本-暂不支持]'\n        };\n      }\n      return {\n        keyword,\n        text: '[需要zlib解压缩]',\n        compressed: true\n      };\n    } catch (error) {\n      console.warn('zTXt解析失败:', error);\n      return {};\n    }\n  }\n\n  /**\n   * 安全的Latin-1解码 - 逐字节处理，永不截断\n   */\n  decodeLatin1(data) {\n    let result = '';\n    for (let i = 0; i < data.length; i++) {\n      result += String.fromCharCode(data[i]);\n    }\n    return result;\n  }\n\n  /**\n   * 安全的UTF-8解码\n   */\n  decodeUTF8(data) {\n    try {\n      return new TextDecoder('utf-8', {\n        fatal: false\n      }).decode(data);\n    } catch (error) {\n      console.warn('UTF-8解码失败，使用Latin-1:', error);\n      return this.decodeLatin1(data);\n    }\n  }\n\n  /**\n   * 检测AUTOMATIC1111格式\n   */\n  isAutomatic1111Format(textData) {\n    if (textData.keyword !== 'parameters') return false;\n    const text = textData.text.toLowerCase();\n    return text.includes('steps:') || text.includes('cfg scale:') || text.includes('sampler:') || text.includes('negative prompt:');\n  }\n\n  /**\n   * 解析AUTOMATIC1111数据 - 增强版，不会截断提示词\n   */\n  parseAutomatic1111Data(text) {\n    const result = {\n      positive: '',\n      negative: '',\n      parameters: {}\n    };\n    try {\n      // 查找负向提示词分隔符\n      const negativePromptIndex = text.indexOf('Negative prompt:');\n      if (negativePromptIndex !== -1) {\n        // 提取正向提示词\n        result.positive = text.substring(0, negativePromptIndex).trim();\n\n        // 提取剩余部分\n        const afterNegative = text.substring(negativePromptIndex + 16); // 'Negative prompt:' 长度\n\n        // 查找参数部分的开始\n        const parameterLines = afterNegative.split('\\n');\n        let negativePrompt = '';\n        let parametersStartIndex = -1;\n        for (let i = 0; i < parameterLines.length; i++) {\n          const line = parameterLines[i].trim();\n          if (this.looksLikeParameterLine(line)) {\n            parametersStartIndex = i;\n            break;\n          } else if (line) {\n            negativePrompt += (negativePrompt ? '\\n' : '') + line;\n          }\n        }\n        result.negative = negativePrompt.trim();\n\n        // 解析参数\n        if (parametersStartIndex !== -1) {\n          const paramText = parameterLines.slice(parametersStartIndex).join(', ');\n          result.parameters = this.parseParameterString(paramText);\n        }\n      } else {\n        // 没有负向提示词，查找参数分隔\n        const lines = text.split('\\n');\n        let positiveLines = [];\n        let parameterLines = [];\n        let foundParameters = false;\n        for (const line of lines) {\n          const trimmedLine = line.trim();\n          if (this.looksLikeParameterLine(trimmedLine)) {\n            foundParameters = true;\n            parameterLines.push(trimmedLine);\n          } else if (!foundParameters && trimmedLine) {\n            positiveLines.push(trimmedLine);\n          } else if (foundParameters) {\n            parameterLines.push(trimmedLine);\n          }\n        }\n        result.positive = positiveLines.join(' ').trim();\n        if (parameterLines.length > 0) {\n          result.parameters = this.parseParameterString(parameterLines.join(', '));\n        }\n      }\n    } catch (error) {\n      console.warn('AUTOMATIC1111解析警告:', error);\n      result.positive = text; // 备用方案\n    }\n    return result;\n  }\n\n  /**\n   * 检测ComfyUI格式\n   */\n  isComfyUIFormat(textData) {\n    if (!['workflow', 'prompt'].includes(textData.keyword)) return false;\n    try {\n      const parsed = JSON.parse(textData.text);\n      return parsed && typeof parsed === 'object';\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * 解析ComfyUI数据 - 完整提取，不截断\n   */\n  parseComfyUIData(text) {\n    const result = {\n      positive: '',\n      negative: '',\n      parameters: {}\n    };\n    try {\n      const data = JSON.parse(text);\n      if (Array.isArray(data === null || data === void 0 ? void 0 : data.nodes)) {\n        // 工作流格式\n        const prompts = this.extractPromptsFromComfyWorkflow(data);\n        result.positive = prompts.positive;\n        result.negative = prompts.negative;\n        result.parameters.workflow = data;\n      } else if (typeof data === 'object') {\n        // 提示格式\n        const prompts = this.extractPromptsFromComfyPrompt(data);\n        result.positive = prompts.positive;\n        result.negative = prompts.negative;\n        result.parameters.prompt = data;\n      }\n    } catch (error) {\n      console.warn('ComfyUI解析警告:', error);\n    }\n    return result;\n  }\n\n  /**\n   * 从ComfyUI工作流提取提示词 - 修复版，收集所有文本\n   */\n  extractPromptsFromComfyWorkflow(workflow) {\n    const positivePrompts = [];\n    const negativePrompts = [];\n    for (const node of workflow.nodes || []) {\n      if (['CLIPTextEncode', 'CLIPTextEncodeSDXL', 'ConditioningCombine'].includes(node.type)) {\n        var _node$widgets_values;\n        const text = (_node$widgets_values = node.widgets_values) === null || _node$widgets_values === void 0 ? void 0 : _node$widgets_values[0];\n        if (text && typeof text === 'string' && text.trim()) {\n          var _node$title, _node$title2;\n          const cleanText = text.trim();\n\n          // 根据节点标题或内容判断正负向\n          const isNegative = this.isNegativePrompt(cleanText) || ((_node$title = node.title) === null || _node$title === void 0 ? void 0 : _node$title.toLowerCase().includes('negative')) || ((_node$title2 = node.title) === null || _node$title2 === void 0 ? void 0 : _node$title2.toLowerCase().includes('neg'));\n          if (isNegative) {\n            negativePrompts.push(cleanText);\n          } else {\n            positivePrompts.push(cleanText);\n          }\n        }\n      }\n    }\n    return {\n      positive: this.mergePrompts(positivePrompts),\n      negative: this.mergePrompts(negativePrompts)\n    };\n  }\n\n  /**\n   * 从ComfyUI提示提取提示词\n   */\n  extractPromptsFromComfyPrompt(prompt) {\n    const positivePrompts = [];\n    const negativePrompts = [];\n    for (const [nodeId, nodeData] of Object.entries(prompt)) {\n      if (['CLIPTextEncode', 'CLIPTextEncodeSDXL'].includes(nodeData.class_type)) {\n        var _nodeData$inputs;\n        const text = (_nodeData$inputs = nodeData.inputs) === null || _nodeData$inputs === void 0 ? void 0 : _nodeData$inputs.text;\n        if (text && typeof text === 'string' && text.trim()) {\n          const cleanText = text.trim();\n          if (this.isNegativePrompt(cleanText)) {\n            negativePrompts.push(cleanText);\n          } else {\n            positivePrompts.push(cleanText);\n          }\n        }\n      }\n    }\n    return {\n      positive: this.mergePrompts(positivePrompts),\n      negative: this.mergePrompts(negativePrompts)\n    };\n  }\n\n  /**\n   * 智能合并提示词 - 保持完整性\n   */\n  mergePrompts(prompts) {\n    if (!prompts.length) return '';\n    if (prompts.length === 1) return prompts[0];\n\n    // 检查是否有明显更长更完整的提示词\n    const longest = prompts.reduce((max, current) => current.length > max.length ? current : max);\n\n    // 如果最长的比其他的长很多，选择它\n    const avgLength = prompts.reduce((sum, p) => sum + p.length, 0) / prompts.length;\n    if (longest.length > avgLength * 2) {\n      return longest;\n    }\n\n    // 否则按长度排序，优先选择长的\n    const sorted = [...prompts].sort((a, b) => b.length - a.length);\n    return sorted[0];\n  }\n\n  /**\n   * 检测NovelAI格式\n   */\n  isNovelAIFormat(textData) {\n    if (!['Description', 'Comment'].includes(textData.keyword)) return false;\n    try {\n      const parsed = JSON.parse(textData.text);\n      return parsed.prompt !== undefined || parsed.uc !== undefined;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * 解析NovelAI数据\n   */\n  parseNovelAIData(text) {\n    const result = {\n      positive: '',\n      negative: '',\n      parameters: {}\n    };\n    try {\n      const data = JSON.parse(text);\n      result.positive = data.prompt || '';\n      result.negative = data.uc || '';\n      ['steps', 'scale', 'seed', 'sampler', 'width', 'height'].forEach(key => {\n        if (data[key] !== undefined) {\n          result.parameters[key] = data[key];\n        }\n      });\n    } catch (error) {\n      console.warn('NovelAI解析警告:', error);\n    }\n    return result;\n  }\n\n  /**\n   * 改进的负向提示词检测\n   */\n  isNegativePrompt(text) {\n    if (!text || typeof text !== 'string') return false;\n    const lowerText = text.toLowerCase();\n    const strongNegative = ['worst quality', 'bad anatomy', 'ugly', 'blurry', 'lowres', 'bad hands', 'text', 'error', 'cropped', 'out of frame', 'deformed', 'mutated', 'malformed', 'poorly drawn'];\n    return strongNegative.some(keyword => lowerText.includes(keyword));\n  }\n\n  /**\n   * 检测提示词样式文本\n   */\n  containsPromptLikeText(text) {\n    if (!text || typeof text !== 'string' || text.length < 10) return false;\n    const keywords = ['masterpiece', 'best quality', 'detailed', 'high resolution', 'realistic', 'anime', 'portrait', 'landscape'];\n    const lowerText = text.toLowerCase();\n    const hasKeywords = keywords.some(keyword => lowerText.includes(keyword));\n    const hasCommas = text.includes(',') && text.split(',').length > 2;\n    return hasKeywords || hasCommas;\n  }\n\n  /**\n   * 检测参数行\n   */\n  looksLikeParameterLine(line) {\n    const parameterPattern = /\\b(Steps|Sampler|CFG scale|Seed|Size|Model|Clip skip|Denoising strength):/i;\n    return parameterPattern.test(line);\n  }\n\n  /**\n   * 解析参数字符串\n   */\n  parseParameterString(paramText) {\n    const parameters = {};\n    const paramPattern = /(\\w+(?:\\s+\\w+)*)\\s*:\\s*([^,]+?)(?=,\\s*\\w+\\s*:|$)/g;\n    let match;\n    while ((match = paramPattern.exec(paramText)) !== null) {\n      const key = match[1].trim();\n      const value = match[2].trim();\n      const normalizedKey = this.normalizeParameterKey(key);\n      parameters[normalizedKey] = this.parseParameterValue(value);\n    }\n    return parameters;\n  }\n\n  /**\n   * 标准化参数键名\n   */\n  normalizeParameterKey(key) {\n    const keyMap = {\n      'steps': 'steps',\n      'sampler': 'sampler',\n      'cfg scale': 'cfgScale',\n      'seed': 'seed',\n      'size': 'size',\n      'model hash': 'modelHash',\n      'model': 'model',\n      'clip skip': 'clipSkip',\n      'denoising strength': 'denoisingStrength'\n    };\n    return keyMap[key.toLowerCase()] || key.replace(/\\s+/g, '');\n  }\n\n  /**\n   * 解析参数值\n   */\n  parseParameterValue(value) {\n    const numValue = parseFloat(value);\n    if (!isNaN(numValue) && isFinite(numValue)) {\n      return Number.isInteger(numValue) ? parseInt(value) : numValue;\n    }\n    return value;\n  }\n\n  /**\n   * EXIF数据提取\n   */\n  async extractFromEXIF(file) {\n    try {\n      const exifData = await exifr.parse(file, {\n        userComment: true,\n        imageDescription: true,\n        software: true\n      });\n      if (!exifData) return null;\n      const result = {\n        type: 'EXIF',\n        confidence: 'medium',\n        data: {\n          software: exifData.Software,\n          description: exifData.ImageDescription,\n          userComment: exifData.UserComment\n        }\n      };\n      if (exifData.UserComment) {\n        const aiData = this.parseUserComment(exifData.UserComment);\n        if (aiData.positive || aiData.negative) {\n          Object.assign(result.data, aiData);\n          result.confidence = 'high';\n        }\n      }\n      return result;\n    } catch (error) {\n      console.warn('EXIF提取失败:', error);\n      return null;\n    }\n  }\n\n  /**\n   * 解析UserComment\n   */\n  parseUserComment(userComment) {\n    const result = {\n      positive: '',\n      negative: '',\n      parameters: {}\n    };\n    try {\n      if (userComment.startsWith('{')) {\n        const data = JSON.parse(userComment);\n        result.positive = data.prompt || data.positive || '';\n        result.negative = data.negativePrompt || data.negative || '';\n        result.parameters = data.parameters || {};\n      } else {\n        result.positive = userComment;\n      }\n    } catch {\n      result.positive = userComment;\n    }\n    return result;\n  }\n\n  /**\n   * 标准化提取的数据\n   */\n  standardizeExtractedData(extractedData) {\n    const standardized = {\n      generationTool: 'Unknown',\n      positive: '',\n      negative: '',\n      parameters: {}\n    };\n    const priorityOrder = ['PNG_Chunks', 'EXIF'];\n    for (const source of priorityOrder) {\n      const data = extractedData[source];\n      if (!data) continue;\n      if (data.data.generationTool) {\n        standardized.generationTool = data.data.generationTool;\n      }\n      if (data.data.positive && !standardized.positive) {\n        standardized.positive = data.data.positive;\n      }\n      if (data.data.negative && !standardized.negative) {\n        standardized.negative = data.data.negative;\n      }\n      Object.assign(standardized.parameters, data.data.parameters || {});\n    }\n    return standardized;\n  }\n}\n\n// 导出单例实例\nexport const imageMetadataExtractor = new ImageMetadataExtractor();\nexport default ImageMetadataExtractor;","map":{"version":3,"names":["exifr","ImageMetadataExtractor","extractMetadata","file","console","log","result","success","filename","name","extractedData","standardizedData","errors","extractionPromises","extractFromEXIF","type","extractFromPNGChunks","filter","Boolean","extractionResults","Promise","allSettled","forEach","promiseResult","index","status","value","methodNames","methodName","standardizeExtractedData","Object","keys","length","error","push","message","Error","resolve","reject","reader","FileReader","onload","e","buffer","target","view","DataView","pngSignature","i","getUint8","chunks","parsePNGChunks","metadata","extractAIMetadataFromChunks","confidence","data","onerror","readAsArrayBuffer","offset","byteLength","getUint32","readChunkType","Uint8Array","crc","warn","bytes","String","fromCharCode","textChunks","chunk","includes","generationTool","positive","negative","parameters","textData","parseTextChunk","keyword","text","isAutomatic1111Format","assign","parseAutomatic1111Data","isComfyUIFormat","parseComfyUIData","isNovelAIFormat","parseNovelAIData","containsPromptLikeText","parseTEXt","parseITXt","parseZTXt","nullIndex","indexOf","decodeLatin1","slice","nullIndices","decodeUTF8","compression","compressed","TextDecoder","fatal","decode","toLowerCase","negativePromptIndex","substring","trim","afterNegative","parameterLines","split","negativePrompt","parametersStartIndex","line","looksLikeParameterLine","paramText","join","parseParameterString","lines","positiveLines","foundParameters","trimmedLine","parsed","JSON","parse","Array","isArray","nodes","prompts","extractPromptsFromComfyWorkflow","workflow","extractPromptsFromComfyPrompt","prompt","positivePrompts","negativePrompts","node","_node$widgets_values","widgets_values","_node$title","_node$title2","cleanText","isNegative","isNegativePrompt","title","mergePrompts","nodeId","nodeData","entries","class_type","_nodeData$inputs","inputs","longest","reduce","max","current","avgLength","sum","p","sorted","sort","a","b","undefined","uc","key","lowerText","strongNegative","some","keywords","hasKeywords","hasCommas","parameterPattern","test","paramPattern","match","exec","normalizedKey","normalizeParameterKey","parseParameterValue","keyMap","replace","numValue","parseFloat","isNaN","isFinite","Number","isInteger","parseInt","exifData","userComment","imageDescription","software","Software","description","ImageDescription","UserComment","aiData","parseUserComment","startsWith","standardized","priorityOrder","source","imageMetadataExtractor"],"sources":["C:/Users/wjx19/Documents/GitHub/I-Prompt/src/utils/imageMetadataExtractor.js"],"sourcesContent":["import exifr from 'exifr';\n\n/**\n * 专业级图像元数据提取器 v2.0\n * 基于stable-diffusion-inspector、auto1111-pnginfo等开源项目的最佳实践\n * 专门解决PNG文本块解析、字符编码和提示词截断问题\n */\nexport class ImageMetadataExtractor {\n  \n  /**\n   * 主提取方法\n   */\n  async extractMetadata(file) {\n    console.log('🚀 开始专业级元数据提取...');\n    \n    const result = {\n      success: false,\n      filename: file.name,\n      extractedData: {},\n      standardizedData: null,\n      errors: []\n    };\n\n    try {\n      // 并行运行多种提取方法\n      const extractionPromises = [\n        this.extractFromEXIF(file),\n        file.type === 'image/png' ? this.extractFromPNGChunks(file) : null\n      ].filter(Boolean);\n\n      const extractionResults = await Promise.allSettled(extractionPromises);\n      \n      // 整合结果\n      extractionResults.forEach((promiseResult, index) => {\n        if (promiseResult.status === 'fulfilled' && promiseResult.value) {\n          const methodNames = ['EXIF', 'PNG_Chunks'];\n          const methodName = methodNames[index];\n          result.extractedData[methodName] = promiseResult.value;\n        }\n      });\n\n      // 标准化数据\n      result.standardizedData = this.standardizeExtractedData(result.extractedData);\n      result.success = Object.keys(result.extractedData).length > 0;\n\n      return result;\n      \n    } catch (error) {\n      console.error('❌ 元数据提取失败:', error);\n      result.errors.push(`总体错误: ${error.message}`);\n      throw new Error(`元数据提取失败: ${error.message}`);\n    }\n  }\n\n  /**\n   * 专业级PNG文本块提取器 - 修复特殊字符截断问题\n   */\n  async extractFromPNGChunks(file) {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      \n      reader.onload = (e) => {\n        try {\n          const buffer = e.target.result;\n          const view = new DataView(buffer);\n          \n          // PNG签名验证\n          const pngSignature = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A];\n          for (let i = 0; i < 8; i++) {\n            if (view.getUint8(i) !== pngSignature[i]) {\n              throw new Error('不是有效的PNG文件');\n            }\n          }\n\n          const chunks = this.parsePNGChunks(buffer);\n          const metadata = this.extractAIMetadataFromChunks(chunks);\n          \n          resolve({\n            type: 'PNG_Chunks',\n            confidence: metadata.confidence || 'high',\n            data: metadata\n          });\n          \n        } catch (error) {\n          reject(error);\n        }\n      };\n      \n      reader.onerror = () => reject(new Error('文件读取失败'));\n      reader.readAsArrayBuffer(file);\n    });\n  }\n\n  /**\n   * 高级PNG块解析器 - 安全处理所有字符\n   */\n  parsePNGChunks(buffer) {\n    const view = new DataView(buffer);\n    const chunks = [];\n    let offset = 8; // 跳过PNG签名\n\n    while (offset < buffer.byteLength - 8) {\n      try {\n        // 读取块长度 (big-endian)\n        const length = view.getUint32(offset);\n        if (length > buffer.byteLength - offset) break; // 安全检查\n        offset += 4;\n\n        // 读取块类型\n        const type = this.readChunkType(view, offset);\n        offset += 4;\n\n        // 读取块数据\n        const data = new Uint8Array(buffer, offset, length);\n        offset += length;\n\n        // 读取CRC\n        const crc = view.getUint32(offset);\n        offset += 4;\n\n        chunks.push({ type, length, data, crc });\n\n        if (type === 'IEND') break;\n        \n      } catch (error) {\n        console.warn('PNG块解析警告:', error);\n        break;\n      }\n    }\n\n    return chunks;\n  }\n\n  /**\n   * 安全的块类型读取\n   */\n  readChunkType(view, offset) {\n    const bytes = [];\n    for (let i = 0; i < 4; i++) {\n      bytes.push(view.getUint8(offset + i));\n    }\n    return String.fromCharCode(...bytes);\n  }\n\n  /**\n   * 从PNG块提取AI元数据 - 专门处理SD生成的图像\n   */\n  extractAIMetadataFromChunks(chunks) {\n    const textChunks = chunks.filter(chunk => \n      ['tEXt', 'iTXt', 'zTXt'].includes(chunk.type)\n    );\n\n    const metadata = {\n      confidence: 'low',\n      generationTool: 'Unknown',\n      positive: '',\n      negative: '',\n      parameters: {}\n    };\n\n    for (const chunk of textChunks) {\n      const textData = this.parseTextChunk(chunk);\n      if (!textData.keyword || !textData.text) continue;\n\n      console.log('解析PNG文本块:', textData.keyword, '长度:', textData.text.length);\n\n      // 检测不同AI工具的数据格式\n      if (this.isAutomatic1111Format(textData)) {\n        Object.assign(metadata, this.parseAutomatic1111Data(textData.text));\n        metadata.generationTool = 'AUTOMATIC1111';\n        metadata.confidence = 'high';\n      } else if (this.isComfyUIFormat(textData)) {\n        Object.assign(metadata, this.parseComfyUIData(textData.text));\n        metadata.generationTool = 'ComfyUI';\n        metadata.confidence = 'high';\n      } else if (this.isNovelAIFormat(textData)) {\n        Object.assign(metadata, this.parseNovelAIData(textData.text));\n        metadata.generationTool = 'NovelAI';\n        metadata.confidence = 'high';\n      } else if (this.containsPromptLikeText(textData.text)) {\n        metadata.positive = textData.text;\n        metadata.confidence = 'medium';\n      }\n    }\n\n    return metadata;\n  }\n\n  /**\n   * 高级文本块解析器 - 正确处理所有编码和特殊字符\n   */\n  parseTextChunk(chunk) {\n    try {\n      const data = chunk.data;\n      \n      if (chunk.type === 'tEXt') {\n        return this.parseTEXt(data);\n      } else if (chunk.type === 'iTXt') {\n        return this.parseITXt(data);\n      } else if (chunk.type === 'zTXt') {\n        return this.parseZTXt(data);\n      }\n      \n      return {};\n    } catch (error) {\n      console.warn('文本块解析失败:', error);\n      return {};\n    }\n  }\n\n  /**\n   * 解析tEXt块 - Latin-1编码，安全处理特殊字符\n   */\n  parseTEXt(data) {\n    const nullIndex = data.indexOf(0);\n    if (nullIndex === -1) return {};\n\n    const keyword = this.decodeLatin1(data.slice(0, nullIndex));\n    const text = this.decodeLatin1(data.slice(nullIndex + 1));\n\n    return { keyword, text };\n  }\n\n  /**\n   * 解析iTXt块 - UTF-8编码\n   */\n  parseITXt(data) {\n    try {\n      const nullIndices = [];\n      for (let i = 0; i < data.length; i++) {\n        if (data[i] === 0) {\n          nullIndices.push(i);\n          if (nullIndices.length >= 4) break;\n        }\n      }\n\n      if (nullIndices.length < 4) return {};\n\n      const keyword = this.decodeUTF8(data.slice(0, nullIndices[0]));\n      const text = this.decodeUTF8(data.slice(nullIndices[3] + 1));\n\n      return { keyword, text };\n    } catch (error) {\n      console.warn('iTXt解析失败:', error);\n      return {};\n    }\n  }\n\n  /**\n   * 解析zTXt块 - 压缩文本\n   */\n  parseZTXt(data) {\n    try {\n      const nullIndex = data.indexOf(0);\n      if (nullIndex === -1) return {};\n\n      const keyword = this.decodeLatin1(data.slice(0, nullIndex));\n      const compression = data[nullIndex + 1];\n      \n      if (compression !== 0) {\n        return { keyword, text: '[压缩文本-暂不支持]' };\n      }\n\n      return { keyword, text: '[需要zlib解压缩]', compressed: true };\n    } catch (error) {\n      console.warn('zTXt解析失败:', error);\n      return {};\n    }\n  }\n\n  /**\n   * 安全的Latin-1解码 - 逐字节处理，永不截断\n   */\n  decodeLatin1(data) {\n    let result = '';\n    for (let i = 0; i < data.length; i++) {\n      result += String.fromCharCode(data[i]);\n    }\n    return result;\n  }\n\n  /**\n   * 安全的UTF-8解码\n   */\n  decodeUTF8(data) {\n    try {\n      return new TextDecoder('utf-8', { fatal: false }).decode(data);\n    } catch (error) {\n      console.warn('UTF-8解码失败，使用Latin-1:', error);\n      return this.decodeLatin1(data);\n    }\n  }\n\n  /**\n   * 检测AUTOMATIC1111格式\n   */\n  isAutomatic1111Format(textData) {\n    if (textData.keyword !== 'parameters') return false;\n    const text = textData.text.toLowerCase();\n    return text.includes('steps:') || text.includes('cfg scale:') || \n           text.includes('sampler:') || text.includes('negative prompt:');\n  }\n\n  /**\n   * 解析AUTOMATIC1111数据 - 增强版，不会截断提示词\n   */\n  parseAutomatic1111Data(text) {\n    const result = {\n      positive: '',\n      negative: '',\n      parameters: {}\n    };\n\n    try {\n      // 查找负向提示词分隔符\n      const negativePromptIndex = text.indexOf('Negative prompt:');\n      \n      if (negativePromptIndex !== -1) {\n        // 提取正向提示词\n        result.positive = text.substring(0, negativePromptIndex).trim();\n        \n        // 提取剩余部分\n        const afterNegative = text.substring(negativePromptIndex + 16); // 'Negative prompt:' 长度\n        \n        // 查找参数部分的开始\n        const parameterLines = afterNegative.split('\\n');\n        let negativePrompt = '';\n        let parametersStartIndex = -1;\n        \n        for (let i = 0; i < parameterLines.length; i++) {\n          const line = parameterLines[i].trim();\n          if (this.looksLikeParameterLine(line)) {\n            parametersStartIndex = i;\n            break;\n          } else if (line) {\n            negativePrompt += (negativePrompt ? '\\n' : '') + line;\n          }\n        }\n        \n        result.negative = negativePrompt.trim();\n        \n        // 解析参数\n        if (parametersStartIndex !== -1) {\n          const paramText = parameterLines.slice(parametersStartIndex).join(', ');\n          result.parameters = this.parseParameterString(paramText);\n        }\n      } else {\n        // 没有负向提示词，查找参数分隔\n        const lines = text.split('\\n');\n        let positiveLines = [];\n        let parameterLines = [];\n        let foundParameters = false;\n        \n        for (const line of lines) {\n          const trimmedLine = line.trim();\n          if (this.looksLikeParameterLine(trimmedLine)) {\n            foundParameters = true;\n            parameterLines.push(trimmedLine);\n          } else if (!foundParameters && trimmedLine) {\n            positiveLines.push(trimmedLine);\n          } else if (foundParameters) {\n            parameterLines.push(trimmedLine);\n          }\n        }\n        \n        result.positive = positiveLines.join(' ').trim();\n        \n        if (parameterLines.length > 0) {\n          result.parameters = this.parseParameterString(parameterLines.join(', '));\n        }\n      }\n\n    } catch (error) {\n      console.warn('AUTOMATIC1111解析警告:', error);\n      result.positive = text; // 备用方案\n    }\n\n    return result;\n  }\n\n  /**\n   * 检测ComfyUI格式\n   */\n  isComfyUIFormat(textData) {\n    if (!['workflow', 'prompt'].includes(textData.keyword)) return false;\n    try {\n      const parsed = JSON.parse(textData.text);\n      return parsed && typeof parsed === 'object';\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * 解析ComfyUI数据 - 完整提取，不截断\n   */\n  parseComfyUIData(text) {\n    const result = {\n      positive: '',\n      negative: '',\n      parameters: {}\n    };\n\n    try {\n      const data = JSON.parse(text);\n      \n      if (Array.isArray(data?.nodes)) {\n        // 工作流格式\n        const prompts = this.extractPromptsFromComfyWorkflow(data);\n        result.positive = prompts.positive;\n        result.negative = prompts.negative;\n        result.parameters.workflow = data;\n      } else if (typeof data === 'object') {\n        // 提示格式\n        const prompts = this.extractPromptsFromComfyPrompt(data);\n        result.positive = prompts.positive;\n        result.negative = prompts.negative;\n        result.parameters.prompt = data;\n      }\n\n    } catch (error) {\n      console.warn('ComfyUI解析警告:', error);\n    }\n\n    return result;\n  }\n\n  /**\n   * 从ComfyUI工作流提取提示词 - 修复版，收集所有文本\n   */\n  extractPromptsFromComfyWorkflow(workflow) {\n    const positivePrompts = [];\n    const negativePrompts = [];\n\n    for (const node of workflow.nodes || []) {\n      if (['CLIPTextEncode', 'CLIPTextEncodeSDXL', 'ConditioningCombine'].includes(node.type)) {\n        const text = node.widgets_values?.[0];\n        if (text && typeof text === 'string' && text.trim()) {\n          const cleanText = text.trim();\n          \n          // 根据节点标题或内容判断正负向\n          const isNegative = this.isNegativePrompt(cleanText) || \n                           node.title?.toLowerCase().includes('negative') ||\n                           node.title?.toLowerCase().includes('neg');\n          \n          if (isNegative) {\n            negativePrompts.push(cleanText);\n          } else {\n            positivePrompts.push(cleanText);\n          }\n        }\n      }\n    }\n\n    return {\n      positive: this.mergePrompts(positivePrompts),\n      negative: this.mergePrompts(negativePrompts)\n    };\n  }\n\n  /**\n   * 从ComfyUI提示提取提示词\n   */\n  extractPromptsFromComfyPrompt(prompt) {\n    const positivePrompts = [];\n    const negativePrompts = [];\n\n    for (const [nodeId, nodeData] of Object.entries(prompt)) {\n      if (['CLIPTextEncode', 'CLIPTextEncodeSDXL'].includes(nodeData.class_type)) {\n        const text = nodeData.inputs?.text;\n        if (text && typeof text === 'string' && text.trim()) {\n          const cleanText = text.trim();\n          \n          if (this.isNegativePrompt(cleanText)) {\n            negativePrompts.push(cleanText);\n          } else {\n            positivePrompts.push(cleanText);\n          }\n        }\n      }\n    }\n\n    return {\n      positive: this.mergePrompts(positivePrompts),\n      negative: this.mergePrompts(negativePrompts)\n    };\n  }\n\n  /**\n   * 智能合并提示词 - 保持完整性\n   */\n  mergePrompts(prompts) {\n    if (!prompts.length) return '';\n    if (prompts.length === 1) return prompts[0];\n\n    // 检查是否有明显更长更完整的提示词\n    const longest = prompts.reduce((max, current) => \n      current.length > max.length ? current : max);\n    \n    // 如果最长的比其他的长很多，选择它\n    const avgLength = prompts.reduce((sum, p) => sum + p.length, 0) / prompts.length;\n    if (longest.length > avgLength * 2) {\n      return longest;\n    }\n    \n    // 否则按长度排序，优先选择长的\n    const sorted = [...prompts].sort((a, b) => b.length - a.length);\n    return sorted[0];\n  }\n\n  /**\n   * 检测NovelAI格式\n   */\n  isNovelAIFormat(textData) {\n    if (!['Description', 'Comment'].includes(textData.keyword)) return false;\n    try {\n      const parsed = JSON.parse(textData.text);\n      return parsed.prompt !== undefined || parsed.uc !== undefined;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * 解析NovelAI数据\n   */\n  parseNovelAIData(text) {\n    const result = {\n      positive: '',\n      negative: '',\n      parameters: {}\n    };\n\n    try {\n      const data = JSON.parse(text);\n      result.positive = data.prompt || '';\n      result.negative = data.uc || '';\n      \n      ['steps', 'scale', 'seed', 'sampler', 'width', 'height'].forEach(key => {\n        if (data[key] !== undefined) {\n          result.parameters[key] = data[key];\n        }\n      });\n\n    } catch (error) {\n      console.warn('NovelAI解析警告:', error);\n    }\n\n    return result;\n  }\n\n  /**\n   * 改进的负向提示词检测\n   */\n  isNegativePrompt(text) {\n    if (!text || typeof text !== 'string') return false;\n    \n    const lowerText = text.toLowerCase();\n    \n    const strongNegative = [\n      'worst quality', 'bad anatomy', 'ugly', 'blurry', 'lowres',\n      'bad hands', 'text', 'error', 'cropped', 'out of frame',\n      'deformed', 'mutated', 'malformed', 'poorly drawn'\n    ];\n\n    return strongNegative.some(keyword => lowerText.includes(keyword));\n  }\n\n  /**\n   * 检测提示词样式文本\n   */\n  containsPromptLikeText(text) {\n    if (!text || typeof text !== 'string' || text.length < 10) return false;\n    \n    const keywords = [\n      'masterpiece', 'best quality', 'detailed', 'high resolution',\n      'realistic', 'anime', 'portrait', 'landscape'\n    ];\n\n    const lowerText = text.toLowerCase();\n    const hasKeywords = keywords.some(keyword => lowerText.includes(keyword));\n    const hasCommas = text.includes(',') && text.split(',').length > 2;\n    \n    return hasKeywords || hasCommas;\n  }\n\n  /**\n   * 检测参数行\n   */\n  looksLikeParameterLine(line) {\n    const parameterPattern = /\\b(Steps|Sampler|CFG scale|Seed|Size|Model|Clip skip|Denoising strength):/i;\n    return parameterPattern.test(line);\n  }\n\n  /**\n   * 解析参数字符串\n   */\n  parseParameterString(paramText) {\n    const parameters = {};\n    const paramPattern = /(\\w+(?:\\s+\\w+)*)\\s*:\\s*([^,]+?)(?=,\\s*\\w+\\s*:|$)/g;\n    let match;\n\n    while ((match = paramPattern.exec(paramText)) !== null) {\n      const key = match[1].trim();\n      const value = match[2].trim();\n      \n      const normalizedKey = this.normalizeParameterKey(key);\n      parameters[normalizedKey] = this.parseParameterValue(value);\n    }\n\n    return parameters;\n  }\n\n  /**\n   * 标准化参数键名\n   */\n  normalizeParameterKey(key) {\n    const keyMap = {\n      'steps': 'steps',\n      'sampler': 'sampler',\n      'cfg scale': 'cfgScale',\n      'seed': 'seed',\n      'size': 'size',\n      'model hash': 'modelHash',\n      'model': 'model',\n      'clip skip': 'clipSkip',\n      'denoising strength': 'denoisingStrength'\n    };\n    \n    return keyMap[key.toLowerCase()] || key.replace(/\\s+/g, '');\n  }\n\n  /**\n   * 解析参数值\n   */\n  parseParameterValue(value) {\n    const numValue = parseFloat(value);\n    if (!isNaN(numValue) && isFinite(numValue)) {\n      return Number.isInteger(numValue) ? parseInt(value) : numValue;\n    }\n    return value;\n  }\n\n  /**\n   * EXIF数据提取\n   */\n  async extractFromEXIF(file) {\n    try {\n      const exifData = await exifr.parse(file, {\n        userComment: true,\n        imageDescription: true,\n        software: true\n      });\n\n      if (!exifData) return null;\n\n      const result = {\n        type: 'EXIF',\n        confidence: 'medium',\n        data: {\n          software: exifData.Software,\n          description: exifData.ImageDescription,\n          userComment: exifData.UserComment\n        }\n      };\n\n      if (exifData.UserComment) {\n        const aiData = this.parseUserComment(exifData.UserComment);\n        if (aiData.positive || aiData.negative) {\n          Object.assign(result.data, aiData);\n          result.confidence = 'high';\n        }\n      }\n\n      return result;\n    } catch (error) {\n      console.warn('EXIF提取失败:', error);\n      return null;\n    }\n  }\n\n  /**\n   * 解析UserComment\n   */\n  parseUserComment(userComment) {\n    const result = { positive: '', negative: '', parameters: {} };\n\n    try {\n      if (userComment.startsWith('{')) {\n        const data = JSON.parse(userComment);\n        result.positive = data.prompt || data.positive || '';\n        result.negative = data.negativePrompt || data.negative || '';\n        result.parameters = data.parameters || {};\n      } else {\n        result.positive = userComment;\n      }\n    } catch {\n      result.positive = userComment;\n    }\n\n    return result;\n  }\n\n  /**\n   * 标准化提取的数据\n   */\n  standardizeExtractedData(extractedData) {\n    const standardized = {\n      generationTool: 'Unknown',\n      positive: '',\n      negative: '',\n      parameters: {}\n    };\n\n    const priorityOrder = ['PNG_Chunks', 'EXIF'];\n    \n    for (const source of priorityOrder) {\n      const data = extractedData[source];\n      if (!data) continue;\n\n      if (data.data.generationTool) {\n        standardized.generationTool = data.data.generationTool;\n      }\n\n      if (data.data.positive && !standardized.positive) {\n        standardized.positive = data.data.positive;\n      }\n\n      if (data.data.negative && !standardized.negative) {\n        standardized.negative = data.data.negative;\n      }\n\n      Object.assign(standardized.parameters, data.data.parameters || {});\n    }\n\n    return standardized;\n  }\n}\n\n// 导出单例实例\nexport const imageMetadataExtractor = new ImageMetadataExtractor();\nexport default ImageMetadataExtractor; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}