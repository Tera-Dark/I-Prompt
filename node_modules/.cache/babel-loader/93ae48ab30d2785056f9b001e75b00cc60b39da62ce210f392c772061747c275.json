{"ast":null,"code":"/**\n * 简化的图像元数据提取器\n * 参考stable-diffusion-inspector的实现方式\n */\n\n// 主要的提取函数\nexport async function extractMetadata(file) {\n  console.log('🚀 开始提取图像元数据...');\n  const result = {\n    success: false,\n    filename: file.name,\n    extractedData: {},\n    standardizedData: null,\n    timestamp: new Date().toISOString()\n  };\n  try {\n    // 基本文件信息\n    result.basicInfo = {\n      size: file.size,\n      sizeFormatted: `${(file.size / 1024).toFixed(1)} KB`,\n      type: file.type,\n      lastModified: new Date(file.lastModified).toLocaleString()\n    };\n\n    // 根据文件类型选择提取方法\n    if (file.type === 'image/png') {\n      const pngData = await extractFromPNG(file);\n      if (pngData) {\n        result.extractedData.PNG = pngData;\n      }\n    }\n\n    // 尝试EXIF提取\n    try {\n      const exifData = await extractFromEXIF(file);\n      if (exifData) {\n        result.extractedData.EXIF = exifData;\n      }\n    } catch (error) {\n      console.warn('EXIF提取失败:', error);\n    }\n\n    // 标准化数据\n    result.standardizedData = standardizeData(result.extractedData);\n    result.success = Object.keys(result.extractedData).length > 0;\n\n    // 添加提取方法信息\n    result.extractionMethods = Object.keys(result.extractedData).map(method => {\n      var _result$extractedData;\n      return {\n        method: method,\n        confidence: ((_result$extractedData = result.extractedData[method]) === null || _result$extractedData === void 0 ? void 0 : _result$extractedData.confidence) || 'unknown'\n      };\n    });\n    return result;\n  } catch (error) {\n    console.error('❌ 元数据提取失败:', error);\n    result.error = error.message;\n    throw error;\n  }\n}\n\n// PNG文件解析 - 参考stable-diffusion-inspector的简洁实现\nasync function extractFromPNG(file) {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = e => {\n      try {\n        const buffer = e.target.result;\n        const chunks = parsePNGChunks(buffer);\n        const metadata = extractMetadataFromChunks(chunks);\n        resolve({\n          type: 'PNG',\n          confidence: metadata.confidence || 'medium',\n          data: metadata\n        });\n      } catch (error) {\n        console.warn('PNG解析失败:', error);\n        resolve(null);\n      }\n    };\n    reader.onerror = () => resolve(null);\n    reader.readAsArrayBuffer(file);\n  });\n}\n\n// 简化的PNG块解析\nfunction parsePNGChunks(buffer) {\n  const view = new DataView(buffer);\n  const chunks = [];\n  let offset = 8; // 跳过PNG签名\n\n  // 验证PNG签名\n  const signature = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A];\n  for (let i = 0; i < 8; i++) {\n    if (view.getUint8(i) !== signature[i]) {\n      throw new Error('不是有效的PNG文件');\n    }\n  }\n  while (offset < buffer.byteLength - 8) {\n    try {\n      const length = view.getUint32(offset);\n      offset += 4;\n      const type = String.fromCharCode(view.getUint8(offset), view.getUint8(offset + 1), view.getUint8(offset + 2), view.getUint8(offset + 3));\n      offset += 4;\n      const data = new Uint8Array(buffer, offset, length);\n      offset += length;\n      const crc = view.getUint32(offset);\n      offset += 4;\n      chunks.push({\n        type,\n        length,\n        data,\n        crc\n      });\n      if (type === 'IEND') break;\n    } catch (error) {\n      console.warn('PNG块解析警告:', error);\n      break;\n    }\n  }\n  return chunks;\n}\n\n// 从PNG块提取元数据\nfunction extractMetadataFromChunks(chunks) {\n  const textChunks = chunks.filter(chunk => ['tEXt', 'iTXt', 'zTXt'].includes(chunk.type));\n  const metadata = {\n    confidence: 'low',\n    generationTool: 'Unknown',\n    positive: '',\n    negative: '',\n    parameters: {}\n  };\n  for (const chunk of textChunks) {\n    const textData = parseTextChunk(chunk);\n    if (!textData.keyword || !textData.text) continue;\n    console.log('解析文本块:', textData.keyword, '长度:', textData.text.length);\n\n    // 检测不同格式\n    if (textData.keyword === 'parameters' && isAutomatic1111Format(textData.text)) {\n      const parsed = parseAutomatic1111(textData.text);\n      Object.assign(metadata, parsed);\n      metadata.generationTool = 'AUTOMATIC1111';\n      metadata.confidence = 'high';\n    } else if (['workflow', 'prompt'].includes(textData.keyword)) {\n      try {\n        const parsed = parseComfyUI(textData.text);\n        Object.assign(metadata, parsed);\n        metadata.generationTool = 'ComfyUI';\n        metadata.confidence = 'high';\n      } catch (error) {\n        console.warn('ComfyUI解析失败:', error);\n      }\n    } else if (['Description', 'Comment'].includes(textData.keyword)) {\n      try {\n        const parsed = parseNovelAI(textData.text);\n        Object.assign(metadata, parsed);\n        metadata.generationTool = 'NovelAI';\n        metadata.confidence = 'high';\n      } catch (error) {\n        console.warn('NovelAI解析失败:', error);\n      }\n    }\n  }\n  return metadata;\n}\n\n// 解析文本块\nfunction parseTextChunk(chunk) {\n  try {\n    const data = chunk.data;\n    if (chunk.type === 'tEXt') {\n      const nullIndex = data.indexOf(0);\n      if (nullIndex === -1) return {};\n      const keyword = decodeLatin1(data.slice(0, nullIndex));\n      const text = decodeLatin1(data.slice(nullIndex + 1));\n      return {\n        keyword,\n        text\n      };\n    }\n    if (chunk.type === 'iTXt') {\n      const nullIndices = [];\n      for (let i = 0; i < data.length; i++) {\n        if (data[i] === 0) {\n          nullIndices.push(i);\n          if (nullIndices.length >= 4) break;\n        }\n      }\n      if (nullIndices.length < 4) return {};\n      const keyword = decodeUTF8(data.slice(0, nullIndices[0]));\n      const text = decodeUTF8(data.slice(nullIndices[3] + 1));\n      return {\n        keyword,\n        text\n      };\n    }\n    return {};\n  } catch (error) {\n    console.warn('文本块解析失败:', error);\n    return {};\n  }\n}\n\n// 安全的字符解码\nfunction decodeLatin1(data) {\n  let result = '';\n  for (let i = 0; i < data.length; i++) {\n    result += String.fromCharCode(data[i]);\n  }\n  return result;\n}\nfunction decodeUTF8(data) {\n  try {\n    return new TextDecoder('utf-8', {\n      fatal: false\n    }).decode(data);\n  } catch (error) {\n    return decodeLatin1(data);\n  }\n}\n\n// 检测AUTOMATIC1111格式\nfunction isAutomatic1111Format(text) {\n  const lowerText = text.toLowerCase();\n  return lowerText.includes('steps:') || lowerText.includes('cfg scale:') || lowerText.includes('sampler:') || lowerText.includes('negative prompt:');\n}\n\n// 解析AUTOMATIC1111数据\nfunction parseAutomatic1111(text) {\n  const result = {\n    positive: '',\n    negative: '',\n    parameters: {}\n  };\n  try {\n    const negativeIndex = text.indexOf('Negative prompt:');\n    if (negativeIndex !== -1) {\n      result.positive = text.substring(0, negativeIndex).trim();\n      const afterNegative = text.substring(negativeIndex + 16);\n      const lines = afterNegative.split('\\n');\n      let negativePrompt = '';\n      let parameterLines = [];\n      let foundParams = false;\n      for (const line of lines) {\n        const trimmed = line.trim();\n        if (isParameterLine(trimmed)) {\n          foundParams = true;\n          parameterLines.push(trimmed);\n        } else if (!foundParams && trimmed) {\n          negativePrompt += (negativePrompt ? '\\n' : '') + trimmed;\n        } else if (foundParams) {\n          parameterLines.push(trimmed);\n        }\n      }\n      result.negative = negativePrompt.trim();\n      if (parameterLines.length > 0) {\n        result.parameters = parseParameters(parameterLines.join(', '));\n      }\n    } else {\n      // 没有负向提示词的情况\n      const lines = text.split('\\n');\n      let positiveLines = [];\n      let parameterLines = [];\n      let foundParams = false;\n      for (const line of lines) {\n        const trimmed = line.trim();\n        if (isParameterLine(trimmed)) {\n          foundParams = true;\n          parameterLines.push(trimmed);\n        } else if (!foundParams && trimmed) {\n          positiveLines.push(trimmed);\n        } else if (foundParams) {\n          parameterLines.push(trimmed);\n        }\n      }\n      result.positive = positiveLines.join(' ').trim();\n      if (parameterLines.length > 0) {\n        result.parameters = parseParameters(parameterLines.join(', '));\n      }\n    }\n  } catch (error) {\n    console.warn('AUTOMATIC1111解析警告:', error);\n    result.positive = text;\n  }\n  return result;\n}\n\n// 检测参数行\nfunction isParameterLine(line) {\n  return /\\b(Steps|Sampler|CFG scale|Seed|Size|Model):/i.test(line);\n}\n\n// 解析参数\nfunction parseParameters(paramText) {\n  const parameters = {};\n  const regex = /(\\w+(?:\\s+\\w+)*)\\s*:\\s*([^,]+?)(?=,\\s*\\w+\\s*:|$)/g;\n  let match;\n  while ((match = regex.exec(paramText)) !== null) {\n    const key = match[1].trim().toLowerCase().replace(/\\s+/g, '');\n    const value = match[2].trim();\n    const numValue = parseFloat(value);\n    parameters[key] = !isNaN(numValue) && isFinite(numValue) ? numValue : value;\n  }\n  return parameters;\n}\n\n// 解析ComfyUI数据\nfunction parseComfyUI(text) {\n  const result = {\n    positive: '',\n    negative: '',\n    parameters: {}\n  };\n  try {\n    const data = JSON.parse(text);\n    if (Array.isArray(data === null || data === void 0 ? void 0 : data.nodes)) {\n      // 工作流格式\n      const prompts = extractFromComfyWorkflow(data);\n      result.positive = prompts.positive;\n      result.negative = prompts.negative;\n    } else if (typeof data === 'object') {\n      // 提示格式\n      const prompts = extractFromComfyPrompt(data);\n      result.positive = prompts.positive;\n      result.negative = prompts.negative;\n    }\n  } catch (error) {\n    console.warn('ComfyUI解析失败:', error);\n  }\n  return result;\n}\n\n// 从ComfyUI工作流提取\nfunction extractFromComfyWorkflow(workflow) {\n  const positivePrompts = [];\n  const negativePrompts = [];\n  for (const node of workflow.nodes || []) {\n    if (['CLIPTextEncode', 'CLIPTextEncodeSDXL'].includes(node.type)) {\n      var _node$widgets_values;\n      const text = (_node$widgets_values = node.widgets_values) === null || _node$widgets_values === void 0 ? void 0 : _node$widgets_values[0];\n      if (text && typeof text === 'string' && text.trim()) {\n        var _node$title;\n        const cleanText = text.trim();\n        if (isNegativePrompt(cleanText) || (_node$title = node.title) !== null && _node$title !== void 0 && _node$title.toLowerCase().includes('negative')) {\n          negativePrompts.push(cleanText);\n        } else {\n          positivePrompts.push(cleanText);\n        }\n      }\n    }\n  }\n  return {\n    positive: positivePrompts.join(', '),\n    negative: negativePrompts.join(', ')\n  };\n}\n\n// 从ComfyUI提示提取\nfunction extractFromComfyPrompt(prompt) {\n  const positivePrompts = [];\n  const negativePrompts = [];\n  for (const [nodeId, nodeData] of Object.entries(prompt)) {\n    if (['CLIPTextEncode', 'CLIPTextEncodeSDXL'].includes(nodeData.class_type)) {\n      var _nodeData$inputs;\n      const text = (_nodeData$inputs = nodeData.inputs) === null || _nodeData$inputs === void 0 ? void 0 : _nodeData$inputs.text;\n      if (text && typeof text === 'string' && text.trim()) {\n        const cleanText = text.trim();\n        if (isNegativePrompt(cleanText)) {\n          negativePrompts.push(cleanText);\n        } else {\n          positivePrompts.push(cleanText);\n        }\n      }\n    }\n  }\n  return {\n    positive: positivePrompts.join(', '),\n    negative: negativePrompts.join(', ')\n  };\n}\n\n// 检测负向提示词\nfunction isNegativePrompt(text) {\n  const lowerText = text.toLowerCase();\n  const negativeKeywords = ['worst quality', 'bad anatomy', 'ugly', 'blurry', 'lowres', 'bad hands', 'text', 'error', 'cropped'];\n  return negativeKeywords.some(keyword => lowerText.includes(keyword));\n}\n\n// 解析NovelAI数据\nfunction parseNovelAI(text) {\n  const result = {\n    positive: '',\n    negative: '',\n    parameters: {}\n  };\n  try {\n    const data = JSON.parse(text);\n    result.positive = data.prompt || '';\n    result.negative = data.uc || '';\n    ['steps', 'scale', 'seed', 'sampler', 'width', 'height'].forEach(key => {\n      if (data[key] !== undefined) {\n        result.parameters[key] = data[key];\n      }\n    });\n  } catch (error) {\n    console.warn('NovelAI解析失败:', error);\n  }\n  return result;\n}\n\n// EXIF数据提取\nasync function extractFromEXIF(file) {\n  try {\n    // 动态导入exifr\n    const exifr = await import('exifr');\n    const exifData = await exifr.parse(file, {\n      userComment: true,\n      imageDescription: true,\n      software: true\n    });\n    if (!exifData) return null;\n    return {\n      type: 'EXIF',\n      confidence: 'medium',\n      data: {\n        software: exifData.Software,\n        description: exifData.ImageDescription,\n        userComment: exifData.UserComment,\n        positive: exifData.UserComment || exifData.ImageDescription || '',\n        negative: '',\n        parameters: {}\n      }\n    };\n  } catch (error) {\n    console.warn('EXIF提取失败:', error);\n    return null;\n  }\n}\n\n// 标准化数据\nfunction standardizeData(extractedData) {\n  const standardized = {\n    generationTool: 'Unknown',\n    positive: '',\n    negative: '',\n    parameters: {}\n  };\n\n  // 优先级顺序\n  const sources = ['PNG', 'EXIF'];\n  for (const source of sources) {\n    const data = extractedData[source];\n    if (!data) continue;\n    if (data.data.generationTool) {\n      standardized.generationTool = data.data.generationTool;\n    }\n    if (data.data.positive && !standardized.positive) {\n      standardized.positive = data.data.positive;\n    }\n    if (data.data.negative && !standardized.negative) {\n      standardized.negative = data.data.negative;\n    }\n    Object.assign(standardized.parameters, data.data.parameters || {});\n  }\n  return standardized;\n}\n\n// 导出主要函数\nexport const imageMetadataExtractor = {\n  extractMetadata\n};\nexport default imageMetadataExtractor;","map":{"version":3,"names":["extractMetadata","file","console","log","result","success","filename","name","extractedData","standardizedData","timestamp","Date","toISOString","basicInfo","size","sizeFormatted","toFixed","type","lastModified","toLocaleString","pngData","extractFromPNG","PNG","exifData","extractFromEXIF","EXIF","error","warn","standardizeData","Object","keys","length","extractionMethods","map","method","_result$extractedData","confidence","message","Promise","resolve","reject","reader","FileReader","onload","e","buffer","target","chunks","parsePNGChunks","metadata","extractMetadataFromChunks","data","onerror","readAsArrayBuffer","view","DataView","offset","signature","i","getUint8","Error","byteLength","getUint32","String","fromCharCode","Uint8Array","crc","push","textChunks","filter","chunk","includes","generationTool","positive","negative","parameters","textData","parseTextChunk","keyword","text","isAutomatic1111Format","parsed","parseAutomatic1111","assign","parseComfyUI","parseNovelAI","nullIndex","indexOf","decodeLatin1","slice","nullIndices","decodeUTF8","TextDecoder","fatal","decode","lowerText","toLowerCase","negativeIndex","substring","trim","afterNegative","lines","split","negativePrompt","parameterLines","foundParams","line","trimmed","isParameterLine","parseParameters","join","positiveLines","test","paramText","regex","match","exec","key","replace","value","numValue","parseFloat","isNaN","isFinite","JSON","parse","Array","isArray","nodes","prompts","extractFromComfyWorkflow","extractFromComfyPrompt","workflow","positivePrompts","negativePrompts","node","_node$widgets_values","widgets_values","_node$title","cleanText","isNegativePrompt","title","prompt","nodeId","nodeData","entries","class_type","_nodeData$inputs","inputs","negativeKeywords","some","uc","forEach","undefined","exifr","userComment","imageDescription","software","Software","description","ImageDescription","UserComment","standardized","sources","source","imageMetadataExtractor"],"sources":["C:/Users/wjx19/Documents/GitHub/I-Prompt/src/utils/imageMetadataExtractor.js"],"sourcesContent":["/**\n * 简化的图像元数据提取器\n * 参考stable-diffusion-inspector的实现方式\n */\n\n// 主要的提取函数\nexport async function extractMetadata(file) {\n  console.log('🚀 开始提取图像元数据...');\n  \n  const result = {\n    success: false,\n    filename: file.name,\n    extractedData: {},\n    standardizedData: null,\n    timestamp: new Date().toISOString()\n  };\n\n  try {\n    // 基本文件信息\n    result.basicInfo = {\n      size: file.size,\n      sizeFormatted: `${(file.size / 1024).toFixed(1)} KB`,\n      type: file.type,\n      lastModified: new Date(file.lastModified).toLocaleString()\n    };\n\n    // 根据文件类型选择提取方法\n    if (file.type === 'image/png') {\n      const pngData = await extractFromPNG(file);\n      if (pngData) {\n        result.extractedData.PNG = pngData;\n      }\n    }\n\n    // 尝试EXIF提取\n    try {\n      const exifData = await extractFromEXIF(file);\n      if (exifData) {\n        result.extractedData.EXIF = exifData;\n      }\n    } catch (error) {\n      console.warn('EXIF提取失败:', error);\n    }\n\n    // 标准化数据\n    result.standardizedData = standardizeData(result.extractedData);\n    result.success = Object.keys(result.extractedData).length > 0;\n\n    // 添加提取方法信息\n    result.extractionMethods = Object.keys(result.extractedData).map(method => ({\n      method: method,\n      confidence: result.extractedData[method]?.confidence || 'unknown'\n    }));\n\n    return result;\n    \n  } catch (error) {\n    console.error('❌ 元数据提取失败:', error);\n    result.error = error.message;\n    throw error;\n  }\n}\n\n// PNG文件解析 - 参考stable-diffusion-inspector的简洁实现\nasync function extractFromPNG(file) {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    \n    reader.onload = (e) => {\n      try {\n        const buffer = e.target.result;\n        const chunks = parsePNGChunks(buffer);\n        const metadata = extractMetadataFromChunks(chunks);\n        \n        resolve({\n          type: 'PNG',\n          confidence: metadata.confidence || 'medium',\n          data: metadata\n        });\n      } catch (error) {\n        console.warn('PNG解析失败:', error);\n        resolve(null);\n      }\n    };\n    \n    reader.onerror = () => resolve(null);\n    reader.readAsArrayBuffer(file);\n  });\n}\n\n// 简化的PNG块解析\nfunction parsePNGChunks(buffer) {\n  const view = new DataView(buffer);\n  const chunks = [];\n  let offset = 8; // 跳过PNG签名\n\n  // 验证PNG签名\n  const signature = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A];\n  for (let i = 0; i < 8; i++) {\n    if (view.getUint8(i) !== signature[i]) {\n      throw new Error('不是有效的PNG文件');\n    }\n  }\n\n  while (offset < buffer.byteLength - 8) {\n    try {\n      const length = view.getUint32(offset);\n      offset += 4;\n\n      const type = String.fromCharCode(\n        view.getUint8(offset),\n        view.getUint8(offset + 1),\n        view.getUint8(offset + 2),\n        view.getUint8(offset + 3)\n      );\n      offset += 4;\n\n      const data = new Uint8Array(buffer, offset, length);\n      offset += length;\n\n      const crc = view.getUint32(offset);\n      offset += 4;\n\n      chunks.push({ type, length, data, crc });\n\n      if (type === 'IEND') break;\n    } catch (error) {\n      console.warn('PNG块解析警告:', error);\n      break;\n    }\n  }\n\n  return chunks;\n}\n\n// 从PNG块提取元数据\nfunction extractMetadataFromChunks(chunks) {\n  const textChunks = chunks.filter(chunk => \n    ['tEXt', 'iTXt', 'zTXt'].includes(chunk.type)\n  );\n\n  const metadata = {\n    confidence: 'low',\n    generationTool: 'Unknown',\n    positive: '',\n    negative: '',\n    parameters: {}\n  };\n\n  for (const chunk of textChunks) {\n    const textData = parseTextChunk(chunk);\n    if (!textData.keyword || !textData.text) continue;\n\n    console.log('解析文本块:', textData.keyword, '长度:', textData.text.length);\n\n    // 检测不同格式\n    if (textData.keyword === 'parameters' && isAutomatic1111Format(textData.text)) {\n      const parsed = parseAutomatic1111(textData.text);\n      Object.assign(metadata, parsed);\n      metadata.generationTool = 'AUTOMATIC1111';\n      metadata.confidence = 'high';\n    } else if (['workflow', 'prompt'].includes(textData.keyword)) {\n      try {\n        const parsed = parseComfyUI(textData.text);\n        Object.assign(metadata, parsed);\n        metadata.generationTool = 'ComfyUI';\n        metadata.confidence = 'high';\n      } catch (error) {\n        console.warn('ComfyUI解析失败:', error);\n      }\n    } else if (['Description', 'Comment'].includes(textData.keyword)) {\n      try {\n        const parsed = parseNovelAI(textData.text);\n        Object.assign(metadata, parsed);\n        metadata.generationTool = 'NovelAI';\n        metadata.confidence = 'high';\n      } catch (error) {\n        console.warn('NovelAI解析失败:', error);\n      }\n    }\n  }\n\n  return metadata;\n}\n\n// 解析文本块\nfunction parseTextChunk(chunk) {\n  try {\n    const data = chunk.data;\n    \n    if (chunk.type === 'tEXt') {\n      const nullIndex = data.indexOf(0);\n      if (nullIndex === -1) return {};\n\n      const keyword = decodeLatin1(data.slice(0, nullIndex));\n      const text = decodeLatin1(data.slice(nullIndex + 1));\n      return { keyword, text };\n    }\n    \n    if (chunk.type === 'iTXt') {\n      const nullIndices = [];\n      for (let i = 0; i < data.length; i++) {\n        if (data[i] === 0) {\n          nullIndices.push(i);\n          if (nullIndices.length >= 4) break;\n        }\n      }\n\n      if (nullIndices.length < 4) return {};\n\n      const keyword = decodeUTF8(data.slice(0, nullIndices[0]));\n      const text = decodeUTF8(data.slice(nullIndices[3] + 1));\n      return { keyword, text };\n    }\n    \n    return {};\n  } catch (error) {\n    console.warn('文本块解析失败:', error);\n    return {};\n  }\n}\n\n// 安全的字符解码\nfunction decodeLatin1(data) {\n  let result = '';\n  for (let i = 0; i < data.length; i++) {\n    result += String.fromCharCode(data[i]);\n  }\n  return result;\n}\n\nfunction decodeUTF8(data) {\n  try {\n    return new TextDecoder('utf-8', { fatal: false }).decode(data);\n  } catch (error) {\n    return decodeLatin1(data);\n  }\n}\n\n// 检测AUTOMATIC1111格式\nfunction isAutomatic1111Format(text) {\n  const lowerText = text.toLowerCase();\n  return lowerText.includes('steps:') || \n         lowerText.includes('cfg scale:') || \n         lowerText.includes('sampler:') || \n         lowerText.includes('negative prompt:');\n}\n\n// 解析AUTOMATIC1111数据\nfunction parseAutomatic1111(text) {\n  const result = {\n    positive: '',\n    negative: '',\n    parameters: {}\n  };\n\n  try {\n    const negativeIndex = text.indexOf('Negative prompt:');\n    \n    if (negativeIndex !== -1) {\n      result.positive = text.substring(0, negativeIndex).trim();\n      \n      const afterNegative = text.substring(negativeIndex + 16);\n      const lines = afterNegative.split('\\n');\n      \n      let negativePrompt = '';\n      let parameterLines = [];\n      let foundParams = false;\n      \n      for (const line of lines) {\n        const trimmed = line.trim();\n        if (isParameterLine(trimmed)) {\n          foundParams = true;\n          parameterLines.push(trimmed);\n        } else if (!foundParams && trimmed) {\n          negativePrompt += (negativePrompt ? '\\n' : '') + trimmed;\n        } else if (foundParams) {\n          parameterLines.push(trimmed);\n        }\n      }\n      \n      result.negative = negativePrompt.trim();\n      \n      if (parameterLines.length > 0) {\n        result.parameters = parseParameters(parameterLines.join(', '));\n      }\n    } else {\n      // 没有负向提示词的情况\n      const lines = text.split('\\n');\n      let positiveLines = [];\n      let parameterLines = [];\n      let foundParams = false;\n      \n      for (const line of lines) {\n        const trimmed = line.trim();\n        if (isParameterLine(trimmed)) {\n          foundParams = true;\n          parameterLines.push(trimmed);\n        } else if (!foundParams && trimmed) {\n          positiveLines.push(trimmed);\n        } else if (foundParams) {\n          parameterLines.push(trimmed);\n        }\n      }\n      \n      result.positive = positiveLines.join(' ').trim();\n      \n      if (parameterLines.length > 0) {\n        result.parameters = parseParameters(parameterLines.join(', '));\n      }\n    }\n  } catch (error) {\n    console.warn('AUTOMATIC1111解析警告:', error);\n    result.positive = text;\n  }\n\n  return result;\n}\n\n// 检测参数行\nfunction isParameterLine(line) {\n  return /\\b(Steps|Sampler|CFG scale|Seed|Size|Model):/i.test(line);\n}\n\n// 解析参数\nfunction parseParameters(paramText) {\n  const parameters = {};\n  const regex = /(\\w+(?:\\s+\\w+)*)\\s*:\\s*([^,]+?)(?=,\\s*\\w+\\s*:|$)/g;\n  let match;\n\n  while ((match = regex.exec(paramText)) !== null) {\n    const key = match[1].trim().toLowerCase().replace(/\\s+/g, '');\n    const value = match[2].trim();\n    \n    const numValue = parseFloat(value);\n    parameters[key] = !isNaN(numValue) && isFinite(numValue) ? numValue : value;\n  }\n\n  return parameters;\n}\n\n// 解析ComfyUI数据\nfunction parseComfyUI(text) {\n  const result = {\n    positive: '',\n    negative: '',\n    parameters: {}\n  };\n\n  try {\n    const data = JSON.parse(text);\n    \n    if (Array.isArray(data?.nodes)) {\n      // 工作流格式\n      const prompts = extractFromComfyWorkflow(data);\n      result.positive = prompts.positive;\n      result.negative = prompts.negative;\n    } else if (typeof data === 'object') {\n      // 提示格式\n      const prompts = extractFromComfyPrompt(data);\n      result.positive = prompts.positive;\n      result.negative = prompts.negative;\n    }\n  } catch (error) {\n    console.warn('ComfyUI解析失败:', error);\n  }\n\n  return result;\n}\n\n// 从ComfyUI工作流提取\nfunction extractFromComfyWorkflow(workflow) {\n  const positivePrompts = [];\n  const negativePrompts = [];\n\n  for (const node of workflow.nodes || []) {\n    if (['CLIPTextEncode', 'CLIPTextEncodeSDXL'].includes(node.type)) {\n      const text = node.widgets_values?.[0];\n      if (text && typeof text === 'string' && text.trim()) {\n        const cleanText = text.trim();\n        \n        if (isNegativePrompt(cleanText) || \n            node.title?.toLowerCase().includes('negative')) {\n          negativePrompts.push(cleanText);\n        } else {\n          positivePrompts.push(cleanText);\n        }\n      }\n    }\n  }\n\n  return {\n    positive: positivePrompts.join(', '),\n    negative: negativePrompts.join(', ')\n  };\n}\n\n// 从ComfyUI提示提取\nfunction extractFromComfyPrompt(prompt) {\n  const positivePrompts = [];\n  const negativePrompts = [];\n\n  for (const [nodeId, nodeData] of Object.entries(prompt)) {\n    if (['CLIPTextEncode', 'CLIPTextEncodeSDXL'].includes(nodeData.class_type)) {\n      const text = nodeData.inputs?.text;\n      if (text && typeof text === 'string' && text.trim()) {\n        const cleanText = text.trim();\n        \n        if (isNegativePrompt(cleanText)) {\n          negativePrompts.push(cleanText);\n        } else {\n          positivePrompts.push(cleanText);\n        }\n      }\n    }\n  }\n\n  return {\n    positive: positivePrompts.join(', '),\n    negative: negativePrompts.join(', ')\n  };\n}\n\n// 检测负向提示词\nfunction isNegativePrompt(text) {\n  const lowerText = text.toLowerCase();\n  const negativeKeywords = [\n    'worst quality', 'bad anatomy', 'ugly', 'blurry', 'lowres',\n    'bad hands', 'text', 'error', 'cropped'\n  ];\n  \n  return negativeKeywords.some(keyword => lowerText.includes(keyword));\n}\n\n// 解析NovelAI数据\nfunction parseNovelAI(text) {\n  const result = {\n    positive: '',\n    negative: '',\n    parameters: {}\n  };\n\n  try {\n    const data = JSON.parse(text);\n    result.positive = data.prompt || '';\n    result.negative = data.uc || '';\n    \n    ['steps', 'scale', 'seed', 'sampler', 'width', 'height'].forEach(key => {\n      if (data[key] !== undefined) {\n        result.parameters[key] = data[key];\n      }\n    });\n  } catch (error) {\n    console.warn('NovelAI解析失败:', error);\n  }\n\n  return result;\n}\n\n// EXIF数据提取\nasync function extractFromEXIF(file) {\n  try {\n    // 动态导入exifr\n    const exifr = await import('exifr');\n    \n    const exifData = await exifr.parse(file, {\n      userComment: true,\n      imageDescription: true,\n      software: true\n    });\n\n    if (!exifData) return null;\n\n    return {\n      type: 'EXIF',\n      confidence: 'medium',\n      data: {\n        software: exifData.Software,\n        description: exifData.ImageDescription,\n        userComment: exifData.UserComment,\n        positive: exifData.UserComment || exifData.ImageDescription || '',\n        negative: '',\n        parameters: {}\n      }\n    };\n  } catch (error) {\n    console.warn('EXIF提取失败:', error);\n    return null;\n  }\n}\n\n// 标准化数据\nfunction standardizeData(extractedData) {\n  const standardized = {\n    generationTool: 'Unknown',\n    positive: '',\n    negative: '',\n    parameters: {}\n  };\n\n  // 优先级顺序\n  const sources = ['PNG', 'EXIF'];\n  \n  for (const source of sources) {\n    const data = extractedData[source];\n    if (!data) continue;\n\n    if (data.data.generationTool) {\n      standardized.generationTool = data.data.generationTool;\n    }\n\n    if (data.data.positive && !standardized.positive) {\n      standardized.positive = data.data.positive;\n    }\n\n    if (data.data.negative && !standardized.negative) {\n      standardized.negative = data.data.negative;\n    }\n\n    Object.assign(standardized.parameters, data.data.parameters || {});\n  }\n\n  return standardized;\n}\n\n// 导出主要函数\nexport const imageMetadataExtractor = {\n  extractMetadata\n};\n\nexport default imageMetadataExtractor; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}