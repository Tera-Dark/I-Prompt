{"ast":null,"code":"import exifr from 'exifr';\n\n/**\r\n * 专业级图像元数据提取器 v2.0\r\n * 基于stable-diffusion-inspector、auto1111-pnginfo等开源项目的最佳实践\r\n * 专门解决PNG文本块解析、字符编码和提示词截断问题\r\n */\n\n/**\r\n * 主提取方法\r\n */\nasync function extractMetadata(file) {\n  console.log('🚀 开始专业级元数据提取...');\n  const result = {\n    success: false,\n    filename: file.name,\n    extractedData: {},\n    standardizedData: null,\n    errors: []\n  };\n  try {\n    // 并行运行多种提取方法\n    const extractionPromises = [extractFromEXIF(file), file.type === 'image/png' ? extractFromPNGChunks(file) : null].filter(Boolean);\n    const extractionResults = await Promise.allSettled(extractionPromises);\n\n    // 整合结果\n    extractionResults.forEach((promiseResult, index) => {\n      if (promiseResult.status === 'fulfilled' && promiseResult.value) {\n        const methodNames = ['EXIF', 'PNG_Chunks'];\n        const methodName = methodNames[index];\n        result.extractedData[methodName] = promiseResult.value;\n      }\n    });\n\n    // 标准化数据\n    result.standardizedData = standardizeExtractedData(result.extractedData);\n    result.success = Object.keys(result.extractedData).length > 0;\n    return result;\n  } catch (error) {\n    console.error('❌ 元数据提取失败:', error);\n    result.errors.push(`总体错误: ${error.message}`);\n    throw new Error(`元数据提取失败: ${error.message}`);\n  }\n}\n\n/**\r\n * 专业级PNG文本块提取器 - 修复特殊字符截断问题\r\n */\nasync function extractFromPNGChunks(file) {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = e => {\n      try {\n        const buffer = e.target.result;\n        const view = new DataView(buffer);\n\n        // PNG签名验证\n        const pngSignature = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A];\n        for (let i = 0; i < 8; i++) {\n          if (view.getUint8(i) !== pngSignature[i]) {\n            throw new Error('不是有效的PNG文件');\n          }\n        }\n        const chunks = parsePNGChunks(buffer);\n        const metadata = extractAIMetadataFromChunks(chunks);\n        resolve({\n          type: 'PNG_Chunks',\n          confidence: metadata.confidence || 'high',\n          data: metadata\n        });\n      } catch (error) {\n        reject(error);\n      }\n    };\n    reader.onerror = () => reject(new Error('文件读取失败'));\n    reader.readAsArrayBuffer(file);\n  });\n}\n\n/**\r\n * 高级PNG块解析器 - 安全处理所有字符\r\n */\nfunction parsePNGChunks(buffer) {\n  const view = new DataView(buffer);\n  const chunks = [];\n  let offset = 8; // 跳过PNG签名\n\n  while (offset < buffer.byteLength - 8) {\n    try {\n      // 读取块长度 (big-endian)\n      const length = view.getUint32(offset);\n      if (length > buffer.byteLength - offset) break; // 安全检查\n      offset += 4;\n\n      // 读取块类型\n      const type = readChunkType(view, offset);\n      offset += 4;\n\n      // 读取块数据\n      const data = new Uint8Array(buffer, offset, length);\n      offset += length;\n\n      // 读取CRC\n      const crc = view.getUint32(offset);\n      offset += 4;\n      chunks.push({\n        type,\n        length,\n        data,\n        crc\n      });\n      if (type === 'IEND') break;\n    } catch (error) {\n      console.warn('PNG块解析警告:', error);\n      break;\n    }\n  }\n  return chunks;\n}\n\n/**\r\n * 安全的块类型读取\r\n */\nfunction readChunkType(view, offset) {\n  const bytes = [];\n  for (let i = 0; i < 4; i++) {\n    bytes.push(view.getUint8(offset + i));\n  }\n  return String.fromCharCode(...bytes);\n}\n\n/**\r\n * 从PNG块提取AI元数据 - 专门处理SD生成的图像\r\n */\nfunction extractAIMetadataFromChunks(chunks) {\n  const textChunks = chunks.filter(chunk => ['tEXt', 'iTXt', 'zTXt'].includes(chunk.type));\n  const metadata = {\n    confidence: 'low',\n    generationTool: 'Unknown',\n    positive: '',\n    negative: '',\n    parameters: {}\n  };\n  for (const chunk of textChunks) {\n    const textData = parseTextChunk(chunk);\n    if (!textData.keyword || !textData.text) continue;\n    console.log('解析PNG文本块:', textData.keyword, '长度:', textData.text.length);\n\n    // 检测不同AI工具的数据格式\n    if (isAutomatic1111Format(textData)) {\n      Object.assign(metadata, parseAutomatic1111Data(textData.text));\n      metadata.generationTool = 'AUTOMATIC1111';\n      metadata.confidence = 'high';\n    } else if (isComfyUIFormat(textData)) {\n      Object.assign(metadata, parseComfyUIData(textData.text));\n      metadata.generationTool = 'ComfyUI';\n      metadata.confidence = 'high';\n    } else if (isNovelAIFormat(textData)) {\n      Object.assign(metadata, parseNovelAIData(textData.text));\n      metadata.generationTool = 'NovelAI';\n      metadata.confidence = 'high';\n    } else if (containsPromptLikeText(textData.text)) {\n      metadata.positive = textData.text;\n      metadata.confidence = 'medium';\n    }\n  }\n  return metadata;\n}\n\n/**\r\n * 高级文本块解析器 - 正确处理所有编码和特殊字符\r\n */\nfunction parseTextChunk(chunk) {\n  try {\n    const data = chunk.data;\n    if (chunk.type === 'tEXt') {\n      return parseTEXt(data);\n    } else if (chunk.type === 'iTXt') {\n      return parseITXt(data);\n    } else if (chunk.type === 'zTXt') {\n      return parseZTXt(data);\n    }\n    return {};\n  } catch (error) {\n    console.warn('文本块解析失败:', error);\n    return {};\n  }\n}\n\n/**\r\n * 解析tEXt块 - Latin-1编码，安全处理特殊字符\r\n */\nfunction parseTEXt(data) {\n  const nullIndex = data.indexOf(0);\n  if (nullIndex === -1) return {};\n  const keyword = decodeLatin1(data.slice(0, nullIndex));\n  const text = decodeLatin1(data.slice(nullIndex + 1));\n  return {\n    keyword,\n    text\n  };\n}\n\n/**\r\n * 解析iTXt块 - UTF-8编码\r\n */\nfunction parseITXt(data) {\n  try {\n    const nullIndices = [];\n    for (let i = 0; i < data.length; i++) {\n      if (data[i] === 0) {\n        nullIndices.push(i);\n        if (nullIndices.length >= 4) break;\n      }\n    }\n    if (nullIndices.length < 4) return {};\n    const keyword = decodeUTF8(data.slice(0, nullIndices[0]));\n    const text = decodeUTF8(data.slice(nullIndices[3] + 1));\n    return {\n      keyword,\n      text\n    };\n  } catch (error) {\n    console.warn('iTXt解析失败:', error);\n    return {};\n  }\n}\n\n/**\r\n * 解析zTXt块 - 压缩文本\r\n */\nfunction parseZTXt(data) {\n  try {\n    const nullIndex = data.indexOf(0);\n    if (nullIndex === -1) return {};\n    const keyword = decodeLatin1(data.slice(0, nullIndex));\n    const compression = data[nullIndex + 1];\n    if (compression !== 0) {\n      return {\n        keyword,\n        text: '[压缩文本-暂不支持]'\n      };\n    }\n    return {\n      keyword,\n      text: '[需要zlib解压缩]',\n      compressed: true\n    };\n  } catch (error) {\n    console.warn('zTXt解析失败:', error);\n    return {};\n  }\n}\n\n/**\r\n * 安全的Latin-1解码 - 逐字节处理，永不截断\r\n */\nfunction decodeLatin1(data) {\n  let result = '';\n  for (let i = 0; i < data.length; i++) {\n    result += String.fromCharCode(data[i]);\n  }\n  return result;\n}\n\n/**\r\n * 安全的UTF-8解码\r\n */\nfunction decodeUTF8(data) {\n  try {\n    return new TextDecoder('utf-8', {\n      fatal: false\n    }).decode(data);\n  } catch (error) {\n    console.warn('UTF-8解码失败，使用Latin-1:', error);\n    return decodeLatin1(data);\n  }\n}\n\n/**\r\n * 检测AUTOMATIC1111格式\r\n */\nfunction isAutomatic1111Format(textData) {\n  if (textData.keyword !== 'parameters') return false;\n  const text = textData.text.toLowerCase();\n  return text.includes('steps:') || text.includes('cfg scale:') || text.includes('sampler:') || text.includes('negative prompt:');\n}\n\n/**\r\n * 解析AUTOMATIC1111数据 - 增强版，不会截断提示词\r\n */\nfunction parseAutomatic1111Data(text) {\n  const result = {\n    positive: '',\n    negative: '',\n    parameters: {}\n  };\n  try {\n    // 查找负向提示词分隔符\n    const negativePromptIndex = text.indexOf('Negative prompt:');\n    if (negativePromptIndex !== -1) {\n      // 提取正向提示词\n      result.positive = text.substring(0, negativePromptIndex).trim();\n\n      // 提取剩余部分\n      const afterNegative = text.substring(negativePromptIndex + 16); // 'Negative prompt:' 长度\n\n      // 查找参数部分的开始\n      const parameterLines = afterNegative.split('\\n');\n      let negativePrompt = '';\n      let parametersStartIndex = -1;\n      for (let i = 0; i < parameterLines.length; i++) {\n        const line = parameterLines[i].trim();\n        if (looksLikeParameterLine(line)) {\n          parametersStartIndex = i;\n          break;\n        } else if (line) {\n          negativePrompt += (negativePrompt ? '\\n' : '') + line;\n        }\n      }\n      result.negative = negativePrompt.trim();\n\n      // 解析参数\n      if (parametersStartIndex !== -1) {\n        const paramText = parameterLines.slice(parametersStartIndex).join(', ');\n        result.parameters = parseParameterString(paramText);\n      }\n    } else {\n      // 没有负向提示词，查找参数分隔\n      const lines = text.split('\\n');\n      let positiveLines = [];\n      let parameterLines = [];\n      let foundParameters = false;\n      for (const line of lines) {\n        const trimmedLine = line.trim();\n        if (looksLikeParameterLine(trimmedLine)) {\n          foundParameters = true;\n          parameterLines.push(trimmedLine);\n        } else if (!foundParameters && trimmedLine) {\n          positiveLines.push(trimmedLine);\n        } else if (foundParameters) {\n          parameterLines.push(trimmedLine);\n        }\n      }\n      result.positive = positiveLines.join(' ').trim();\n      if (parameterLines.length > 0) {\n        result.parameters = parseParameterString(parameterLines.join(', '));\n      }\n    }\n  } catch (error) {\n    console.warn('AUTOMATIC1111解析警告:', error);\n    result.positive = text; // 备用方案\n  }\n  return result;\n}\n\n/**\r\n * 检测ComfyUI格式\r\n */\nfunction isComfyUIFormat(textData) {\n  if (!['workflow', 'prompt'].includes(textData.keyword)) return false;\n  try {\n    const parsed = JSON.parse(textData.text);\n    return parsed && typeof parsed === 'object';\n  } catch {\n    return false;\n  }\n}\n\n/**\r\n * 解析ComfyUI数据 - 完整提取，不截断\r\n */\nfunction parseComfyUIData(text) {\n  const result = {\n    positive: '',\n    negative: '',\n    parameters: {}\n  };\n  try {\n    const data = JSON.parse(text);\n    if (Array.isArray(data === null || data === void 0 ? void 0 : data.nodes)) {\n      // 工作流格式\n      const prompts = extractPromptsFromComfyWorkflow(data);\n      result.positive = prompts.positive;\n      result.negative = prompts.negative;\n      result.parameters.workflow = data;\n    } else if (typeof data === 'object') {\n      // 提示格式\n      const prompts = extractPromptsFromComfyPrompt(data);\n      result.positive = prompts.positive;\n      result.negative = prompts.negative;\n      result.parameters.prompt = data;\n    }\n  } catch (error) {\n    console.warn('ComfyUI解析警告:', error);\n  }\n  return result;\n}\n\n/**\r\n * 从ComfyUI工作流提取提示词 - 修复版，收集所有文本\r\n */\nfunction extractPromptsFromComfyWorkflow(workflow) {\n  const positivePrompts = [];\n  const negativePrompts = [];\n  for (const node of workflow.nodes || []) {\n    if (['CLIPTextEncode', 'CLIPTextEncodeSDXL', 'ConditioningCombine'].includes(node.type)) {\n      var _node$widgets_values;\n      const text = (_node$widgets_values = node.widgets_values) === null || _node$widgets_values === void 0 ? void 0 : _node$widgets_values[0];\n      if (text && typeof text === 'string' && text.trim()) {\n        var _node$title, _node$title2;\n        const cleanText = text.trim();\n\n        // 根据节点标题或内容判断正负向\n        const isNegative = isNegativePrompt(cleanText) || ((_node$title = node.title) === null || _node$title === void 0 ? void 0 : _node$title.toLowerCase().includes('negative')) || ((_node$title2 = node.title) === null || _node$title2 === void 0 ? void 0 : _node$title2.toLowerCase().includes('neg'));\n        if (isNegative) {\n          negativePrompts.push(cleanText);\n        } else {\n          positivePrompts.push(cleanText);\n        }\n      }\n    }\n  }\n  return {\n    positive: mergePrompts(positivePrompts),\n    negative: mergePrompts(negativePrompts)\n  };\n}\n\n/**\r\n * 从ComfyUI提示提取提示词\r\n */\nfunction extractPromptsFromComfyPrompt(prompt) {\n  const positivePrompts = [];\n  const negativePrompts = [];\n  for (const [nodeId, nodeData] of Object.entries(prompt)) {\n    if (['CLIPTextEncode', 'CLIPTextEncodeSDXL'].includes(nodeData.class_type)) {\n      var _nodeData$inputs;\n      const text = (_nodeData$inputs = nodeData.inputs) === null || _nodeData$inputs === void 0 ? void 0 : _nodeData$inputs.text;\n      if (text && typeof text === 'string' && text.trim()) {\n        const cleanText = text.trim();\n        if (isNegativePrompt(cleanText)) {\n          negativePrompts.push(cleanText);\n        } else {\n          positivePrompts.push(cleanText);\n        }\n      }\n    }\n  }\n  return {\n    positive: mergePrompts(positivePrompts),\n    negative: mergePrompts(negativePrompts)\n  };\n}\n\n/**\r\n * 智能合并提示词 - 保持完整性\r\n */\nfunction mergePrompts(prompts) {\n  if (!prompts.length) return '';\n  if (prompts.length === 1) return prompts[0];\n\n  // 检查是否有明显更长更完整的提示词\n  const longest = prompts.reduce((max, current) => current.length > max.length ? current : max);\n\n  // 如果最长的比其他的长很多，选择它\n  const avgLength = prompts.reduce((sum, p) => sum + p.length, 0) / prompts.length;\n  if (longest.length > avgLength * 2) {\n    return longest;\n  }\n\n  // 否则按长度排序，优先选择长的\n  const sorted = [...prompts].sort((a, b) => b.length - a.length);\n  return sorted[0];\n}\n\n/**\r\n * 检测NovelAI格式\r\n */\nfunction isNovelAIFormat(textData) {\n  if (!['Description', 'Comment'].includes(textData.keyword)) return false;\n  try {\n    const parsed = JSON.parse(textData.text);\n    return parsed.prompt !== undefined || parsed.uc !== undefined;\n  } catch {\n    return false;\n  }\n}\n\n/**\r\n * 解析NovelAI数据\r\n */\nfunction parseNovelAIData(text) {\n  const result = {\n    positive: '',\n    negative: '',\n    parameters: {}\n  };\n  try {\n    const data = JSON.parse(text);\n    result.positive = data.prompt || '';\n    result.negative = data.uc || '';\n    ['steps', 'scale', 'seed', 'sampler', 'width', 'height'].forEach(key => {\n      if (data[key] !== undefined) {\n        result.parameters[key] = data[key];\n      }\n    });\n  } catch (error) {\n    console.warn('NovelAI解析警告:', error);\n  }\n  return result;\n}\n\n/**\r\n * 改进的负向提示词检测\r\n */\nfunction isNegativePrompt(text) {\n  if (!text || typeof text !== 'string') return false;\n  const lowerText = text.toLowerCase();\n  const strongNegative = ['worst quality', 'bad anatomy', 'ugly', 'blurry', 'lowres', 'bad hands', 'text', 'error', 'cropped', 'out of frame', 'deformed', 'mutated', 'malformed', 'poorly drawn'];\n  return strongNegative.some(keyword => lowerText.includes(keyword));\n}\n\n/**\r\n * 检测提示词样式文本\r\n */\nfunction containsPromptLikeText(text) {\n  if (!text || typeof text !== 'string' || text.length < 10) return false;\n  const keywords = ['masterpiece', 'best quality', 'detailed', 'high resolution', 'realistic', 'anime', 'portrait', 'landscape'];\n  const lowerText = text.toLowerCase();\n  const hasKeywords = keywords.some(keyword => lowerText.includes(keyword));\n  const hasCommas = text.includes(',') && text.split(',').length > 2;\n  return hasKeywords || hasCommas;\n}\n\n/**\r\n * 检测参数行\r\n */\nfunction looksLikeParameterLine(line) {\n  const parameterPattern = /\\b(Steps|Sampler|CFG scale|Seed|Size|Model|Clip skip|Denoising strength):/i;\n  return parameterPattern.test(line);\n}\n\n/**\r\n * 解析参数字符串\r\n */\nfunction parseParameterString(paramText) {\n  const parameters = {};\n  const paramPattern = /(\\w+(?:\\s+\\w+)*)\\s*:\\s*([^,]+?)(?=,\\s*\\w+\\s*:|$)/g;\n  let match;\n  while ((match = paramPattern.exec(paramText)) !== null) {\n    const key = match[1].trim();\n    const value = match[2].trim();\n    const normalizedKey = normalizeParameterKey(key);\n    parameters[normalizedKey] = parseParameterValue(value);\n  }\n  return parameters;\n}\n\n/**\r\n * 标准化参数键名\r\n */\nfunction normalizeParameterKey(key) {\n  const keyMap = {\n    'steps': 'steps',\n    'sampler': 'sampler',\n    'cfg scale': 'cfgScale',\n    'seed': 'seed',\n    'size': 'size',\n    'model hash': 'modelHash',\n    'model': 'model',\n    'clip skip': 'clipSkip',\n    'denoising strength': 'denoisingStrength'\n  };\n  return keyMap[key.toLowerCase()] || key.replace(/\\s+/g, '');\n}\n\n/**\r\n * 解析参数值\r\n */\nfunction parseParameterValue(value) {\n  const numValue = parseFloat(value);\n  if (!isNaN(numValue) && isFinite(numValue)) {\n    return Number.isInteger(numValue) ? parseInt(value) : numValue;\n  }\n  return value;\n}\n\n/**\r\n * EXIF数据提取\r\n */\nasync function extractFromEXIF(file) {\n  try {\n    const exifData = await exifr.parse(file, {\n      userComment: true,\n      imageDescription: true,\n      software: true\n    });\n    if (!exifData) return null;\n    const result = {\n      type: 'EXIF',\n      confidence: 'medium',\n      data: {\n        software: exifData.Software,\n        description: exifData.ImageDescription,\n        userComment: exifData.UserComment\n      }\n    };\n    if (exifData.UserComment) {\n      const aiData = parseUserComment(exifData.UserComment);\n      if (aiData.positive || aiData.negative) {\n        Object.assign(result.data, aiData);\n        result.confidence = 'high';\n      }\n    }\n    return result;\n  } catch (error) {\n    console.warn('EXIF提取失败:', error);\n    return null;\n  }\n}\n\n/**\r\n * 解析UserComment\r\n */\nfunction parseUserComment(userComment) {\n  const result = {\n    positive: '',\n    negative: '',\n    parameters: {}\n  };\n  try {\n    if (userComment.startsWith('{')) {\n      const data = JSON.parse(userComment);\n      result.positive = data.prompt || data.positive || '';\n      result.negative = data.negativePrompt || data.negative || '';\n      result.parameters = data.parameters || {};\n    } else {\n      result.positive = userComment;\n    }\n  } catch {\n    result.positive = userComment;\n  }\n  return result;\n}\n\n/**\r\n * 标准化提取的数据\r\n */\nfunction standardizeExtractedData(extractedData) {\n  const standardized = {\n    generationTool: 'Unknown',\n    positive: '',\n    negative: '',\n    parameters: {}\n  };\n  const priorityOrder = ['PNG_Chunks', 'EXIF'];\n  for (const source of priorityOrder) {\n    const data = extractedData[source];\n    if (!data) continue;\n    if (data.data.generationTool) {\n      standardized.generationTool = data.data.generationTool;\n    }\n    if (data.data.positive && !standardized.positive) {\n      standardized.positive = data.data.positive;\n    }\n    if (data.data.negative && !standardized.negative) {\n      standardized.negative = data.data.negative;\n    }\n    Object.assign(standardized.parameters, data.data.parameters || {});\n  }\n  return standardized;\n}\n\n// 创建单例对象，按照原项目标准\nexport const imageMetadataExtractor = {\n  extractMetadata\n};\n\n// 默认导出\nexport default imageMetadataExtractor;","map":{"version":3,"names":["exifr","extractMetadata","file","console","log","result","success","filename","name","extractedData","standardizedData","errors","extractionPromises","extractFromEXIF","type","extractFromPNGChunks","filter","Boolean","extractionResults","Promise","allSettled","forEach","promiseResult","index","status","value","methodNames","methodName","standardizeExtractedData","Object","keys","length","error","push","message","Error","resolve","reject","reader","FileReader","onload","e","buffer","target","view","DataView","pngSignature","i","getUint8","chunks","parsePNGChunks","metadata","extractAIMetadataFromChunks","confidence","data","onerror","readAsArrayBuffer","offset","byteLength","getUint32","readChunkType","Uint8Array","crc","warn","bytes","String","fromCharCode","textChunks","chunk","includes","generationTool","positive","negative","parameters","textData","parseTextChunk","keyword","text","isAutomatic1111Format","assign","parseAutomatic1111Data","isComfyUIFormat","parseComfyUIData","isNovelAIFormat","parseNovelAIData","containsPromptLikeText","parseTEXt","parseITXt","parseZTXt","nullIndex","indexOf","decodeLatin1","slice","nullIndices","decodeUTF8","compression","compressed","TextDecoder","fatal","decode","toLowerCase","negativePromptIndex","substring","trim","afterNegative","parameterLines","split","negativePrompt","parametersStartIndex","line","looksLikeParameterLine","paramText","join","parseParameterString","lines","positiveLines","foundParameters","trimmedLine","parsed","JSON","parse","Array","isArray","nodes","prompts","extractPromptsFromComfyWorkflow","workflow","extractPromptsFromComfyPrompt","prompt","positivePrompts","negativePrompts","node","_node$widgets_values","widgets_values","_node$title","_node$title2","cleanText","isNegative","isNegativePrompt","title","mergePrompts","nodeId","nodeData","entries","class_type","_nodeData$inputs","inputs","longest","reduce","max","current","avgLength","sum","p","sorted","sort","a","b","undefined","uc","key","lowerText","strongNegative","some","keywords","hasKeywords","hasCommas","parameterPattern","test","paramPattern","match","exec","normalizedKey","normalizeParameterKey","parseParameterValue","keyMap","replace","numValue","parseFloat","isNaN","isFinite","Number","isInteger","parseInt","exifData","userComment","imageDescription","software","Software","description","ImageDescription","UserComment","aiData","parseUserComment","startsWith","standardized","priorityOrder","source","imageMetadataExtractor"],"sources":["C:/Users/wjx19/Documents/GitHub/I-Prompt/src/utils/imageMetadataExtractor.js"],"sourcesContent":["import exifr from 'exifr';\r\n\r\n/**\r\n * 专业级图像元数据提取器 v2.0\r\n * 基于stable-diffusion-inspector、auto1111-pnginfo等开源项目的最佳实践\r\n * 专门解决PNG文本块解析、字符编码和提示词截断问题\r\n */\r\n\r\n/**\r\n * 主提取方法\r\n */\r\nasync function extractMetadata(file) {\r\n  console.log('🚀 开始专业级元数据提取...');\r\n  \r\n  const result = {\r\n    success: false,\r\n    filename: file.name,\r\n    extractedData: {},\r\n    standardizedData: null,\r\n    errors: []\r\n  };\r\n\r\n  try {\r\n    // 并行运行多种提取方法\r\n    const extractionPromises = [\r\n      extractFromEXIF(file),\r\n      file.type === 'image/png' ? extractFromPNGChunks(file) : null\r\n    ].filter(Boolean);\r\n\r\n    const extractionResults = await Promise.allSettled(extractionPromises);\r\n    \r\n    // 整合结果\r\n    extractionResults.forEach((promiseResult, index) => {\r\n      if (promiseResult.status === 'fulfilled' && promiseResult.value) {\r\n        const methodNames = ['EXIF', 'PNG_Chunks'];\r\n        const methodName = methodNames[index];\r\n        result.extractedData[methodName] = promiseResult.value;\r\n      }\r\n    });\r\n\r\n    // 标准化数据\r\n    result.standardizedData = standardizeExtractedData(result.extractedData);\r\n    result.success = Object.keys(result.extractedData).length > 0;\r\n\r\n    return result;\r\n    \r\n  } catch (error) {\r\n    console.error('❌ 元数据提取失败:', error);\r\n    result.errors.push(`总体错误: ${error.message}`);\r\n    throw new Error(`元数据提取失败: ${error.message}`);\r\n  }\r\n}\r\n\r\n/**\r\n * 专业级PNG文本块提取器 - 修复特殊字符截断问题\r\n */\r\nasync function extractFromPNGChunks(file) {\r\n  return new Promise((resolve, reject) => {\r\n    const reader = new FileReader();\r\n    \r\n    reader.onload = (e) => {\r\n      try {\r\n        const buffer = e.target.result;\r\n        const view = new DataView(buffer);\r\n        \r\n        // PNG签名验证\r\n        const pngSignature = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A];\r\n        for (let i = 0; i < 8; i++) {\r\n          if (view.getUint8(i) !== pngSignature[i]) {\r\n            throw new Error('不是有效的PNG文件');\r\n          }\r\n        }\r\n\r\n        const chunks = parsePNGChunks(buffer);\r\n        const metadata = extractAIMetadataFromChunks(chunks);\r\n        \r\n        resolve({\r\n          type: 'PNG_Chunks',\r\n          confidence: metadata.confidence || 'high',\r\n          data: metadata\r\n        });\r\n        \r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    };\r\n    \r\n    reader.onerror = () => reject(new Error('文件读取失败'));\r\n    reader.readAsArrayBuffer(file);\r\n  });\r\n}\r\n\r\n/**\r\n * 高级PNG块解析器 - 安全处理所有字符\r\n */\r\nfunction parsePNGChunks(buffer) {\r\n  const view = new DataView(buffer);\r\n  const chunks = [];\r\n  let offset = 8; // 跳过PNG签名\r\n\r\n  while (offset < buffer.byteLength - 8) {\r\n    try {\r\n      // 读取块长度 (big-endian)\r\n      const length = view.getUint32(offset);\r\n      if (length > buffer.byteLength - offset) break; // 安全检查\r\n      offset += 4;\r\n\r\n      // 读取块类型\r\n      const type = readChunkType(view, offset);\r\n      offset += 4;\r\n\r\n      // 读取块数据\r\n      const data = new Uint8Array(buffer, offset, length);\r\n      offset += length;\r\n\r\n      // 读取CRC\r\n      const crc = view.getUint32(offset);\r\n      offset += 4;\r\n\r\n      chunks.push({ type, length, data, crc });\r\n\r\n      if (type === 'IEND') break;\r\n      \r\n    } catch (error) {\r\n      console.warn('PNG块解析警告:', error);\r\n      break;\r\n    }\r\n  }\r\n\r\n  return chunks;\r\n}\r\n\r\n/**\r\n * 安全的块类型读取\r\n */\r\nfunction readChunkType(view, offset) {\r\n  const bytes = [];\r\n  for (let i = 0; i < 4; i++) {\r\n    bytes.push(view.getUint8(offset + i));\r\n  }\r\n  return String.fromCharCode(...bytes);\r\n}\r\n\r\n/**\r\n * 从PNG块提取AI元数据 - 专门处理SD生成的图像\r\n */\r\nfunction extractAIMetadataFromChunks(chunks) {\r\n  const textChunks = chunks.filter(chunk => \r\n    ['tEXt', 'iTXt', 'zTXt'].includes(chunk.type)\r\n  );\r\n\r\n  const metadata = {\r\n    confidence: 'low',\r\n    generationTool: 'Unknown',\r\n    positive: '',\r\n    negative: '',\r\n    parameters: {}\r\n  };\r\n\r\n  for (const chunk of textChunks) {\r\n    const textData = parseTextChunk(chunk);\r\n    if (!textData.keyword || !textData.text) continue;\r\n\r\n    console.log('解析PNG文本块:', textData.keyword, '长度:', textData.text.length);\r\n\r\n    // 检测不同AI工具的数据格式\r\n    if (isAutomatic1111Format(textData)) {\r\n      Object.assign(metadata, parseAutomatic1111Data(textData.text));\r\n      metadata.generationTool = 'AUTOMATIC1111';\r\n      metadata.confidence = 'high';\r\n    } else if (isComfyUIFormat(textData)) {\r\n      Object.assign(metadata, parseComfyUIData(textData.text));\r\n      metadata.generationTool = 'ComfyUI';\r\n      metadata.confidence = 'high';\r\n    } else if (isNovelAIFormat(textData)) {\r\n      Object.assign(metadata, parseNovelAIData(textData.text));\r\n      metadata.generationTool = 'NovelAI';\r\n      metadata.confidence = 'high';\r\n    } else if (containsPromptLikeText(textData.text)) {\r\n      metadata.positive = textData.text;\r\n      metadata.confidence = 'medium';\r\n    }\r\n  }\r\n\r\n  return metadata;\r\n}\r\n\r\n/**\r\n * 高级文本块解析器 - 正确处理所有编码和特殊字符\r\n */\r\nfunction parseTextChunk(chunk) {\r\n  try {\r\n    const data = chunk.data;\r\n    \r\n    if (chunk.type === 'tEXt') {\r\n      return parseTEXt(data);\r\n    } else if (chunk.type === 'iTXt') {\r\n      return parseITXt(data);\r\n    } else if (chunk.type === 'zTXt') {\r\n      return parseZTXt(data);\r\n    }\r\n    \r\n    return {};\r\n  } catch (error) {\r\n    console.warn('文本块解析失败:', error);\r\n    return {};\r\n  }\r\n}\r\n\r\n/**\r\n * 解析tEXt块 - Latin-1编码，安全处理特殊字符\r\n */\r\nfunction parseTEXt(data) {\r\n  const nullIndex = data.indexOf(0);\r\n  if (nullIndex === -1) return {};\r\n\r\n  const keyword = decodeLatin1(data.slice(0, nullIndex));\r\n  const text = decodeLatin1(data.slice(nullIndex + 1));\r\n\r\n  return { keyword, text };\r\n}\r\n\r\n/**\r\n * 解析iTXt块 - UTF-8编码\r\n */\r\nfunction parseITXt(data) {\r\n  try {\r\n    const nullIndices = [];\r\n    for (let i = 0; i < data.length; i++) {\r\n      if (data[i] === 0) {\r\n        nullIndices.push(i);\r\n        if (nullIndices.length >= 4) break;\r\n      }\r\n    }\r\n\r\n    if (nullIndices.length < 4) return {};\r\n\r\n    const keyword = decodeUTF8(data.slice(0, nullIndices[0]));\r\n    const text = decodeUTF8(data.slice(nullIndices[3] + 1));\r\n\r\n    return { keyword, text };\r\n  } catch (error) {\r\n    console.warn('iTXt解析失败:', error);\r\n    return {};\r\n  }\r\n}\r\n\r\n/**\r\n * 解析zTXt块 - 压缩文本\r\n */\r\nfunction parseZTXt(data) {\r\n  try {\r\n    const nullIndex = data.indexOf(0);\r\n    if (nullIndex === -1) return {};\r\n\r\n    const keyword = decodeLatin1(data.slice(0, nullIndex));\r\n    const compression = data[nullIndex + 1];\r\n    \r\n    if (compression !== 0) {\r\n      return { keyword, text: '[压缩文本-暂不支持]' };\r\n    }\r\n\r\n    return { keyword, text: '[需要zlib解压缩]', compressed: true };\r\n  } catch (error) {\r\n    console.warn('zTXt解析失败:', error);\r\n    return {};\r\n  }\r\n}\r\n\r\n/**\r\n * 安全的Latin-1解码 - 逐字节处理，永不截断\r\n */\r\nfunction decodeLatin1(data) {\r\n  let result = '';\r\n  for (let i = 0; i < data.length; i++) {\r\n    result += String.fromCharCode(data[i]);\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * 安全的UTF-8解码\r\n */\r\nfunction decodeUTF8(data) {\r\n  try {\r\n    return new TextDecoder('utf-8', { fatal: false }).decode(data);\r\n  } catch (error) {\r\n    console.warn('UTF-8解码失败，使用Latin-1:', error);\r\n    return decodeLatin1(data);\r\n  }\r\n}\r\n\r\n/**\r\n * 检测AUTOMATIC1111格式\r\n */\r\nfunction isAutomatic1111Format(textData) {\r\n  if (textData.keyword !== 'parameters') return false;\r\n  const text = textData.text.toLowerCase();\r\n  return text.includes('steps:') || text.includes('cfg scale:') || \r\n         text.includes('sampler:') || text.includes('negative prompt:');\r\n}\r\n\r\n/**\r\n * 解析AUTOMATIC1111数据 - 增强版，不会截断提示词\r\n */\r\nfunction parseAutomatic1111Data(text) {\r\n  const result = {\r\n    positive: '',\r\n    negative: '',\r\n    parameters: {}\r\n  };\r\n\r\n  try {\r\n    // 查找负向提示词分隔符\r\n    const negativePromptIndex = text.indexOf('Negative prompt:');\r\n    \r\n    if (negativePromptIndex !== -1) {\r\n      // 提取正向提示词\r\n      result.positive = text.substring(0, negativePromptIndex).trim();\r\n      \r\n      // 提取剩余部分\r\n      const afterNegative = text.substring(negativePromptIndex + 16); // 'Negative prompt:' 长度\r\n      \r\n      // 查找参数部分的开始\r\n      const parameterLines = afterNegative.split('\\n');\r\n      let negativePrompt = '';\r\n      let parametersStartIndex = -1;\r\n      \r\n      for (let i = 0; i < parameterLines.length; i++) {\r\n        const line = parameterLines[i].trim();\r\n        if (looksLikeParameterLine(line)) {\r\n          parametersStartIndex = i;\r\n          break;\r\n        } else if (line) {\r\n          negativePrompt += (negativePrompt ? '\\n' : '') + line;\r\n        }\r\n      }\r\n      \r\n      result.negative = negativePrompt.trim();\r\n      \r\n      // 解析参数\r\n      if (parametersStartIndex !== -1) {\r\n        const paramText = parameterLines.slice(parametersStartIndex).join(', ');\r\n        result.parameters = parseParameterString(paramText);\r\n      }\r\n    } else {\r\n      // 没有负向提示词，查找参数分隔\r\n      const lines = text.split('\\n');\r\n      let positiveLines = [];\r\n      let parameterLines = [];\r\n      let foundParameters = false;\r\n      \r\n      for (const line of lines) {\r\n        const trimmedLine = line.trim();\r\n        if (looksLikeParameterLine(trimmedLine)) {\r\n          foundParameters = true;\r\n          parameterLines.push(trimmedLine);\r\n        } else if (!foundParameters && trimmedLine) {\r\n          positiveLines.push(trimmedLine);\r\n        } else if (foundParameters) {\r\n          parameterLines.push(trimmedLine);\r\n        }\r\n      }\r\n      \r\n      result.positive = positiveLines.join(' ').trim();\r\n      \r\n      if (parameterLines.length > 0) {\r\n        result.parameters = parseParameterString(parameterLines.join(', '));\r\n      }\r\n    }\r\n\r\n  } catch (error) {\r\n    console.warn('AUTOMATIC1111解析警告:', error);\r\n    result.positive = text; // 备用方案\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * 检测ComfyUI格式\r\n */\r\nfunction isComfyUIFormat(textData) {\r\n  if (!['workflow', 'prompt'].includes(textData.keyword)) return false;\r\n  try {\r\n    const parsed = JSON.parse(textData.text);\r\n    return parsed && typeof parsed === 'object';\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 解析ComfyUI数据 - 完整提取，不截断\r\n */\r\nfunction parseComfyUIData(text) {\r\n  const result = {\r\n    positive: '',\r\n    negative: '',\r\n    parameters: {}\r\n  };\r\n\r\n  try {\r\n    const data = JSON.parse(text);\r\n    \r\n    if (Array.isArray(data?.nodes)) {\r\n      // 工作流格式\r\n      const prompts = extractPromptsFromComfyWorkflow(data);\r\n      result.positive = prompts.positive;\r\n      result.negative = prompts.negative;\r\n      result.parameters.workflow = data;\r\n    } else if (typeof data === 'object') {\r\n      // 提示格式\r\n      const prompts = extractPromptsFromComfyPrompt(data);\r\n      result.positive = prompts.positive;\r\n      result.negative = prompts.negative;\r\n      result.parameters.prompt = data;\r\n    }\r\n\r\n  } catch (error) {\r\n    console.warn('ComfyUI解析警告:', error);\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * 从ComfyUI工作流提取提示词 - 修复版，收集所有文本\r\n */\r\nfunction extractPromptsFromComfyWorkflow(workflow) {\r\n  const positivePrompts = [];\r\n  const negativePrompts = [];\r\n\r\n  for (const node of workflow.nodes || []) {\r\n    if (['CLIPTextEncode', 'CLIPTextEncodeSDXL', 'ConditioningCombine'].includes(node.type)) {\r\n      const text = node.widgets_values?.[0];\r\n      if (text && typeof text === 'string' && text.trim()) {\r\n        const cleanText = text.trim();\r\n        \r\n        // 根据节点标题或内容判断正负向\r\n        const isNegative = isNegativePrompt(cleanText) || \r\n                         node.title?.toLowerCase().includes('negative') ||\r\n                         node.title?.toLowerCase().includes('neg');\r\n        \r\n        if (isNegative) {\r\n          negativePrompts.push(cleanText);\r\n        } else {\r\n          positivePrompts.push(cleanText);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return {\r\n    positive: mergePrompts(positivePrompts),\r\n    negative: mergePrompts(negativePrompts)\r\n  };\r\n}\r\n\r\n/**\r\n * 从ComfyUI提示提取提示词\r\n */\r\nfunction extractPromptsFromComfyPrompt(prompt) {\r\n  const positivePrompts = [];\r\n  const negativePrompts = [];\r\n\r\n  for (const [nodeId, nodeData] of Object.entries(prompt)) {\r\n    if (['CLIPTextEncode', 'CLIPTextEncodeSDXL'].includes(nodeData.class_type)) {\r\n      const text = nodeData.inputs?.text;\r\n      if (text && typeof text === 'string' && text.trim()) {\r\n        const cleanText = text.trim();\r\n        \r\n        if (isNegativePrompt(cleanText)) {\r\n          negativePrompts.push(cleanText);\r\n        } else {\r\n          positivePrompts.push(cleanText);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return {\r\n    positive: mergePrompts(positivePrompts),\r\n    negative: mergePrompts(negativePrompts)\r\n  };\r\n}\r\n\r\n/**\r\n * 智能合并提示词 - 保持完整性\r\n */\r\nfunction mergePrompts(prompts) {\r\n  if (!prompts.length) return '';\r\n  if (prompts.length === 1) return prompts[0];\r\n\r\n  // 检查是否有明显更长更完整的提示词\r\n  const longest = prompts.reduce((max, current) => \r\n    current.length > max.length ? current : max);\r\n  \r\n  // 如果最长的比其他的长很多，选择它\r\n  const avgLength = prompts.reduce((sum, p) => sum + p.length, 0) / prompts.length;\r\n  if (longest.length > avgLength * 2) {\r\n    return longest;\r\n  }\r\n  \r\n  // 否则按长度排序，优先选择长的\r\n  const sorted = [...prompts].sort((a, b) => b.length - a.length);\r\n  return sorted[0];\r\n}\r\n\r\n/**\r\n * 检测NovelAI格式\r\n */\r\nfunction isNovelAIFormat(textData) {\r\n  if (!['Description', 'Comment'].includes(textData.keyword)) return false;\r\n  try {\r\n    const parsed = JSON.parse(textData.text);\r\n    return parsed.prompt !== undefined || parsed.uc !== undefined;\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 解析NovelAI数据\r\n */\r\nfunction parseNovelAIData(text) {\r\n  const result = {\r\n    positive: '',\r\n    negative: '',\r\n    parameters: {}\r\n  };\r\n\r\n  try {\r\n    const data = JSON.parse(text);\r\n    result.positive = data.prompt || '';\r\n    result.negative = data.uc || '';\r\n    \r\n    ['steps', 'scale', 'seed', 'sampler', 'width', 'height'].forEach(key => {\r\n      if (data[key] !== undefined) {\r\n        result.parameters[key] = data[key];\r\n      }\r\n    });\r\n\r\n  } catch (error) {\r\n    console.warn('NovelAI解析警告:', error);\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * 改进的负向提示词检测\r\n */\r\nfunction isNegativePrompt(text) {\r\n  if (!text || typeof text !== 'string') return false;\r\n  \r\n  const lowerText = text.toLowerCase();\r\n  \r\n  const strongNegative = [\r\n    'worst quality', 'bad anatomy', 'ugly', 'blurry', 'lowres',\r\n    'bad hands', 'text', 'error', 'cropped', 'out of frame',\r\n    'deformed', 'mutated', 'malformed', 'poorly drawn'\r\n  ];\r\n\r\n  return strongNegative.some(keyword => lowerText.includes(keyword));\r\n}\r\n\r\n/**\r\n * 检测提示词样式文本\r\n */\r\nfunction containsPromptLikeText(text) {\r\n  if (!text || typeof text !== 'string' || text.length < 10) return false;\r\n  \r\n  const keywords = [\r\n    'masterpiece', 'best quality', 'detailed', 'high resolution',\r\n    'realistic', 'anime', 'portrait', 'landscape'\r\n  ];\r\n\r\n  const lowerText = text.toLowerCase();\r\n  const hasKeywords = keywords.some(keyword => lowerText.includes(keyword));\r\n  const hasCommas = text.includes(',') && text.split(',').length > 2;\r\n  \r\n  return hasKeywords || hasCommas;\r\n}\r\n\r\n/**\r\n * 检测参数行\r\n */\r\nfunction looksLikeParameterLine(line) {\r\n  const parameterPattern = /\\b(Steps|Sampler|CFG scale|Seed|Size|Model|Clip skip|Denoising strength):/i;\r\n  return parameterPattern.test(line);\r\n}\r\n\r\n/**\r\n * 解析参数字符串\r\n */\r\nfunction parseParameterString(paramText) {\r\n  const parameters = {};\r\n  const paramPattern = /(\\w+(?:\\s+\\w+)*)\\s*:\\s*([^,]+?)(?=,\\s*\\w+\\s*:|$)/g;\r\n  let match;\r\n\r\n  while ((match = paramPattern.exec(paramText)) !== null) {\r\n    const key = match[1].trim();\r\n    const value = match[2].trim();\r\n    \r\n    const normalizedKey = normalizeParameterKey(key);\r\n    parameters[normalizedKey] = parseParameterValue(value);\r\n  }\r\n\r\n  return parameters;\r\n}\r\n\r\n/**\r\n * 标准化参数键名\r\n */\r\nfunction normalizeParameterKey(key) {\r\n  const keyMap = {\r\n    'steps': 'steps',\r\n    'sampler': 'sampler',\r\n    'cfg scale': 'cfgScale',\r\n    'seed': 'seed',\r\n    'size': 'size',\r\n    'model hash': 'modelHash',\r\n    'model': 'model',\r\n    'clip skip': 'clipSkip',\r\n    'denoising strength': 'denoisingStrength'\r\n  };\r\n  \r\n  return keyMap[key.toLowerCase()] || key.replace(/\\s+/g, '');\r\n}\r\n\r\n/**\r\n * 解析参数值\r\n */\r\nfunction parseParameterValue(value) {\r\n  const numValue = parseFloat(value);\r\n  if (!isNaN(numValue) && isFinite(numValue)) {\r\n    return Number.isInteger(numValue) ? parseInt(value) : numValue;\r\n  }\r\n  return value;\r\n}\r\n\r\n/**\r\n * EXIF数据提取\r\n */\r\nasync function extractFromEXIF(file) {\r\n  try {\r\n    const exifData = await exifr.parse(file, {\r\n      userComment: true,\r\n      imageDescription: true,\r\n      software: true\r\n    });\r\n\r\n    if (!exifData) return null;\r\n\r\n    const result = {\r\n      type: 'EXIF',\r\n      confidence: 'medium',\r\n      data: {\r\n        software: exifData.Software,\r\n        description: exifData.ImageDescription,\r\n        userComment: exifData.UserComment\r\n      }\r\n    };\r\n\r\n    if (exifData.UserComment) {\r\n      const aiData = parseUserComment(exifData.UserComment);\r\n      if (aiData.positive || aiData.negative) {\r\n        Object.assign(result.data, aiData);\r\n        result.confidence = 'high';\r\n      }\r\n    }\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.warn('EXIF提取失败:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * 解析UserComment\r\n */\r\nfunction parseUserComment(userComment) {\r\n  const result = { positive: '', negative: '', parameters: {} };\r\n\r\n  try {\r\n    if (userComment.startsWith('{')) {\r\n      const data = JSON.parse(userComment);\r\n      result.positive = data.prompt || data.positive || '';\r\n      result.negative = data.negativePrompt || data.negative || '';\r\n      result.parameters = data.parameters || {};\r\n    } else {\r\n      result.positive = userComment;\r\n    }\r\n  } catch {\r\n    result.positive = userComment;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * 标准化提取的数据\r\n */\r\nfunction standardizeExtractedData(extractedData) {\r\n  const standardized = {\r\n    generationTool: 'Unknown',\r\n    positive: '',\r\n    negative: '',\r\n    parameters: {}\r\n  };\r\n\r\n  const priorityOrder = ['PNG_Chunks', 'EXIF'];\r\n  \r\n  for (const source of priorityOrder) {\r\n    const data = extractedData[source];\r\n    if (!data) continue;\r\n\r\n    if (data.data.generationTool) {\r\n      standardized.generationTool = data.data.generationTool;\r\n    }\r\n\r\n    if (data.data.positive && !standardized.positive) {\r\n      standardized.positive = data.data.positive;\r\n    }\r\n\r\n    if (data.data.negative && !standardized.negative) {\r\n      standardized.negative = data.data.negative;\r\n    }\r\n\r\n    Object.assign(standardized.parameters, data.data.parameters || {});\r\n  }\r\n\r\n  return standardized;\r\n}\r\n\r\n// 创建单例对象，按照原项目标准\r\nexport const imageMetadataExtractor = {\r\n  extractMetadata\r\n};\r\n\r\n// 默认导出\r\nexport default imageMetadataExtractor; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}