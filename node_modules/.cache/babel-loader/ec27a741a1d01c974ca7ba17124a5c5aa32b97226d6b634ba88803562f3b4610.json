{"ast":null,"code":"import exifr from 'exifr';\nimport piexif from 'piexifjs';\nimport AdvancedPromptAnalyzer from './advancedPromptAnalyzer.js';\n\n/**\r\n * 专业级图像元数据提取器\r\n * 基于stable-diffusion-inspector、auto1111-pnginfo等开源项目的最佳实践\r\n * 专门针对AI图像生成工具的元数据提取优化\r\n */\nexport class ImageMetadataExtractor {\n  constructor() {\n    this.supportedFormats = ['jpg', 'jpeg', 'png', 'webp'];\n    this.promptAnalyzer = new AdvancedPromptAnalyzer();\n  }\n\n  /**\r\n   * 主提取方法 - 使用多重策略并行提取\r\n   * @param {File} file - 图像文件\r\n   * @returns {Promise<Object>} 完整的提取结果\r\n   */\n  async extractMetadata(file) {\n    console.log('🚀 开始专业级元数据提取...');\n    const startTime = Date.now();\n    const result = {\n      success: false,\n      filename: file.name,\n      timestamp: new Date().toISOString(),\n      basicInfo: {\n        size: file.size,\n        sizeFormatted: this.formatFileSize(file.size),\n        type: file.type,\n        lastModified: new Date(file.lastModified).toISOString()\n      },\n      extractedData: {},\n      standardizedData: null,\n      extractionMethods: [],\n      errors: []\n    };\n    try {\n      var _result$standardizedD;\n      // 并行运行多种提取方法\n      const extractionPromises = [this.extractFromEXIF(file), file.type === 'image/png' ? this.extractFromPNGChunks(file) : null, this.extractFromGenericMetadata(file)].filter(Boolean);\n      const extractionResults = await Promise.allSettled(extractionPromises);\n\n      // 整合所有成功的提取结果\n      extractionResults.forEach((promiseResult, index) => {\n        if (promiseResult.status === 'fulfilled' && promiseResult.value) {\n          const methodNames = ['EXIF', 'PNG_Chunks', 'Generic'];\n          const methodName = methodNames[index];\n          result.extractedData[methodName] = promiseResult.value;\n          result.extractionMethods.push({\n            method: methodName,\n            success: true,\n            confidence: promiseResult.value.confidence || 'medium'\n          });\n        } else if (promiseResult.status === 'rejected') {\n          result.errors.push(`${methodNames[index]}: ${promiseResult.reason}`);\n        }\n      });\n\n      // 标准化和合并数据\n      result.standardizedData = this.standardizeExtractedData(result.extractedData);\n      result.success = Object.keys(result.extractedData).length > 0;\n      console.log(`✅ 提取完成 (${Date.now() - startTime}ms):`, {\n        methods: result.extractionMethods.length,\n        dataQuality: ((_result$standardizedD = result.standardizedData) === null || _result$standardizedD === void 0 ? void 0 : _result$standardizedD.generationTool) || 'Unknown'\n      });\n      return result;\n    } catch (error) {\n      console.error('❌ 元数据提取失败:', error);\n      result.errors.push(`总体错误: ${error.message}`);\n      throw new Error(`元数据提取失败: ${error.message}`);\n    }\n  }\n\n  /**\r\n   * 专业级PNG文本块提取器 - 参考auto1111-pnginfo的实现\r\n   * @param {File} file - PNG文件\r\n   * @returns {Promise<Object>} PNG元数据\r\n   */\n  async extractFromPNGChunks(file) {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.onload = e => {\n        try {\n          const buffer = e.target.result;\n          const view = new DataView(buffer);\n\n          // PNG签名验证\n          const pngSignature = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A];\n          for (let i = 0; i < 8; i++) {\n            if (view.getUint8(i) !== pngSignature[i]) {\n              throw new Error('不是有效的PNG文件');\n            }\n          }\n          const chunks = this.parsePNGChunks(buffer);\n          const metadata = this.extractAIMetadataFromChunks(chunks);\n          resolve({\n            type: 'PNG_Chunks',\n            confidence: metadata.confidence || 'high',\n            data: metadata,\n            chunks: chunks.map(chunk => ({\n              type: chunk.type,\n              length: chunk.length\n            }))\n          });\n        } catch (error) {\n          reject(error);\n        }\n      };\n      reader.onerror = () => reject(new Error('文件读取失败'));\n      reader.readAsArrayBuffer(file);\n    });\n  }\n\n  /**\r\n   * 高级PNG块解析器 - 修复特殊字符处理问题\r\n   * @param {ArrayBuffer} buffer - PNG文件缓冲区\r\n   * @returns {Array} 解析后的块列表\r\n   */\n  parsePNGChunks(buffer) {\n    const view = new DataView(buffer);\n    const chunks = [];\n    let offset = 8; // 跳过PNG签名\n\n    while (offset < buffer.byteLength - 8) {\n      try {\n        // 读取块长度 (big-endian)\n        const length = view.getUint32(offset);\n        offset += 4;\n\n        // 读取块类型\n        const type = this.readChunkType(view, offset);\n        offset += 4;\n\n        // 读取块数据\n        const data = new Uint8Array(buffer, offset, length);\n        offset += length;\n\n        // 读取CRC\n        const crc = view.getUint32(offset);\n        offset += 4;\n        chunks.push({\n          type,\n          length,\n          data,\n          crc\n        });\n\n        // 如果遇到IEND块，停止解析\n        if (type === 'IEND') break;\n      } catch (error) {\n        console.warn('PNG块解析警告:', error);\n        break;\n      }\n    }\n    return chunks;\n  }\n\n  /**\r\n   * 安全的块类型读取\r\n   * @param {DataView} view - 数据视图\r\n   * @param {number} offset - 偏移量\r\n   * @returns {string} 块类型\r\n   */\n  readChunkType(view, offset) {\n    const bytes = [];\n    for (let i = 0; i < 4; i++) {\n      bytes.push(view.getUint8(offset + i));\n    }\n    return String.fromCharCode(...bytes);\n  }\n\n  /**\r\n   * 从PNG块中提取AI元数据 - 专门处理SD生成的图像\r\n   * @param {Array} chunks - PNG块列表\r\n   * @returns {Object} 提取的元数据\r\n   */\n  extractAIMetadataFromChunks(chunks) {\n    const textChunks = chunks.filter(chunk => ['tEXt', 'iTXt', 'zTXt'].includes(chunk.type));\n    const metadata = {\n      confidence: 'low',\n      generationTool: 'Unknown',\n      positive: '',\n      negative: '',\n      parameters: {}\n    };\n    for (const chunk of textChunks) {\n      const textData = this.parseTextChunk(chunk);\n      if (!textData.keyword || !textData.text) continue;\n\n      // 检测不同AI工具的数据格式\n      if (this.isAutomatic1111Format(textData)) {\n        Object.assign(metadata, this.parseAutomatic1111Data(textData.text));\n        metadata.generationTool = 'AUTOMATIC1111';\n        metadata.confidence = 'high';\n      } else if (this.isComfyUIFormat(textData)) {\n        Object.assign(metadata, this.parseComfyUIData(textData.text));\n        metadata.generationTool = 'ComfyUI';\n        metadata.confidence = 'high';\n      } else if (this.isNovelAIFormat(textData)) {\n        Object.assign(metadata, this.parseNovelAIData(textData.text));\n        metadata.generationTool = 'NovelAI';\n        metadata.confidence = 'high';\n      } else if (this.containsPromptLikeText(textData.text)) {\n        // 通用提示词检测\n        metadata.positive = textData.text;\n        metadata.confidence = 'medium';\n      }\n    }\n    return metadata;\n  }\n\n  /**\r\n   * 高级文本块解析器 - 正确处理所有编码和特殊字符\r\n   * @param {Object} chunk - PNG文本块\r\n   * @returns {Object} 解析后的文本数据\r\n   */\n  parseTextChunk(chunk) {\n    try {\n      const data = chunk.data;\n      if (chunk.type === 'tEXt') {\n        return this.parseTEXt(data);\n      } else if (chunk.type === 'iTXt') {\n        return this.parseITXt(data);\n      } else if (chunk.type === 'zTXt') {\n        return this.parseZTXt(data);\n      }\n      return {};\n    } catch (error) {\n      console.warn('文本块解析失败:', error);\n      return {};\n    }\n  }\n\n  /**\r\n   * 解析tEXt块 - Latin-1编码\r\n   * @param {Uint8Array} data - 块数据\r\n   * @returns {Object} 解析结果\r\n   */\n  parseTEXt(data) {\n    // 查找null分隔符\n    const nullIndex = data.indexOf(0);\n    if (nullIndex === -1) return {};\n    const keyword = this.decodeLatin1(data.slice(0, nullIndex));\n    const text = this.decodeLatin1(data.slice(nullIndex + 1));\n    return {\n      keyword,\n      text\n    };\n  }\n\n  /**\r\n   * 解析iTXt块 - UTF-8编码\r\n   * @param {Uint8Array} data - 块数据\r\n   * @returns {Object} 解析结果\r\n   */\n  parseITXt(data) {\n    try {\n      const nullIndices = [];\n      for (let i = 0; i < data.length; i++) {\n        if (data[i] === 0) {\n          nullIndices.push(i);\n          if (nullIndices.length >= 4) break;\n        }\n      }\n      if (nullIndices.length < 4) return {};\n      const keyword = this.decodeUTF8(data.slice(0, nullIndices[0]));\n      const compression = data[nullIndices[0] + 1];\n      const text = this.decodeUTF8(data.slice(nullIndices[3] + 1));\n      return {\n        keyword,\n        text,\n        compression\n      };\n    } catch (error) {\n      console.warn('iTXt解析失败:', error);\n      return {};\n    }\n  }\n\n  /**\r\n   * 解析zTXt块 - 压缩文本\r\n   * @param {Uint8Array} data - 块数据\r\n   * @returns {Object} 解析结果\r\n   */\n  parseZTXt(data) {\n    try {\n      const nullIndex = data.indexOf(0);\n      if (nullIndex === -1) return {};\n      const keyword = this.decodeLatin1(data.slice(0, nullIndex));\n      const compression = data[nullIndex + 1];\n      if (compression !== 0) {\n        console.warn('不支持的压缩方法:', compression);\n        return {\n          keyword,\n          text: '[压缩文本]'\n        };\n      }\n\n      // 这里需要zlib解压缩，暂时返回原始数据\n      const compressedData = data.slice(nullIndex + 2);\n      return {\n        keyword,\n        text: '[需要解压缩]',\n        compressed: true\n      };\n    } catch (error) {\n      console.warn('zTXt解析失败:', error);\n      return {};\n    }\n  }\n\n  /**\r\n   * 安全的Latin-1解码\r\n   * @param {Uint8Array} data - 数据\r\n   * @returns {string} 解码后的字符串\r\n   */\n  decodeLatin1(data) {\n    try {\n      let result = '';\n      for (let i = 0; i < data.length; i++) {\n        result += String.fromCharCode(data[i]);\n      }\n      return result;\n    } catch (error) {\n      console.warn('Latin-1解码失败:', error);\n      return '';\n    }\n  }\n\n  /**\r\n   * 安全的UTF-8解码\r\n   * @param {Uint8Array} data - 数据\r\n   * @returns {string} 解码后的字符串\r\n   */\n  decodeUTF8(data) {\n    try {\n      return new TextDecoder('utf-8').decode(data);\n    } catch (error) {\n      console.warn('UTF-8解码失败，尝试Latin-1:', error);\n      return this.decodeLatin1(data);\n    }\n  }\n\n  /**\r\n   * 检测AUTOMATIC1111格式\r\n   * @param {Object} textData - 文本数据\r\n   * @returns {boolean} 是否为A1111格式\r\n   */\n  isAutomatic1111Format(textData) {\n    if (textData.keyword !== 'parameters') return false;\n    const text = textData.text.toLowerCase();\n    return text.includes('steps:') || text.includes('cfg scale:') || text.includes('sampler:') || text.includes('negative prompt:');\n  }\n\n  /**\r\n   * 解析AUTOMATIC1111数据 - 增强版，处理复杂格式\r\n   * @param {string} text - 参数文本\r\n   * @returns {Object} 解析结果\r\n   */\n  parseAutomatic1111Data(text) {\n    const result = {\n      positive: '',\n      negative: '',\n      parameters: {}\n    };\n    try {\n      // 使用更健壮的解析方法\n      const lines = text.split('\\n').map(line => line.trim()).filter(line => line);\n      let currentSection = 'positive';\n      let positiveLines = [];\n      let negativeLines = [];\n      let parameterLines = [];\n      for (const line of lines) {\n        if (line.startsWith('Negative prompt:')) {\n          currentSection = 'negative';\n          const negText = line.replace('Negative prompt:', '').trim();\n          if (negText) negativeLines.push(negText);\n        } else if (this.looksLikeParameterLine(line)) {\n          currentSection = 'parameters';\n          parameterLines.push(line);\n        } else {\n          if (currentSection === 'positive') {\n            positiveLines.push(line);\n          } else if (currentSection === 'negative') {\n            negativeLines.push(line);\n          }\n        }\n      }\n      result.positive = positiveLines.join(' ').trim();\n      result.negative = negativeLines.join(' ').trim();\n\n      // 解析参数\n      const paramText = parameterLines.join(', ');\n      result.parameters = this.parseParameterString(paramText);\n    } catch (error) {\n      console.warn('AUTOMATIC1111解析警告:', error);\n      result.positive = text; // 备用：将整个文本作为正向提示词\n    }\n    return result;\n  }\n\n  /**\r\n   * 检测ComfyUI格式\r\n   * @param {Object} textData - 文本数据\r\n   * @returns {boolean} 是否为ComfyUI格式\r\n   */\n  isComfyUIFormat(textData) {\n    if (!['workflow', 'prompt'].includes(textData.keyword)) return false;\n    try {\n      const parsed = JSON.parse(textData.text);\n      return parsed && typeof parsed === 'object';\n    } catch {\n      return false;\n    }\n  }\n\n  /**\r\n   * 解析ComfyUI数据 - 增强版，完整提取工作流信息\r\n   * @param {string} text - JSON文本\r\n   * @returns {Object} 解析结果\r\n   */\n  parseComfyUIData(text) {\n    const result = {\n      positive: '',\n      negative: '',\n      parameters: {}\n    };\n    try {\n      const data = JSON.parse(text);\n      if (Array.isArray(data === null || data === void 0 ? void 0 : data.nodes)) {\n        // 工作流格式\n        result.parameters.workflow = data;\n        const prompts = this.extractPromptsFromComfyWorkflow(data);\n        result.positive = prompts.positive;\n        result.negative = prompts.negative;\n      } else if (typeof data === 'object') {\n        // 提示格式\n        const prompts = this.extractPromptsFromComfyPrompt(data);\n        result.positive = prompts.positive;\n        result.negative = prompts.negative;\n        result.parameters.prompt = data;\n      }\n    } catch (error) {\n      console.warn('ComfyUI解析警告:', error);\n    }\n    return result;\n  }\n\n  /**\r\n   * 从ComfyUI工作流提取提示词 - 修复版\r\n   * @param {Object} workflow - 工作流对象\r\n   * @returns {Object} 提取的提示词\r\n   */\n  extractPromptsFromComfyWorkflow(workflow) {\n    const positivePrompts = [];\n    const negativePrompts = [];\n    for (const node of workflow.nodes || []) {\n      if (['CLIPTextEncode', 'CLIPTextEncodeSDXL'].includes(node.type)) {\n        var _node$widgets_values;\n        const text = (_node$widgets_values = node.widgets_values) === null || _node$widgets_values === void 0 ? void 0 : _node$widgets_values[0];\n        if (text && typeof text === 'string' && text.trim()) {\n          var _node$title;\n          const cleanText = text.trim();\n          if (this.isNegativePrompt(cleanText) || (_node$title = node.title) !== null && _node$title !== void 0 && _node$title.toLowerCase().includes('negative')) {\n            negativePrompts.push(cleanText);\n          } else {\n            positivePrompts.push(cleanText);\n          }\n        }\n      }\n    }\n    return {\n      positive: this.selectBestPrompt(positivePrompts),\n      negative: this.selectBestPrompt(negativePrompts)\n    };\n  }\n\n  /**\r\n   * 从ComfyUI提示提取提示词\r\n   * @param {Object} prompt - 提示对象\r\n   * @returns {Object} 提取的提示词\r\n   */\n  extractPromptsFromComfyPrompt(prompt) {\n    const positivePrompts = [];\n    const negativePrompts = [];\n    for (const [nodeId, nodeData] of Object.entries(prompt)) {\n      if (['CLIPTextEncode', 'CLIPTextEncodeSDXL'].includes(nodeData.class_type)) {\n        var _nodeData$inputs;\n        const text = (_nodeData$inputs = nodeData.inputs) === null || _nodeData$inputs === void 0 ? void 0 : _nodeData$inputs.text;\n        if (text && typeof text === 'string' && text.trim()) {\n          const cleanText = text.trim();\n          if (this.isNegativePrompt(cleanText)) {\n            negativePrompts.push(cleanText);\n          } else {\n            positivePrompts.push(cleanText);\n          }\n        }\n      }\n    }\n    return {\n      positive: this.selectBestPrompt(positivePrompts),\n      negative: this.selectBestPrompt(negativePrompts)\n    };\n  }\n\n  /**\r\n   * 智能选择最佳提示词\r\n   * @param {Array} prompts - 提示词列表\r\n   * @returns {string} 最佳提示词\r\n   */\n  selectBestPrompt(prompts) {\n    if (!prompts.length) return '';\n    if (prompts.length === 1) return prompts[0];\n\n    // 优先选择最长的提示词\n    const longest = prompts.reduce((longest, current) => current.length > longest.length ? current : longest, '');\n\n    // 如果最长的提示词显著比其他长，选择它\n    if (longest.length > 100) return longest;\n\n    // 否则合并所有提示词\n    return prompts.join(', ');\n  }\n\n  /**\r\n   * 检测NovelAI格式\r\n   * @param {Object} textData - 文本数据\r\n   * @returns {boolean} 是否为NovelAI格式\r\n   */\n  isNovelAIFormat(textData) {\n    if (!['Description', 'Comment'].includes(textData.keyword)) return false;\n    try {\n      const parsed = JSON.parse(textData.text);\n      return parsed.prompt !== undefined || parsed.uc !== undefined;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\r\n   * 解析NovelAI数据\r\n   * @param {string} text - JSON文本\r\n   * @returns {Object} 解析结果\r\n   */\n  parseNovelAIData(text) {\n    const result = {\n      positive: '',\n      negative: '',\n      parameters: {}\n    };\n    try {\n      const data = JSON.parse(text);\n      result.positive = data.prompt || '';\n      result.negative = data.uc || '';\n\n      // 提取参数\n      ['steps', 'scale', 'seed', 'sampler', 'width', 'height'].forEach(key => {\n        if (data[key] !== undefined) {\n          result.parameters[key] = data[key];\n        }\n      });\n    } catch (error) {\n      console.warn('NovelAI解析警告:', error);\n    }\n    return result;\n  }\n\n  /**\r\n   * 改进的负向提示词检测\r\n   * @param {string} text - 文本\r\n   * @returns {boolean} 是否为负向提示词\r\n   */\n  isNegativePrompt(text) {\n    if (!text || typeof text !== 'string') return false;\n    const lowerText = text.toLowerCase();\n\n    // 强负向关键词\n    const strongNegative = ['worst quality', 'bad anatomy', 'ugly', 'blurry', 'lowres', 'bad hands', 'text', 'error', 'cropped', 'out of frame', 'deformed', 'mutated', 'malformed', 'poorly drawn'];\n\n    // 检查是否包含强负向关键词\n    const hasStrongNegative = strongNegative.some(keyword => lowerText.includes(keyword));\n    if (hasStrongNegative) return true;\n\n    // 弱负向关键词\n    const weakNegative = ['bad', 'worst', 'low', 'poor', 'ugly', 'error', 'wrong'];\n    const negativeCount = weakNegative.filter(keyword => lowerText.includes(keyword)).length;\n    const totalWords = text.split(/\\s+/).length;\n    const negativeRatio = negativeCount / totalWords;\n\n    // 如果负向词汇比例超过60%，判定为负向提示词\n    return negativeRatio > 0.6;\n  }\n\n  /**\r\n   * 检测是否包含提示词样式的文本\r\n   * @param {string} text - 文本\r\n   * @returns {boolean} 是否像提示词\r\n   */\n  containsPromptLikeText(text) {\n    if (!text || typeof text !== 'string' || text.length < 10) return false;\n    const keywords = ['masterpiece', 'best quality', 'detailed', 'high resolution', 'realistic', 'anime', 'portrait', 'landscape', 'character'];\n    const lowerText = text.toLowerCase();\n    const hasKeywords = keywords.some(keyword => lowerText.includes(keyword));\n    const hasCommas = text.includes(',') && text.split(',').length > 2;\n    return hasKeywords || hasCommas;\n  }\n\n  /**\r\n   * 检测是否为参数行\r\n   * @param {string} line - 文本行\r\n   * @returns {boolean} 是否为参数行\r\n   */\n  looksLikeParameterLine(line) {\n    const parameterPattern = /\\b(Steps|Sampler|CFG scale|Seed|Size|Model|Clip skip|Denoising strength):/i;\n    return parameterPattern.test(line);\n  }\n\n  /**\r\n   * 解析参数字符串\r\n   * @param {string} paramText - 参数文本\r\n   * @returns {Object} 解析后的参数\r\n   */\n  parseParameterString(paramText) {\n    const parameters = {};\n\n    // 使用正则表达式匹配参数\n    const paramPattern = /(\\w+(?:\\s+\\w+)*)\\s*:\\s*([^,]+?)(?=,\\s*\\w+\\s*:|$)/g;\n    let match;\n    while ((match = paramPattern.exec(paramText)) !== null) {\n      const key = match[1].trim();\n      const value = match[2].trim();\n\n      // 标准化参数名\n      const normalizedKey = this.normalizeParameterKey(key);\n      parameters[normalizedKey] = this.parseParameterValue(value);\n    }\n    return parameters;\n  }\n\n  /**\r\n   * 标准化参数键名\r\n   * @param {string} key - 原始键名\r\n   * @returns {string} 标准化后的键名\r\n   */\n  normalizeParameterKey(key) {\n    const keyMap = {\n      'steps': 'steps',\n      'sampler': 'sampler',\n      'cfg scale': 'cfgScale',\n      'seed': 'seed',\n      'size': 'size',\n      'model hash': 'modelHash',\n      'model': 'model',\n      'clip skip': 'clipSkip',\n      'denoising strength': 'denoisingStrength'\n    };\n    return keyMap[key.toLowerCase()] || key.replace(/\\s+/g, '');\n  }\n\n  /**\r\n   * 解析参数值\r\n   * @param {string} value - 参数值\r\n   * @returns {any} 解析后的值\r\n   */\n  parseParameterValue(value) {\n    // 尝试解析为数字\n    const numValue = parseFloat(value);\n    if (!isNaN(numValue) && isFinite(numValue)) {\n      return Number.isInteger(numValue) ? parseInt(value) : numValue;\n    }\n    return value;\n  }\n\n  /**\r\n   * EXIF数据提取\r\n   * @param {File} file - 文件\r\n   * @returns {Promise<Object>} EXIF数据\r\n   */\n  async extractFromEXIF(file) {\n    try {\n      const exifData = await exifr.parse(file, {\n        userComment: true,\n        imageDescription: true,\n        software: true,\n        make: true,\n        model: true\n      });\n      if (!exifData) return null;\n      const result = {\n        type: 'EXIF',\n        confidence: 'medium',\n        data: {\n          software: exifData.Software,\n          make: exifData.Make,\n          model: exifData.Model,\n          description: exifData.ImageDescription,\n          userComment: exifData.UserComment\n        }\n      };\n\n      // 尝试从UserComment中提取AI数据\n      if (exifData.UserComment) {\n        const aiData = this.parseUserComment(exifData.UserComment);\n        if (aiData.positive || aiData.negative) {\n          Object.assign(result.data, aiData);\n          result.confidence = 'high';\n        }\n      }\n      return result;\n    } catch (error) {\n      console.warn('EXIF提取失败:', error);\n      return null;\n    }\n  }\n\n  /**\r\n   * 解析UserComment中的AI数据\r\n   * @param {string} userComment - 用户注释\r\n   * @returns {Object} 解析的AI数据\r\n   */\n  parseUserComment(userComment) {\n    const result = {\n      positive: '',\n      negative: '',\n      parameters: {}\n    };\n    try {\n      // 尝试JSON解析\n      if (userComment.startsWith('{')) {\n        const data = JSON.parse(userComment);\n        result.positive = data.prompt || data.positive || '';\n        result.negative = data.negativePrompt || data.negative || '';\n        result.parameters = data.parameters || {};\n      } else {\n        // 作为纯文本处理\n        result.positive = userComment;\n      }\n    } catch {\n      result.positive = userComment;\n    }\n    return result;\n  }\n\n  /**\r\n   * 通用元数据提取\r\n   * @param {File} file - 文件\r\n   * @returns {Promise<Object>} 通用元数据\r\n   */\n  async extractFromGenericMetadata(file) {\n    // 这里可以添加其他格式的支持\n    return null;\n  }\n\n  /**\r\n   * 标准化提取的数据\r\n   * @param {Object} extractedData - 提取的原始数据\r\n   * @returns {Object} 标准化后的数据\r\n   */\n  standardizeExtractedData(extractedData) {\n    const standardized = {\n      generationTool: 'Unknown',\n      positive: '',\n      negative: '',\n      parameters: {},\n      quality: null\n    };\n\n    // 优先级：PNG_Chunks > EXIF > Generic\n    const priorityOrder = ['PNG_Chunks', 'EXIF', 'Generic'];\n    for (const source of priorityOrder) {\n      const data = extractedData[source];\n      if (!data) continue;\n      if (data.data.generationTool) {\n        standardized.generationTool = data.data.generationTool;\n      }\n      if (data.data.positive && !standardized.positive) {\n        standardized.positive = data.data.positive;\n      }\n      if (data.data.negative && !standardized.negative) {\n        standardized.negative = data.data.negative;\n      }\n      Object.assign(standardized.parameters, data.data.parameters || {});\n    }\n\n    // 质量评估\n    standardized.quality = this.assessDataQuality(standardized);\n    return standardized;\n  }\n\n  /**\r\n   * 评估数据质量\r\n   * @param {Object} data - 标准化数据\r\n   * @returns {Object} 质量评估\r\n   */\n  assessDataQuality(data) {\n    let score = 0;\n    const factors = [];\n\n    // 提示词质量评分\n    if (data.positive) {\n      score += Math.min(data.positive.length / 100, 0.3);\n      factors.push('positive_prompt');\n    }\n    if (data.negative) {\n      score += 0.2;\n      factors.push('negative_prompt');\n    }\n\n    // 参数完整性评分\n    const importantParams = ['steps', 'cfgScale', 'sampler', 'seed'];\n    const paramScore = importantParams.filter(param => data.parameters[param] !== undefined).length / importantParams.length;\n    score += paramScore * 0.3;\n\n    // 工具识别加分\n    if (data.generationTool !== 'Unknown') {\n      score += 0.2;\n      factors.push('tool_detected');\n    }\n    return {\n      overallScore: Math.min(score, 1),\n      promptEffectiveness: data.positive ? Math.min(data.positive.length / 200, 1) : 0,\n      parameterOptimization: paramScore,\n      factors\n    };\n  }\n\n  /**\r\n   * 格式化文件大小\r\n   * @param {number} bytes - 字节数\r\n   * @returns {string} 格式化后的大小\r\n   */\n  formatFileSize(bytes) {\n    const units = ['B', 'KB', 'MB', 'GB'];\n    let size = bytes;\n    let unitIndex = 0;\n    while (size >= 1024 && unitIndex < units.length - 1) {\n      size /= 1024;\n      unitIndex++;\n    }\n    return `${size.toFixed(2)} ${units[unitIndex]}`;\n  }\n}\n\n// 导出单例实例\nexport const imageMetadataExtractor = new ImageMetadataExtractor();\nexport default ImageMetadataExtractor;","map":{"version":3,"names":["exifr","piexif","AdvancedPromptAnalyzer","ImageMetadataExtractor","constructor","supportedFormats","promptAnalyzer","extractMetadata","file","console","log","startTime","Date","now","result","success","filename","name","timestamp","toISOString","basicInfo","size","sizeFormatted","formatFileSize","type","lastModified","extractedData","standardizedData","extractionMethods","errors","_result$standardizedD","extractionPromises","extractFromEXIF","extractFromPNGChunks","extractFromGenericMetadata","filter","Boolean","extractionResults","Promise","allSettled","forEach","promiseResult","index","status","value","methodNames","methodName","push","method","confidence","reason","standardizeExtractedData","Object","keys","length","methods","dataQuality","generationTool","error","message","Error","resolve","reject","reader","FileReader","onload","e","buffer","target","view","DataView","pngSignature","i","getUint8","chunks","parsePNGChunks","metadata","extractAIMetadataFromChunks","data","map","chunk","onerror","readAsArrayBuffer","offset","byteLength","getUint32","readChunkType","Uint8Array","crc","warn","bytes","String","fromCharCode","textChunks","includes","positive","negative","parameters","textData","parseTextChunk","keyword","text","isAutomatic1111Format","assign","parseAutomatic1111Data","isComfyUIFormat","parseComfyUIData","isNovelAIFormat","parseNovelAIData","containsPromptLikeText","parseTEXt","parseITXt","parseZTXt","nullIndex","indexOf","decodeLatin1","slice","nullIndices","decodeUTF8","compression","compressedData","compressed","TextDecoder","decode","toLowerCase","lines","split","line","trim","currentSection","positiveLines","negativeLines","parameterLines","startsWith","negText","replace","looksLikeParameterLine","join","paramText","parseParameterString","parsed","JSON","parse","Array","isArray","nodes","workflow","prompts","extractPromptsFromComfyWorkflow","extractPromptsFromComfyPrompt","prompt","positivePrompts","negativePrompts","node","_node$widgets_values","widgets_values","_node$title","cleanText","isNegativePrompt","title","selectBestPrompt","nodeId","nodeData","entries","class_type","_nodeData$inputs","inputs","longest","reduce","current","undefined","uc","key","lowerText","strongNegative","hasStrongNegative","some","weakNegative","negativeCount","totalWords","negativeRatio","keywords","hasKeywords","hasCommas","parameterPattern","test","paramPattern","match","exec","normalizedKey","normalizeParameterKey","parseParameterValue","keyMap","numValue","parseFloat","isNaN","isFinite","Number","isInteger","parseInt","exifData","userComment","imageDescription","software","make","model","Software","Make","Model","description","ImageDescription","UserComment","aiData","parseUserComment","negativePrompt","standardized","quality","priorityOrder","source","assessDataQuality","score","factors","Math","min","importantParams","paramScore","param","overallScore","promptEffectiveness","parameterOptimization","units","unitIndex","toFixed","imageMetadataExtractor"],"sources":["C:/Users/wjx19/Documents/GitHub/I-Prompt/src/utils/imageMetadataExtractor.js"],"sourcesContent":["import exifr from 'exifr';\r\nimport piexif from 'piexifjs';\r\nimport AdvancedPromptAnalyzer from './advancedPromptAnalyzer.js';\r\n\r\n/**\r\n * 专业级图像元数据提取器\r\n * 基于stable-diffusion-inspector、auto1111-pnginfo等开源项目的最佳实践\r\n * 专门针对AI图像生成工具的元数据提取优化\r\n */\r\nexport class ImageMetadataExtractor {\r\n  constructor() {\r\n    this.supportedFormats = ['jpg', 'jpeg', 'png', 'webp'];\r\n    this.promptAnalyzer = new AdvancedPromptAnalyzer();\r\n  }\r\n\r\n  /**\r\n   * 主提取方法 - 使用多重策略并行提取\r\n   * @param {File} file - 图像文件\r\n   * @returns {Promise<Object>} 完整的提取结果\r\n   */\r\n  async extractMetadata(file) {\r\n    console.log('🚀 开始专业级元数据提取...');\r\n    \r\n    const startTime = Date.now();\r\n    const result = {\r\n      success: false,\r\n      filename: file.name,\r\n      timestamp: new Date().toISOString(),\r\n      basicInfo: {\r\n        size: file.size,\r\n        sizeFormatted: this.formatFileSize(file.size),\r\n        type: file.type,\r\n        lastModified: new Date(file.lastModified).toISOString()\r\n      },\r\n      extractedData: {},\r\n      standardizedData: null,\r\n      extractionMethods: [],\r\n      errors: []\r\n    };\r\n\r\n    try {\r\n      // 并行运行多种提取方法\r\n      const extractionPromises = [\r\n        this.extractFromEXIF(file),\r\n        file.type === 'image/png' ? this.extractFromPNGChunks(file) : null,\r\n        this.extractFromGenericMetadata(file)\r\n      ].filter(Boolean);\r\n\r\n      const extractionResults = await Promise.allSettled(extractionPromises);\r\n      \r\n      // 整合所有成功的提取结果\r\n      extractionResults.forEach((promiseResult, index) => {\r\n        if (promiseResult.status === 'fulfilled' && promiseResult.value) {\r\n          const methodNames = ['EXIF', 'PNG_Chunks', 'Generic'];\r\n          const methodName = methodNames[index];\r\n          result.extractedData[methodName] = promiseResult.value;\r\n          result.extractionMethods.push({\r\n            method: methodName,\r\n            success: true,\r\n            confidence: promiseResult.value.confidence || 'medium'\r\n          });\r\n        } else if (promiseResult.status === 'rejected') {\r\n          result.errors.push(`${methodNames[index]}: ${promiseResult.reason}`);\r\n        }\r\n      });\r\n\r\n      // 标准化和合并数据\r\n      result.standardizedData = this.standardizeExtractedData(result.extractedData);\r\n      result.success = Object.keys(result.extractedData).length > 0;\r\n      \r\n      console.log(`✅ 提取完成 (${Date.now() - startTime}ms):`, {\r\n        methods: result.extractionMethods.length,\r\n        dataQuality: result.standardizedData?.generationTool || 'Unknown'\r\n      });\r\n\r\n      return result;\r\n      \r\n    } catch (error) {\r\n      console.error('❌ 元数据提取失败:', error);\r\n      result.errors.push(`总体错误: ${error.message}`);\r\n      throw new Error(`元数据提取失败: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 专业级PNG文本块提取器 - 参考auto1111-pnginfo的实现\r\n   * @param {File} file - PNG文件\r\n   * @returns {Promise<Object>} PNG元数据\r\n   */\r\n  async extractFromPNGChunks(file) {\r\n    return new Promise((resolve, reject) => {\r\n      const reader = new FileReader();\r\n      \r\n      reader.onload = (e) => {\r\n        try {\r\n          const buffer = e.target.result;\r\n          const view = new DataView(buffer);\r\n          \r\n          // PNG签名验证\r\n          const pngSignature = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A];\r\n          for (let i = 0; i < 8; i++) {\r\n            if (view.getUint8(i) !== pngSignature[i]) {\r\n              throw new Error('不是有效的PNG文件');\r\n            }\r\n          }\r\n\r\n          const chunks = this.parsePNGChunks(buffer);\r\n          const metadata = this.extractAIMetadataFromChunks(chunks);\r\n          \r\n          resolve({\r\n            type: 'PNG_Chunks',\r\n            confidence: metadata.confidence || 'high',\r\n            data: metadata,\r\n            chunks: chunks.map(chunk => ({\r\n              type: chunk.type,\r\n              length: chunk.length\r\n            }))\r\n          });\r\n          \r\n        } catch (error) {\r\n          reject(error);\r\n        }\r\n      };\r\n      \r\n      reader.onerror = () => reject(new Error('文件读取失败'));\r\n      reader.readAsArrayBuffer(file);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * 高级PNG块解析器 - 修复特殊字符处理问题\r\n   * @param {ArrayBuffer} buffer - PNG文件缓冲区\r\n   * @returns {Array} 解析后的块列表\r\n   */\r\n  parsePNGChunks(buffer) {\r\n    const view = new DataView(buffer);\r\n    const chunks = [];\r\n    let offset = 8; // 跳过PNG签名\r\n\r\n    while (offset < buffer.byteLength - 8) {\r\n      try {\r\n        // 读取块长度 (big-endian)\r\n        const length = view.getUint32(offset);\r\n        offset += 4;\r\n\r\n        // 读取块类型\r\n        const type = this.readChunkType(view, offset);\r\n        offset += 4;\r\n\r\n        // 读取块数据\r\n        const data = new Uint8Array(buffer, offset, length);\r\n        offset += length;\r\n\r\n        // 读取CRC\r\n        const crc = view.getUint32(offset);\r\n        offset += 4;\r\n\r\n        chunks.push({ type, length, data, crc });\r\n\r\n        // 如果遇到IEND块，停止解析\r\n        if (type === 'IEND') break;\r\n        \r\n      } catch (error) {\r\n        console.warn('PNG块解析警告:', error);\r\n        break;\r\n      }\r\n    }\r\n\r\n    return chunks;\r\n  }\r\n\r\n  /**\r\n   * 安全的块类型读取\r\n   * @param {DataView} view - 数据视图\r\n   * @param {number} offset - 偏移量\r\n   * @returns {string} 块类型\r\n   */\r\n  readChunkType(view, offset) {\r\n    const bytes = [];\r\n    for (let i = 0; i < 4; i++) {\r\n      bytes.push(view.getUint8(offset + i));\r\n    }\r\n    return String.fromCharCode(...bytes);\r\n  }\r\n\r\n  /**\r\n   * 从PNG块中提取AI元数据 - 专门处理SD生成的图像\r\n   * @param {Array} chunks - PNG块列表\r\n   * @returns {Object} 提取的元数据\r\n   */\r\n  extractAIMetadataFromChunks(chunks) {\r\n    const textChunks = chunks.filter(chunk => \r\n      ['tEXt', 'iTXt', 'zTXt'].includes(chunk.type)\r\n    );\r\n\r\n    const metadata = {\r\n      confidence: 'low',\r\n      generationTool: 'Unknown',\r\n      positive: '',\r\n      negative: '',\r\n      parameters: {}\r\n    };\r\n\r\n    for (const chunk of textChunks) {\r\n      const textData = this.parseTextChunk(chunk);\r\n      if (!textData.keyword || !textData.text) continue;\r\n\r\n      // 检测不同AI工具的数据格式\r\n      if (this.isAutomatic1111Format(textData)) {\r\n        Object.assign(metadata, this.parseAutomatic1111Data(textData.text));\r\n        metadata.generationTool = 'AUTOMATIC1111';\r\n        metadata.confidence = 'high';\r\n      } else if (this.isComfyUIFormat(textData)) {\r\n        Object.assign(metadata, this.parseComfyUIData(textData.text));\r\n        metadata.generationTool = 'ComfyUI';\r\n        metadata.confidence = 'high';\r\n      } else if (this.isNovelAIFormat(textData)) {\r\n        Object.assign(metadata, this.parseNovelAIData(textData.text));\r\n        metadata.generationTool = 'NovelAI';\r\n        metadata.confidence = 'high';\r\n      } else if (this.containsPromptLikeText(textData.text)) {\r\n        // 通用提示词检测\r\n        metadata.positive = textData.text;\r\n        metadata.confidence = 'medium';\r\n      }\r\n    }\r\n\r\n    return metadata;\r\n  }\r\n\r\n  /**\r\n   * 高级文本块解析器 - 正确处理所有编码和特殊字符\r\n   * @param {Object} chunk - PNG文本块\r\n   * @returns {Object} 解析后的文本数据\r\n   */\r\n  parseTextChunk(chunk) {\r\n    try {\r\n      const data = chunk.data;\r\n      \r\n      if (chunk.type === 'tEXt') {\r\n        return this.parseTEXt(data);\r\n      } else if (chunk.type === 'iTXt') {\r\n        return this.parseITXt(data);\r\n      } else if (chunk.type === 'zTXt') {\r\n        return this.parseZTXt(data);\r\n      }\r\n      \r\n      return {};\r\n    } catch (error) {\r\n      console.warn('文本块解析失败:', error);\r\n      return {};\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 解析tEXt块 - Latin-1编码\r\n   * @param {Uint8Array} data - 块数据\r\n   * @returns {Object} 解析结果\r\n   */\r\n  parseTEXt(data) {\r\n    // 查找null分隔符\r\n    const nullIndex = data.indexOf(0);\r\n    if (nullIndex === -1) return {};\r\n\r\n    const keyword = this.decodeLatin1(data.slice(0, nullIndex));\r\n    const text = this.decodeLatin1(data.slice(nullIndex + 1));\r\n\r\n    return { keyword, text };\r\n  }\r\n\r\n  /**\r\n   * 解析iTXt块 - UTF-8编码\r\n   * @param {Uint8Array} data - 块数据\r\n   * @returns {Object} 解析结果\r\n   */\r\n  parseITXt(data) {\r\n    try {\r\n      const nullIndices = [];\r\n      for (let i = 0; i < data.length; i++) {\r\n        if (data[i] === 0) {\r\n          nullIndices.push(i);\r\n          if (nullIndices.length >= 4) break;\r\n        }\r\n      }\r\n\r\n      if (nullIndices.length < 4) return {};\r\n\r\n      const keyword = this.decodeUTF8(data.slice(0, nullIndices[0]));\r\n      const compression = data[nullIndices[0] + 1];\r\n      const text = this.decodeUTF8(data.slice(nullIndices[3] + 1));\r\n\r\n      return { keyword, text, compression };\r\n    } catch (error) {\r\n      console.warn('iTXt解析失败:', error);\r\n      return {};\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 解析zTXt块 - 压缩文本\r\n   * @param {Uint8Array} data - 块数据\r\n   * @returns {Object} 解析结果\r\n   */\r\n  parseZTXt(data) {\r\n    try {\r\n      const nullIndex = data.indexOf(0);\r\n      if (nullIndex === -1) return {};\r\n\r\n      const keyword = this.decodeLatin1(data.slice(0, nullIndex));\r\n      const compression = data[nullIndex + 1];\r\n      \r\n      if (compression !== 0) {\r\n        console.warn('不支持的压缩方法:', compression);\r\n        return { keyword, text: '[压缩文本]' };\r\n      }\r\n\r\n      // 这里需要zlib解压缩，暂时返回原始数据\r\n      const compressedData = data.slice(nullIndex + 2);\r\n      return { keyword, text: '[需要解压缩]', compressed: true };\r\n    } catch (error) {\r\n      console.warn('zTXt解析失败:', error);\r\n      return {};\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 安全的Latin-1解码\r\n   * @param {Uint8Array} data - 数据\r\n   * @returns {string} 解码后的字符串\r\n   */\r\n  decodeLatin1(data) {\r\n    try {\r\n      let result = '';\r\n      for (let i = 0; i < data.length; i++) {\r\n        result += String.fromCharCode(data[i]);\r\n      }\r\n      return result;\r\n    } catch (error) {\r\n      console.warn('Latin-1解码失败:', error);\r\n      return '';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 安全的UTF-8解码\r\n   * @param {Uint8Array} data - 数据\r\n   * @returns {string} 解码后的字符串\r\n   */\r\n  decodeUTF8(data) {\r\n    try {\r\n      return new TextDecoder('utf-8').decode(data);\r\n    } catch (error) {\r\n      console.warn('UTF-8解码失败，尝试Latin-1:', error);\r\n      return this.decodeLatin1(data);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 检测AUTOMATIC1111格式\r\n   * @param {Object} textData - 文本数据\r\n   * @returns {boolean} 是否为A1111格式\r\n   */\r\n  isAutomatic1111Format(textData) {\r\n    if (textData.keyword !== 'parameters') return false;\r\n    const text = textData.text.toLowerCase();\r\n    return text.includes('steps:') || text.includes('cfg scale:') || \r\n           text.includes('sampler:') || text.includes('negative prompt:');\r\n  }\r\n\r\n  /**\r\n   * 解析AUTOMATIC1111数据 - 增强版，处理复杂格式\r\n   * @param {string} text - 参数文本\r\n   * @returns {Object} 解析结果\r\n   */\r\n  parseAutomatic1111Data(text) {\r\n    const result = {\r\n      positive: '',\r\n      negative: '',\r\n      parameters: {}\r\n    };\r\n\r\n    try {\r\n      // 使用更健壮的解析方法\r\n      const lines = text.split('\\n').map(line => line.trim()).filter(line => line);\r\n      \r\n      let currentSection = 'positive';\r\n      let positiveLines = [];\r\n      let negativeLines = [];\r\n      let parameterLines = [];\r\n\r\n      for (const line of lines) {\r\n        if (line.startsWith('Negative prompt:')) {\r\n          currentSection = 'negative';\r\n          const negText = line.replace('Negative prompt:', '').trim();\r\n          if (negText) negativeLines.push(negText);\r\n        } else if (this.looksLikeParameterLine(line)) {\r\n          currentSection = 'parameters';\r\n          parameterLines.push(line);\r\n        } else {\r\n          if (currentSection === 'positive') {\r\n            positiveLines.push(line);\r\n          } else if (currentSection === 'negative') {\r\n            negativeLines.push(line);\r\n          }\r\n        }\r\n      }\r\n\r\n      result.positive = positiveLines.join(' ').trim();\r\n      result.negative = negativeLines.join(' ').trim();\r\n      \r\n      // 解析参数\r\n      const paramText = parameterLines.join(', ');\r\n      result.parameters = this.parseParameterString(paramText);\r\n\r\n    } catch (error) {\r\n      console.warn('AUTOMATIC1111解析警告:', error);\r\n      result.positive = text; // 备用：将整个文本作为正向提示词\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * 检测ComfyUI格式\r\n   * @param {Object} textData - 文本数据\r\n   * @returns {boolean} 是否为ComfyUI格式\r\n   */\r\n  isComfyUIFormat(textData) {\r\n    if (!['workflow', 'prompt'].includes(textData.keyword)) return false;\r\n    try {\r\n      const parsed = JSON.parse(textData.text);\r\n      return parsed && typeof parsed === 'object';\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 解析ComfyUI数据 - 增强版，完整提取工作流信息\r\n   * @param {string} text - JSON文本\r\n   * @returns {Object} 解析结果\r\n   */\r\n  parseComfyUIData(text) {\r\n    const result = {\r\n      positive: '',\r\n      negative: '',\r\n      parameters: {}\r\n    };\r\n\r\n    try {\r\n      const data = JSON.parse(text);\r\n      \r\n      if (Array.isArray(data?.nodes)) {\r\n        // 工作流格式\r\n        result.parameters.workflow = data;\r\n        const prompts = this.extractPromptsFromComfyWorkflow(data);\r\n        result.positive = prompts.positive;\r\n        result.negative = prompts.negative;\r\n      } else if (typeof data === 'object') {\r\n        // 提示格式\r\n        const prompts = this.extractPromptsFromComfyPrompt(data);\r\n        result.positive = prompts.positive;\r\n        result.negative = prompts.negative;\r\n        result.parameters.prompt = data;\r\n      }\r\n\r\n    } catch (error) {\r\n      console.warn('ComfyUI解析警告:', error);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * 从ComfyUI工作流提取提示词 - 修复版\r\n   * @param {Object} workflow - 工作流对象\r\n   * @returns {Object} 提取的提示词\r\n   */\r\n  extractPromptsFromComfyWorkflow(workflow) {\r\n    const positivePrompts = [];\r\n    const negativePrompts = [];\r\n\r\n    for (const node of workflow.nodes || []) {\r\n      if (['CLIPTextEncode', 'CLIPTextEncodeSDXL'].includes(node.type)) {\r\n        const text = node.widgets_values?.[0];\r\n        if (text && typeof text === 'string' && text.trim()) {\r\n          const cleanText = text.trim();\r\n          if (this.isNegativePrompt(cleanText) || \r\n              node.title?.toLowerCase().includes('negative')) {\r\n            negativePrompts.push(cleanText);\r\n          } else {\r\n            positivePrompts.push(cleanText);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      positive: this.selectBestPrompt(positivePrompts),\r\n      negative: this.selectBestPrompt(negativePrompts)\r\n    };\r\n  }\r\n\r\n  /**\r\n   * 从ComfyUI提示提取提示词\r\n   * @param {Object} prompt - 提示对象\r\n   * @returns {Object} 提取的提示词\r\n   */\r\n  extractPromptsFromComfyPrompt(prompt) {\r\n    const positivePrompts = [];\r\n    const negativePrompts = [];\r\n\r\n    for (const [nodeId, nodeData] of Object.entries(prompt)) {\r\n      if (['CLIPTextEncode', 'CLIPTextEncodeSDXL'].includes(nodeData.class_type)) {\r\n        const text = nodeData.inputs?.text;\r\n        if (text && typeof text === 'string' && text.trim()) {\r\n          const cleanText = text.trim();\r\n          if (this.isNegativePrompt(cleanText)) {\r\n            negativePrompts.push(cleanText);\r\n          } else {\r\n            positivePrompts.push(cleanText);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      positive: this.selectBestPrompt(positivePrompts),\r\n      negative: this.selectBestPrompt(negativePrompts)\r\n    };\r\n  }\r\n\r\n  /**\r\n   * 智能选择最佳提示词\r\n   * @param {Array} prompts - 提示词列表\r\n   * @returns {string} 最佳提示词\r\n   */\r\n  selectBestPrompt(prompts) {\r\n    if (!prompts.length) return '';\r\n    if (prompts.length === 1) return prompts[0];\r\n\r\n    // 优先选择最长的提示词\r\n    const longest = prompts.reduce((longest, current) => \r\n      current.length > longest.length ? current : longest, '');\r\n    \r\n    // 如果最长的提示词显著比其他长，选择它\r\n    if (longest.length > 100) return longest;\r\n    \r\n    // 否则合并所有提示词\r\n    return prompts.join(', ');\r\n  }\r\n\r\n  /**\r\n   * 检测NovelAI格式\r\n   * @param {Object} textData - 文本数据\r\n   * @returns {boolean} 是否为NovelAI格式\r\n   */\r\n  isNovelAIFormat(textData) {\r\n    if (!['Description', 'Comment'].includes(textData.keyword)) return false;\r\n    try {\r\n      const parsed = JSON.parse(textData.text);\r\n      return parsed.prompt !== undefined || parsed.uc !== undefined;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 解析NovelAI数据\r\n   * @param {string} text - JSON文本\r\n   * @returns {Object} 解析结果\r\n   */\r\n  parseNovelAIData(text) {\r\n    const result = {\r\n      positive: '',\r\n      negative: '',\r\n      parameters: {}\r\n    };\r\n\r\n    try {\r\n      const data = JSON.parse(text);\r\n      result.positive = data.prompt || '';\r\n      result.negative = data.uc || '';\r\n      \r\n      // 提取参数\r\n      ['steps', 'scale', 'seed', 'sampler', 'width', 'height'].forEach(key => {\r\n        if (data[key] !== undefined) {\r\n          result.parameters[key] = data[key];\r\n        }\r\n      });\r\n\r\n    } catch (error) {\r\n      console.warn('NovelAI解析警告:', error);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * 改进的负向提示词检测\r\n   * @param {string} text - 文本\r\n   * @returns {boolean} 是否为负向提示词\r\n   */\r\n  isNegativePrompt(text) {\r\n    if (!text || typeof text !== 'string') return false;\r\n    \r\n    const lowerText = text.toLowerCase();\r\n    \r\n    // 强负向关键词\r\n    const strongNegative = [\r\n      'worst quality', 'bad anatomy', 'ugly', 'blurry', 'lowres',\r\n      'bad hands', 'text', 'error', 'cropped', 'out of frame',\r\n      'deformed', 'mutated', 'malformed', 'poorly drawn'\r\n    ];\r\n\r\n    // 检查是否包含强负向关键词\r\n    const hasStrongNegative = strongNegative.some(keyword => \r\n      lowerText.includes(keyword));\r\n\r\n    if (hasStrongNegative) return true;\r\n\r\n    // 弱负向关键词\r\n    const weakNegative = [\r\n      'bad', 'worst', 'low', 'poor', 'ugly', 'error', 'wrong'\r\n    ];\r\n\r\n    const negativeCount = weakNegative.filter(keyword => \r\n      lowerText.includes(keyword)).length;\r\n    \r\n    const totalWords = text.split(/\\s+/).length;\r\n    const negativeRatio = negativeCount / totalWords;\r\n\r\n    // 如果负向词汇比例超过60%，判定为负向提示词\r\n    return negativeRatio > 0.6;\r\n  }\r\n\r\n  /**\r\n   * 检测是否包含提示词样式的文本\r\n   * @param {string} text - 文本\r\n   * @returns {boolean} 是否像提示词\r\n   */\r\n  containsPromptLikeText(text) {\r\n    if (!text || typeof text !== 'string' || text.length < 10) return false;\r\n    \r\n    const keywords = [\r\n      'masterpiece', 'best quality', 'detailed', 'high resolution',\r\n      'realistic', 'anime', 'portrait', 'landscape', 'character'\r\n    ];\r\n\r\n    const lowerText = text.toLowerCase();\r\n    const hasKeywords = keywords.some(keyword => lowerText.includes(keyword));\r\n    const hasCommas = text.includes(',') && text.split(',').length > 2;\r\n    \r\n    return hasKeywords || hasCommas;\r\n  }\r\n\r\n  /**\r\n   * 检测是否为参数行\r\n   * @param {string} line - 文本行\r\n   * @returns {boolean} 是否为参数行\r\n   */\r\n  looksLikeParameterLine(line) {\r\n    const parameterPattern = /\\b(Steps|Sampler|CFG scale|Seed|Size|Model|Clip skip|Denoising strength):/i;\r\n    return parameterPattern.test(line);\r\n  }\r\n\r\n  /**\r\n   * 解析参数字符串\r\n   * @param {string} paramText - 参数文本\r\n   * @returns {Object} 解析后的参数\r\n   */\r\n  parseParameterString(paramText) {\r\n    const parameters = {};\r\n    \r\n    // 使用正则表达式匹配参数\r\n    const paramPattern = /(\\w+(?:\\s+\\w+)*)\\s*:\\s*([^,]+?)(?=,\\s*\\w+\\s*:|$)/g;\r\n    let match;\r\n\r\n    while ((match = paramPattern.exec(paramText)) !== null) {\r\n      const key = match[1].trim();\r\n      const value = match[2].trim();\r\n      \r\n      // 标准化参数名\r\n      const normalizedKey = this.normalizeParameterKey(key);\r\n      parameters[normalizedKey] = this.parseParameterValue(value);\r\n    }\r\n\r\n    return parameters;\r\n  }\r\n\r\n  /**\r\n   * 标准化参数键名\r\n   * @param {string} key - 原始键名\r\n   * @returns {string} 标准化后的键名\r\n   */\r\n  normalizeParameterKey(key) {\r\n    const keyMap = {\r\n      'steps': 'steps',\r\n      'sampler': 'sampler',\r\n      'cfg scale': 'cfgScale',\r\n      'seed': 'seed',\r\n      'size': 'size',\r\n      'model hash': 'modelHash',\r\n      'model': 'model',\r\n      'clip skip': 'clipSkip',\r\n      'denoising strength': 'denoisingStrength'\r\n    };\r\n    \r\n    return keyMap[key.toLowerCase()] || key.replace(/\\s+/g, '');\r\n  }\r\n\r\n  /**\r\n   * 解析参数值\r\n   * @param {string} value - 参数值\r\n   * @returns {any} 解析后的值\r\n   */\r\n  parseParameterValue(value) {\r\n    // 尝试解析为数字\r\n    const numValue = parseFloat(value);\r\n    if (!isNaN(numValue) && isFinite(numValue)) {\r\n      return Number.isInteger(numValue) ? parseInt(value) : numValue;\r\n    }\r\n    \r\n    return value;\r\n  }\r\n\r\n  /**\r\n   * EXIF数据提取\r\n   * @param {File} file - 文件\r\n   * @returns {Promise<Object>} EXIF数据\r\n   */\r\n  async extractFromEXIF(file) {\r\n    try {\r\n      const exifData = await exifr.parse(file, {\r\n        userComment: true,\r\n        imageDescription: true,\r\n        software: true,\r\n        make: true,\r\n        model: true\r\n      });\r\n\r\n      if (!exifData) return null;\r\n\r\n      const result = {\r\n        type: 'EXIF',\r\n        confidence: 'medium',\r\n        data: {\r\n          software: exifData.Software,\r\n          make: exifData.Make,\r\n          model: exifData.Model,\r\n          description: exifData.ImageDescription,\r\n          userComment: exifData.UserComment\r\n        }\r\n      };\r\n\r\n      // 尝试从UserComment中提取AI数据\r\n      if (exifData.UserComment) {\r\n        const aiData = this.parseUserComment(exifData.UserComment);\r\n        if (aiData.positive || aiData.negative) {\r\n          Object.assign(result.data, aiData);\r\n          result.confidence = 'high';\r\n        }\r\n      }\r\n\r\n      return result;\r\n    } catch (error) {\r\n      console.warn('EXIF提取失败:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 解析UserComment中的AI数据\r\n   * @param {string} userComment - 用户注释\r\n   * @returns {Object} 解析的AI数据\r\n   */\r\n  parseUserComment(userComment) {\r\n    const result = { positive: '', negative: '', parameters: {} };\r\n\r\n    try {\r\n      // 尝试JSON解析\r\n      if (userComment.startsWith('{')) {\r\n        const data = JSON.parse(userComment);\r\n        result.positive = data.prompt || data.positive || '';\r\n        result.negative = data.negativePrompt || data.negative || '';\r\n        result.parameters = data.parameters || {};\r\n      } else {\r\n        // 作为纯文本处理\r\n        result.positive = userComment;\r\n      }\r\n    } catch {\r\n      result.positive = userComment;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * 通用元数据提取\r\n   * @param {File} file - 文件\r\n   * @returns {Promise<Object>} 通用元数据\r\n   */\r\n  async extractFromGenericMetadata(file) {\r\n    // 这里可以添加其他格式的支持\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * 标准化提取的数据\r\n   * @param {Object} extractedData - 提取的原始数据\r\n   * @returns {Object} 标准化后的数据\r\n   */\r\n  standardizeExtractedData(extractedData) {\r\n    const standardized = {\r\n      generationTool: 'Unknown',\r\n      positive: '',\r\n      negative: '',\r\n      parameters: {},\r\n      quality: null\r\n    };\r\n\r\n    // 优先级：PNG_Chunks > EXIF > Generic\r\n    const priorityOrder = ['PNG_Chunks', 'EXIF', 'Generic'];\r\n    \r\n    for (const source of priorityOrder) {\r\n      const data = extractedData[source];\r\n      if (!data) continue;\r\n\r\n      if (data.data.generationTool) {\r\n        standardized.generationTool = data.data.generationTool;\r\n      }\r\n\r\n      if (data.data.positive && !standardized.positive) {\r\n        standardized.positive = data.data.positive;\r\n      }\r\n\r\n      if (data.data.negative && !standardized.negative) {\r\n        standardized.negative = data.data.negative;\r\n      }\r\n\r\n      Object.assign(standardized.parameters, data.data.parameters || {});\r\n    }\r\n\r\n    // 质量评估\r\n    standardized.quality = this.assessDataQuality(standardized);\r\n\r\n    return standardized;\r\n  }\r\n\r\n  /**\r\n   * 评估数据质量\r\n   * @param {Object} data - 标准化数据\r\n   * @returns {Object} 质量评估\r\n   */\r\n  assessDataQuality(data) {\r\n    let score = 0;\r\n    const factors = [];\r\n\r\n    // 提示词质量评分\r\n    if (data.positive) {\r\n      score += Math.min(data.positive.length / 100, 0.3);\r\n      factors.push('positive_prompt');\r\n    }\r\n\r\n    if (data.negative) {\r\n      score += 0.2;\r\n      factors.push('negative_prompt');\r\n    }\r\n\r\n    // 参数完整性评分\r\n    const importantParams = ['steps', 'cfgScale', 'sampler', 'seed'];\r\n    const paramScore = importantParams.filter(param => \r\n      data.parameters[param] !== undefined).length / importantParams.length;\r\n    score += paramScore * 0.3;\r\n\r\n    // 工具识别加分\r\n    if (data.generationTool !== 'Unknown') {\r\n      score += 0.2;\r\n      factors.push('tool_detected');\r\n    }\r\n\r\n    return {\r\n      overallScore: Math.min(score, 1),\r\n      promptEffectiveness: data.positive ? Math.min(data.positive.length / 200, 1) : 0,\r\n      parameterOptimization: paramScore,\r\n      factors\r\n    };\r\n  }\r\n\r\n  /**\r\n   * 格式化文件大小\r\n   * @param {number} bytes - 字节数\r\n   * @returns {string} 格式化后的大小\r\n   */\r\n  formatFileSize(bytes) {\r\n    const units = ['B', 'KB', 'MB', 'GB'];\r\n    let size = bytes;\r\n    let unitIndex = 0;\r\n\r\n    while (size >= 1024 && unitIndex < units.length - 1) {\r\n      size /= 1024;\r\n      unitIndex++;\r\n    }\r\n\r\n    return `${size.toFixed(2)} ${units[unitIndex]}`;\r\n  }\r\n}\r\n\r\n// 导出单例实例\r\nexport const imageMetadataExtractor = new ImageMetadataExtractor();\r\nexport default ImageMetadataExtractor; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}