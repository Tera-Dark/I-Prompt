{"ast":null,"code":"/**\n * 简化的图像元数据提取器\n * 参考stable-diffusion-inspector的实现方式\n */\n\n// 主要的提取函数\nexport async function extractMetadata(file) {\n  console.log('🚀 开始提取图像元数据...');\n  const result = {\n    success: false,\n    filename: file.name,\n    extractedData: {},\n    standardizedData: null,\n    timestamp: new Date().toISOString()\n  };\n  try {\n    // 基本文件信息\n    result.basicInfo = {\n      size: file.size,\n      sizeFormatted: `${(file.size / 1024).toFixed(1)} KB`,\n      type: file.type,\n      lastModified: new Date(file.lastModified).toLocaleString()\n    };\n\n    // 根据文件类型选择提取方法\n    if (file.type === 'image/png') {\n      const pngData = await extractFromPNG(file);\n      if (pngData) {\n        result.extractedData.PNG = pngData;\n      }\n    }\n\n    // 尝试EXIF提取\n    try {\n      const exifData = await extractFromEXIF(file);\n      if (exifData) {\n        result.extractedData.EXIF = exifData;\n      }\n    } catch (error) {\n      console.warn('EXIF提取失败:', error);\n    }\n\n    // 标准化数据\n    result.standardizedData = standardizeData(result.extractedData);\n    result.success = Object.keys(result.extractedData).length > 0;\n\n    // 添加提取方法信息\n    result.extractionMethods = Object.keys(result.extractedData).map(method => {\n      var _result$extractedData;\n      return {\n        method: method,\n        confidence: ((_result$extractedData = result.extractedData[method]) === null || _result$extractedData === void 0 ? void 0 : _result$extractedData.confidence) || 'unknown'\n      };\n    });\n    return result;\n  } catch (error) {\n    console.error('❌ 元数据提取失败:', error);\n    result.error = error.message;\n    throw error;\n  }\n}\n\n// PNG文件解析 - 参考stable-diffusion-inspector的简洁实现\nasync function extractFromPNG(file) {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = e => {\n      try {\n        const buffer = e.target.result;\n        const chunks = parsePNGChunks(buffer);\n        const metadata = extractMetadataFromChunks(chunks);\n        resolve({\n          type: 'PNG',\n          confidence: metadata.confidence || 'medium',\n          data: metadata\n        });\n      } catch (error) {\n        console.warn('PNG解析失败:', error);\n        resolve(null);\n      }\n    };\n    reader.onerror = () => resolve(null);\n    reader.readAsArrayBuffer(file);\n  });\n}\n\n// 简化的PNG块解析\nfunction parsePNGChunks(buffer) {\n  const view = new DataView(buffer);\n  const chunks = [];\n  let offset = 8; // 跳过PNG签名\n\n  // 验证PNG签名\n  const signature = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A];\n  for (let i = 0; i < 8; i++) {\n    if (view.getUint8(i) !== signature[i]) {\n      throw new Error('不是有效的PNG文件');\n    }\n  }\n  while (offset < buffer.byteLength - 8) {\n    try {\n      const length = view.getUint32(offset);\n      offset += 4;\n      const type = String.fromCharCode(view.getUint8(offset), view.getUint8(offset + 1), view.getUint8(offset + 2), view.getUint8(offset + 3));\n      offset += 4;\n      const data = new Uint8Array(buffer, offset, length);\n      offset += length;\n      const crc = view.getUint32(offset);\n      offset += 4;\n      chunks.push({\n        type,\n        length,\n        data,\n        crc\n      });\n      if (type === 'IEND') break;\n    } catch (error) {\n      console.warn('PNG块解析警告:', error);\n      break;\n    }\n  }\n  return chunks;\n}\n\n// 从PNG块提取元数据\nfunction extractMetadataFromChunks(chunks) {\n  const textChunks = chunks.filter(chunk => ['tEXt', 'iTXt', 'zTXt'].includes(chunk.type));\n  const metadata = {\n    confidence: 'low',\n    generationTool: 'Unknown',\n    positive: '',\n    negative: '',\n    parameters: {}\n  };\n  for (const chunk of textChunks) {\n    const textData = parseTextChunk(chunk);\n    if (!textData.keyword || !textData.text) continue;\n    console.log('解析文本块:', textData.keyword, '长度:', textData.text.length);\n\n    // 检测不同格式\n    if (textData.keyword === 'parameters' && isAutomatic1111Format(textData.text)) {\n      const parsed = parseAutomatic1111(textData.text);\n      Object.assign(metadata, parsed);\n      metadata.generationTool = 'AUTOMATIC1111';\n      metadata.confidence = 'high';\n    } else if (['workflow', 'prompt'].includes(textData.keyword)) {\n      try {\n        const parsed = parseComfyUI(textData.text);\n        Object.assign(metadata, parsed);\n        metadata.generationTool = 'ComfyUI';\n        metadata.confidence = 'high';\n      } catch (error) {\n        console.warn('ComfyUI解析失败:', error);\n      }\n    } else if (['Description', 'Comment'].includes(textData.keyword)) {\n      try {\n        const parsed = parseNovelAI(textData.text);\n        Object.assign(metadata, parsed);\n        metadata.generationTool = 'NovelAI';\n        metadata.confidence = 'high';\n      } catch (error) {\n        console.warn('NovelAI解析失败:', error);\n      }\n    }\n  }\n  return metadata;\n}\n\n// 解析文本块\nfunction parseTextChunk(chunk) {\n  try {\n    const data = chunk.data;\n    if (chunk.type === 'tEXt') {\n      const nullIndex = data.indexOf(0);\n      if (nullIndex === -1) return {};\n      const keyword = decodeLatin1(data.slice(0, nullIndex));\n      const text = decodeLatin1(data.slice(nullIndex + 1));\n      return {\n        keyword,\n        text\n      };\n    }\n    if (chunk.type === 'iTXt') {\n      const nullIndices = [];\n      for (let i = 0; i < data.length; i++) {\n        if (data[i] === 0) {\n          nullIndices.push(i);\n          if (nullIndices.length >= 4) break;\n        }\n      }\n      if (nullIndices.length < 4) return {};\n      const keyword = decodeUTF8(data.slice(0, nullIndices[0]));\n      const text = decodeUTF8(data.slice(nullIndices[3] + 1));\n      return {\n        keyword,\n        text\n      };\n    }\n    return {};\n  } catch (error) {\n    console.warn('文本块解析失败:', error);\n    return {};\n  }\n}\n\n// 安全的字符解码\nfunction decodeLatin1(data) {\n  let result = '';\n  for (let i = 0; i < data.length; i++) {\n    result += String.fromCharCode(data[i]);\n  }\n  return result;\n}\nfunction decodeUTF8(data) {\n  try {\n    return new TextDecoder('utf-8', {\n      fatal: false\n    }).decode(data);\n  } catch (error) {\n    return decodeLatin1(data);\n  }\n}\n\n// 检测AUTOMATIC1111格式\nfunction isAutomatic1111Format(text) {\n  const lowerText = text.toLowerCase();\n  return lowerText.includes('steps:') || lowerText.includes('cfg scale:') || lowerText.includes('sampler:') || lowerText.includes('negative prompt:');\n}\n\n// 解析AUTOMATIC1111数据\nfunction parseAutomatic1111(text) {\n  const result = {\n    positive: '',\n    negative: '',\n    parameters: {}\n  };\n  try {\n    const negativeIndex = text.indexOf('Negative prompt:');\n    if (negativeIndex !== -1) {\n      result.positive = text.substring(0, negativeIndex).trim();\n      const afterNegative = text.substring(negativeIndex + 16);\n      const lines = afterNegative.split('\\n');\n      let negativePrompt = '';\n      let parameterLines = [];\n      let foundParams = false;\n      for (const line of lines) {\n        const trimmed = line.trim();\n        if (isParameterLine(trimmed)) {\n          foundParams = true;\n          parameterLines.push(trimmed);\n        } else if (!foundParams && trimmed) {\n          negativePrompt += (negativePrompt ? '\\n' : '') + trimmed;\n        } else if (foundParams) {\n          parameterLines.push(trimmed);\n        }\n      }\n      result.negative = negativePrompt.trim();\n      if (parameterLines.length > 0) {\n        result.parameters = parseParameters(parameterLines.join(', '));\n      }\n    } else {\n      // 没有负向提示词的情况\n      const lines = text.split('\\n');\n      let positiveLines = [];\n      let parameterLines = [];\n      let foundParams = false;\n      for (const line of lines) {\n        const trimmed = line.trim();\n        if (isParameterLine(trimmed)) {\n          foundParams = true;\n          parameterLines.push(trimmed);\n        } else if (!foundParams && trimmed) {\n          positiveLines.push(trimmed);\n        } else if (foundParams) {\n          parameterLines.push(trimmed);\n        }\n      }\n      result.positive = positiveLines.join(' ').trim();\n      if (parameterLines.length > 0) {\n        result.parameters = parseParameters(parameterLines.join(', '));\n      }\n    }\n  } catch (error) {\n    console.warn('AUTOMATIC1111解析警告:', error);\n    result.positive = text;\n  }\n  return result;\n}\n\n// 检测参数行\nfunction isParameterLine(line) {\n  return /\\b(Steps|Sampler|CFG scale|Seed|Size|Model):/i.test(line);\n}\n\n// 解析参数\nfunction parseParameters(paramText) {\n  const parameters = {};\n  const regex = /(\\w+(?:\\s+\\w+)*)\\s*:\\s*([^,]+?)(?=,\\s*\\w+\\s*:|$)/g;\n  let match;\n  while ((match = regex.exec(paramText)) !== null) {\n    const key = match[1].trim().toLowerCase().replace(/\\s+/g, '');\n    const value = match[2].trim();\n    const numValue = parseFloat(value);\n    parameters[key] = !isNaN(numValue) && isFinite(numValue) ? numValue : value;\n  }\n  return parameters;\n}\n\n// 解析ComfyUI数据\nfunction parseComfyUI(text) {\n  const result = {\n    positive: '',\n    negative: '',\n    parameters: {}\n  };\n  try {\n    const data = JSON.parse(text);\n    if (Array.isArray(data === null || data === void 0 ? void 0 : data.nodes)) {\n      // 工作流格式\n      const prompts = extractFromComfyWorkflow(data);\n      result.positive = prompts.positive;\n      result.negative = prompts.negative;\n    } else if (typeof data === 'object') {\n      // 提示格式\n      const prompts = extractFromComfyPrompt(data);\n      result.positive = prompts.positive;\n      result.negative = prompts.negative;\n    }\n  } catch (error) {\n    console.warn('ComfyUI解析失败:', error);\n  }\n  return result;\n}\n\n// 从ComfyUI工作流提取\nfunction extractFromComfyWorkflow(workflow) {\n  var _workflow$nodes;\n  const positivePrompts = [];\n  const negativePrompts = [];\n  const parameters = {};\n  console.log('🔍 分析ComfyUI工作流，节点数量:', ((_workflow$nodes = workflow.nodes) === null || _workflow$nodes === void 0 ? void 0 : _workflow$nodes.length) || 0);\n  for (const node of workflow.nodes || []) {\n    console.log(`📝 检查节点: ${node.type} (${node.title || 'untitled'})`);\n\n    // 扩展支持的文本编码节点类型\n    const textEncoderTypes = ['CLIPTextEncode', 'CLIPTextEncodeSDXL', 'BNK_CLIPTextEncoder',\n    // BNK系列节点\n    'WeiLin-ComfyUI-prompt-all-in-one',\n    // WeiLin插件\n    'TIPO',\n    // TIPO节点\n    'PromptWithStyle',\n    // 样式提示词节点\n    'StringFunction',\n    // 字符串处理节点\n    'Text',\n    // 通用文本节点\n    'TextInput',\n    // 文本输入节点\n    'PromptBuilder',\n    // 提示词构建器\n    'AdvancedCLIPTextEncode',\n    // 高级CLIP编码器\n    'CLIPTextEncodeFlux',\n    // Flux模型编码器\n    'ShowText',\n    // 显示文本节点\n    'StringConstant',\n    // 字符串常量\n    'MultilineStringLiteral' // 多行字符串\n    ];\n    if (textEncoderTypes.includes(node.type)) {\n      console.log(`✅ 找到文本编码节点: ${node.type}`);\n\n      // 尝试多种方式获取文本内容\n      let text = null;\n\n      // 方式1: widgets_values数组\n      if (node.widgets_values && Array.isArray(node.widgets_values)) {\n        for (const value of node.widgets_values) {\n          if (typeof value === 'string' && value.trim().length > 0) {\n            text = value.trim();\n            console.log(`📄 从widgets_values获取文本: ${text.substring(0, 50)}...`);\n            break;\n          }\n        }\n      }\n\n      // 方式2: 直接的text属性\n      if (!text && node.text && typeof node.text === 'string') {\n        text = node.text.trim();\n        console.log(`📄 从text属性获取文本: ${text.substring(0, 50)}...`);\n      }\n\n      // 方式3: inputs中的text\n      if (!text && node.inputs) {\n        for (const input of node.inputs) {\n          if (input.name === 'text' && input.widget && input.widget.value) {\n            text = input.widget.value.trim();\n            console.log(`📄 从inputs获取文本: ${text.substring(0, 50)}...`);\n            break;\n          }\n        }\n      }\n\n      // 方式4: properties中查找\n      if (!text && node.properties) {\n        if (node.properties.text) {\n          text = node.properties.text.trim();\n          console.log(`📄 从properties获取文本: ${text.substring(0, 50)}...`);\n        }\n      }\n      if (text && text.length > 0) {\n        var _node$title, _node$title2, _node$title3;\n        // 智能判断是否为负向提示词\n        const isNegative = isNegativePrompt(text) || ((_node$title = node.title) === null || _node$title === void 0 ? void 0 : _node$title.toLowerCase().includes('negative')) || ((_node$title2 = node.title) === null || _node$title2 === void 0 ? void 0 : _node$title2.toLowerCase().includes('负向')) || ((_node$title3 = node.title) === null || _node$title3 === void 0 ? void 0 : _node$title3.toLowerCase().includes('反向')) || node.color && (node.color === '#ff6b6b' || node.color === '#e74c3c'); // 红色通常表示负向\n\n        if (isNegative) {\n          negativePrompts.push(text);\n          console.log(`➖ 识别为负向提示词: ${text.substring(0, 30)}...`);\n        } else {\n          positivePrompts.push(text);\n          console.log(`➕ 识别为正向提示词: ${text.substring(0, 30)}...`);\n        }\n      }\n    }\n\n    // 提取采样器参数\n    if (['KSampler', 'KSamplerAdvanced', 'SamplerCustom'].includes(node.type)) {\n      if (node.widgets_values) {\n        const [seed, steps, cfg, sampler_name, scheduler, denoise] = node.widgets_values;\n        if (seed !== undefined) parameters.seed = seed;\n        if (steps !== undefined) parameters.steps = steps;\n        if (cfg !== undefined) parameters.cfg_scale = cfg;\n        if (sampler_name !== undefined) parameters.sampler = sampler_name;\n        if (scheduler !== undefined) parameters.scheduler = scheduler;\n        if (denoise !== undefined) parameters.denoise = denoise;\n        console.log(`⚙️ 提取采样器参数: steps=${steps}, cfg=${cfg}, sampler=${sampler_name}`);\n      }\n    }\n\n    // 提取模型信息\n    if (['CheckpointLoaderSimple', 'CheckpointLoader'].includes(node.type)) {\n      if (node.widgets_values && node.widgets_values[0]) {\n        parameters.model = node.widgets_values[0];\n        console.log(`🎯 提取模型: ${parameters.model}`);\n      }\n    }\n\n    // 提取图像尺寸\n    if (['EmptyLatentImage', 'LatentUpscale'].includes(node.type)) {\n      if (node.widgets_values) {\n        const [width, height] = node.widgets_values;\n        if (width !== undefined) parameters.width = width;\n        if (height !== undefined) parameters.height = height;\n        console.log(`📐 提取尺寸: ${width}x${height}`);\n      }\n    }\n  }\n\n  // 智能合并提示词\n  const finalPositive = smartMergePrompts(positivePrompts);\n  const finalNegative = smartMergePrompts(negativePrompts);\n  console.log(`🎯 最终结果: 正向提示词${finalPositive.length}字符, 负向提示词${finalNegative.length}字符`);\n  return {\n    positive: finalPositive,\n    negative: finalNegative,\n    parameters\n  };\n}\n\n// 智能合并提示词\nfunction smartMergePrompts(prompts) {\n  if (prompts.length === 0) return '';\n  if (prompts.length === 1) return prompts[0];\n\n  // 去重并按长度排序，优先选择更完整的提示词\n  const uniquePrompts = [...new Set(prompts)];\n  uniquePrompts.sort((a, b) => b.length - a.length);\n\n  // 如果最长的提示词明显比其他的长很多，可能是最终合成的结果\n  const longest = uniquePrompts[0];\n  const secondLongest = uniquePrompts[1] || '';\n  if (longest.length > secondLongest.length * 2) {\n    console.log(`🎯 选择最长提示词作为最终结果: ${longest.length} vs ${secondLongest.length}`);\n    return longest;\n  }\n\n  // 否则合并所有唯一的提示词\n  return uniquePrompts.join(', ');\n}\n\n// 从ComfyUI提示提取\nfunction extractFromComfyPrompt(prompt) {\n  const positivePrompts = [];\n  const negativePrompts = [];\n  const parameters = {};\n  console.log('🔍 分析ComfyUI提示格式，节点数量:', Object.keys(prompt).length);\n  for (const [nodeId, nodeData] of Object.entries(prompt)) {\n    console.log(`📝 检查节点 ${nodeId}: ${nodeData.class_type}`);\n\n    // 扩展支持的节点类型\n    const textEncoderTypes = ['CLIPTextEncode', 'CLIPTextEncodeSDXL', 'BNK_CLIPTextEncoder', 'WeiLin-ComfyUI-prompt-all-in-one', 'TIPO', 'PromptWithStyle', 'StringFunction', 'Text', 'TextInput', 'PromptBuilder', 'AdvancedCLIPTextEncode', 'CLIPTextEncodeFlux', 'ShowText', 'StringConstant', 'MultilineStringLiteral'];\n    if (textEncoderTypes.includes(nodeData.class_type)) {\n      var _nodeData$inputs, _nodeData$inputs2, _nodeData$inputs3;\n      console.log(`✅ 找到文本编码节点: ${nodeData.class_type}`);\n\n      // 尝试多种方式获取文本\n      let text = null;\n      if ((_nodeData$inputs = nodeData.inputs) !== null && _nodeData$inputs !== void 0 && _nodeData$inputs.text && typeof nodeData.inputs.text === 'string') {\n        text = nodeData.inputs.text.trim();\n        console.log(`📄 从inputs.text获取: ${text.substring(0, 50)}...`);\n      } else if ((_nodeData$inputs2 = nodeData.inputs) !== null && _nodeData$inputs2 !== void 0 && _nodeData$inputs2.prompt && typeof nodeData.inputs.prompt === 'string') {\n        text = nodeData.inputs.prompt.trim();\n        console.log(`📄 从inputs.prompt获取: ${text.substring(0, 50)}...`);\n      } else if ((_nodeData$inputs3 = nodeData.inputs) !== null && _nodeData$inputs3 !== void 0 && _nodeData$inputs3.string && typeof nodeData.inputs.string === 'string') {\n        text = nodeData.inputs.string.trim();\n        console.log(`📄 从inputs.string获取: ${text.substring(0, 50)}...`);\n      }\n      if (text && text.length > 0) {\n        if (isNegativePrompt(text)) {\n          negativePrompts.push(text);\n          console.log(`➖ 识别为负向提示词`);\n        } else {\n          positivePrompts.push(text);\n          console.log(`➕ 识别为正向提示词`);\n        }\n      }\n    }\n\n    // 提取其他参数...\n    if (['KSampler', 'KSamplerAdvanced', 'SamplerCustom'].includes(nodeData.class_type)) {\n      const inputs = nodeData.inputs;\n      if (inputs.seed !== undefined) parameters.seed = inputs.seed;\n      if (inputs.steps !== undefined) parameters.steps = inputs.steps;\n      if (inputs.cfg !== undefined) parameters.cfg_scale = inputs.cfg;\n      if (inputs.sampler_name !== undefined) parameters.sampler = inputs.sampler_name;\n      if (inputs.scheduler !== undefined) parameters.scheduler = inputs.scheduler;\n      if (inputs.denoise !== undefined) parameters.denoise = inputs.denoise;\n    }\n  }\n  const finalPositive = smartMergePrompts(positivePrompts);\n  const finalNegative = smartMergePrompts(negativePrompts);\n  console.log(`🎯 最终结果: 正向提示词${finalPositive.length}字符, 负向提示词${finalNegative.length}字符`);\n  return {\n    positive: finalPositive,\n    negative: finalNegative,\n    parameters\n  };\n}\n\n// 检测负向提示词\nfunction isNegativePrompt(text) {\n  const lowerText = text.toLowerCase();\n\n  // 扩展负向关键词列表\n  const negativeKeywords = [\n  // 质量相关\n  'worst quality', 'bad quality', 'low quality', 'poor quality', 'bad anatomy', 'bad proportions', 'bad hands', 'bad fingers', 'ugly', 'deformed', 'disfigured', 'mutated', 'malformed', 'blurry', 'blur', 'out of focus', 'unfocused', 'soft focus', 'lowres', 'low resolution', 'pixelated', 'jpeg artifacts',\n  // 技术问题\n  'error', 'glitch', 'artifact', 'noise', 'grain', 'distorted', 'cropped', 'cut off', 'truncated', 'incomplete', 'watermark', 'signature', 'text', 'logo', 'username', 'border', 'frame', 'black bars', 'letterbox',\n  // 解剖问题\n  'extra limbs', 'missing limbs', 'extra fingers', 'missing fingers', 'extra arms', 'extra legs', 'fused fingers', 'too many fingers', 'long neck', 'long body', 'elongated', 'stretched', 'duplicate', 'multiple', 'conjoined', 'merged',\n  // 风格问题\n  'amateur', 'sketch', 'draft', 'unfinished', 'rough', 'simple', 'basic', 'plain', 'boring', 'dull', 'monochrome', 'grayscale', 'black and white', 'sepia',\n  // 内容问题\n  'nsfw', 'nude', 'naked', 'explicit', 'sexual', 'violence', 'blood', 'gore', 'disturbing', 'scary', 'dark', 'horror', 'nightmare', 'creepy', 'evil',\n  // 中文负向词\n  '最差质量', '糟糕质量', '低质量', '差质量', '糟糕解剖', '变形', '畸形', '丑陋', '模糊', '低分辨率', '像素化', '噪点', '伪影', '水印', '签名', '文字', '标志', '用户名', '多余的', '缺失的', '融合的', '重复的', '业余', '草图', '未完成', '粗糙', '简单', '单色', '灰度', '黑白', '暗色调'];\n\n  // 检查是否包含负向关键词\n  const hasNegativeKeywords = negativeKeywords.some(keyword => lowerText.includes(keyword.toLowerCase()));\n\n  // 检查负向提示词的比例\n  const negativeWordCount = negativeKeywords.filter(keyword => lowerText.includes(keyword.toLowerCase())).length;\n  const totalWords = text.split(/\\s+/).length;\n  const negativeRatio = negativeWordCount / totalWords;\n\n  // 如果负向词汇比例超过30%，很可能是负向提示词\n  const isHighNegativeRatio = negativeRatio > 0.3;\n\n  // 检查是否以负向词开头\n  const startsWithNegative = negativeKeywords.some(keyword => lowerText.startsWith(keyword.toLowerCase()));\n  console.log(`🔍 负向检测: 关键词=${hasNegativeKeywords}, 比例=${negativeRatio.toFixed(2)}, 开头=${startsWithNegative}`);\n  return hasNegativeKeywords || isHighNegativeRatio || startsWithNegative;\n}\n\n// 解析NovelAI数据\nfunction parseNovelAI(text) {\n  const result = {\n    positive: '',\n    negative: '',\n    parameters: {}\n  };\n  try {\n    const data = JSON.parse(text);\n    result.positive = data.prompt || '';\n    result.negative = data.uc || '';\n    ['steps', 'scale', 'seed', 'sampler', 'width', 'height'].forEach(key => {\n      if (data[key] !== undefined) {\n        result.parameters[key] = data[key];\n      }\n    });\n  } catch (error) {\n    console.warn('NovelAI解析失败:', error);\n  }\n  return result;\n}\n\n// EXIF数据提取\nasync function extractFromEXIF(file) {\n  try {\n    // 动态导入exifr\n    const exifr = await import('exifr');\n    const exifData = await exifr.parse(file, {\n      userComment: true,\n      imageDescription: true,\n      software: true\n    });\n    if (!exifData) return null;\n    return {\n      type: 'EXIF',\n      confidence: 'medium',\n      data: {\n        software: exifData.Software,\n        description: exifData.ImageDescription,\n        userComment: exifData.UserComment,\n        positive: exifData.UserComment || exifData.ImageDescription || '',\n        negative: '',\n        parameters: {}\n      }\n    };\n  } catch (error) {\n    console.warn('EXIF提取失败:', error);\n    return null;\n  }\n}\n\n// 标准化数据\nfunction standardizeData(extractedData) {\n  const standardized = {\n    generationTool: 'Unknown',\n    positive: '',\n    negative: '',\n    parameters: {}\n  };\n\n  // 优先级顺序\n  const sources = ['PNG', 'EXIF'];\n  for (const source of sources) {\n    const data = extractedData[source];\n    if (!data) continue;\n    if (data.data.generationTool) {\n      standardized.generationTool = data.data.generationTool;\n    }\n    if (data.data.positive && !standardized.positive) {\n      standardized.positive = data.data.positive;\n    }\n    if (data.data.negative && !standardized.negative) {\n      standardized.negative = data.data.negative;\n    }\n    Object.assign(standardized.parameters, data.data.parameters || {});\n  }\n  return standardized;\n}\n\n// 导出主要函数\nexport const imageMetadataExtractor = {\n  extractMetadata\n};\nexport default imageMetadataExtractor;","map":{"version":3,"names":["extractMetadata","file","console","log","result","success","filename","name","extractedData","standardizedData","timestamp","Date","toISOString","basicInfo","size","sizeFormatted","toFixed","type","lastModified","toLocaleString","pngData","extractFromPNG","PNG","exifData","extractFromEXIF","EXIF","error","warn","standardizeData","Object","keys","length","extractionMethods","map","method","_result$extractedData","confidence","message","Promise","resolve","reject","reader","FileReader","onload","e","buffer","target","chunks","parsePNGChunks","metadata","extractMetadataFromChunks","data","onerror","readAsArrayBuffer","view","DataView","offset","signature","i","getUint8","Error","byteLength","getUint32","String","fromCharCode","Uint8Array","crc","push","textChunks","filter","chunk","includes","generationTool","positive","negative","parameters","textData","parseTextChunk","keyword","text","isAutomatic1111Format","parsed","parseAutomatic1111","assign","parseComfyUI","parseNovelAI","nullIndex","indexOf","decodeLatin1","slice","nullIndices","decodeUTF8","TextDecoder","fatal","decode","lowerText","toLowerCase","negativeIndex","substring","trim","afterNegative","lines","split","negativePrompt","parameterLines","foundParams","line","trimmed","isParameterLine","parseParameters","join","positiveLines","test","paramText","regex","match","exec","key","replace","value","numValue","parseFloat","isNaN","isFinite","JSON","parse","Array","isArray","nodes","prompts","extractFromComfyWorkflow","extractFromComfyPrompt","workflow","_workflow$nodes","positivePrompts","negativePrompts","node","title","textEncoderTypes","widgets_values","inputs","input","widget","properties","_node$title","_node$title2","_node$title3","isNegative","isNegativePrompt","color","seed","steps","cfg","sampler_name","scheduler","denoise","undefined","cfg_scale","sampler","model","width","height","finalPositive","smartMergePrompts","finalNegative","uniquePrompts","Set","sort","a","b","longest","secondLongest","prompt","nodeId","nodeData","entries","class_type","_nodeData$inputs","_nodeData$inputs2","_nodeData$inputs3","string","negativeKeywords","hasNegativeKeywords","some","negativeWordCount","totalWords","negativeRatio","isHighNegativeRatio","startsWithNegative","startsWith","uc","forEach","exifr","userComment","imageDescription","software","Software","description","ImageDescription","UserComment","standardized","sources","source","imageMetadataExtractor"],"sources":["C:/Users/wjx19/Documents/GitHub/I-Prompt/src/utils/imageMetadataExtractor.js"],"sourcesContent":["/**\n * 简化的图像元数据提取器\n * 参考stable-diffusion-inspector的实现方式\n */\n\n// 主要的提取函数\nexport async function extractMetadata(file) {\n  console.log('🚀 开始提取图像元数据...');\n  \n  const result = {\n    success: false,\n    filename: file.name,\n    extractedData: {},\n    standardizedData: null,\n    timestamp: new Date().toISOString()\n  };\n\n  try {\n    // 基本文件信息\n    result.basicInfo = {\n      size: file.size,\n      sizeFormatted: `${(file.size / 1024).toFixed(1)} KB`,\n      type: file.type,\n      lastModified: new Date(file.lastModified).toLocaleString()\n    };\n\n    // 根据文件类型选择提取方法\n    if (file.type === 'image/png') {\n      const pngData = await extractFromPNG(file);\n      if (pngData) {\n        result.extractedData.PNG = pngData;\n      }\n    }\n\n    // 尝试EXIF提取\n    try {\n      const exifData = await extractFromEXIF(file);\n      if (exifData) {\n        result.extractedData.EXIF = exifData;\n      }\n    } catch (error) {\n      console.warn('EXIF提取失败:', error);\n    }\n\n    // 标准化数据\n    result.standardizedData = standardizeData(result.extractedData);\n    result.success = Object.keys(result.extractedData).length > 0;\n\n    // 添加提取方法信息\n    result.extractionMethods = Object.keys(result.extractedData).map(method => ({\n      method: method,\n      confidence: result.extractedData[method]?.confidence || 'unknown'\n    }));\n\n    return result;\n    \n  } catch (error) {\n    console.error('❌ 元数据提取失败:', error);\n    result.error = error.message;\n    throw error;\n  }\n}\n\n// PNG文件解析 - 参考stable-diffusion-inspector的简洁实现\nasync function extractFromPNG(file) {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    \n    reader.onload = (e) => {\n      try {\n        const buffer = e.target.result;\n        const chunks = parsePNGChunks(buffer);\n        const metadata = extractMetadataFromChunks(chunks);\n        \n        resolve({\n          type: 'PNG',\n          confidence: metadata.confidence || 'medium',\n          data: metadata\n        });\n      } catch (error) {\n        console.warn('PNG解析失败:', error);\n        resolve(null);\n      }\n    };\n    \n    reader.onerror = () => resolve(null);\n    reader.readAsArrayBuffer(file);\n  });\n}\n\n// 简化的PNG块解析\nfunction parsePNGChunks(buffer) {\n  const view = new DataView(buffer);\n  const chunks = [];\n  let offset = 8; // 跳过PNG签名\n\n  // 验证PNG签名\n  const signature = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A];\n  for (let i = 0; i < 8; i++) {\n    if (view.getUint8(i) !== signature[i]) {\n      throw new Error('不是有效的PNG文件');\n    }\n  }\n\n  while (offset < buffer.byteLength - 8) {\n    try {\n      const length = view.getUint32(offset);\n      offset += 4;\n\n      const type = String.fromCharCode(\n        view.getUint8(offset),\n        view.getUint8(offset + 1),\n        view.getUint8(offset + 2),\n        view.getUint8(offset + 3)\n      );\n      offset += 4;\n\n      const data = new Uint8Array(buffer, offset, length);\n      offset += length;\n\n      const crc = view.getUint32(offset);\n      offset += 4;\n\n      chunks.push({ type, length, data, crc });\n\n      if (type === 'IEND') break;\n    } catch (error) {\n      console.warn('PNG块解析警告:', error);\n      break;\n    }\n  }\n\n  return chunks;\n}\n\n// 从PNG块提取元数据\nfunction extractMetadataFromChunks(chunks) {\n  const textChunks = chunks.filter(chunk => \n    ['tEXt', 'iTXt', 'zTXt'].includes(chunk.type)\n  );\n\n  const metadata = {\n    confidence: 'low',\n    generationTool: 'Unknown',\n    positive: '',\n    negative: '',\n    parameters: {}\n  };\n\n  for (const chunk of textChunks) {\n    const textData = parseTextChunk(chunk);\n    if (!textData.keyword || !textData.text) continue;\n\n    console.log('解析文本块:', textData.keyword, '长度:', textData.text.length);\n\n    // 检测不同格式\n    if (textData.keyword === 'parameters' && isAutomatic1111Format(textData.text)) {\n      const parsed = parseAutomatic1111(textData.text);\n      Object.assign(metadata, parsed);\n      metadata.generationTool = 'AUTOMATIC1111';\n      metadata.confidence = 'high';\n    } else if (['workflow', 'prompt'].includes(textData.keyword)) {\n      try {\n        const parsed = parseComfyUI(textData.text);\n        Object.assign(metadata, parsed);\n        metadata.generationTool = 'ComfyUI';\n        metadata.confidence = 'high';\n      } catch (error) {\n        console.warn('ComfyUI解析失败:', error);\n      }\n    } else if (['Description', 'Comment'].includes(textData.keyword)) {\n      try {\n        const parsed = parseNovelAI(textData.text);\n        Object.assign(metadata, parsed);\n        metadata.generationTool = 'NovelAI';\n        metadata.confidence = 'high';\n      } catch (error) {\n        console.warn('NovelAI解析失败:', error);\n      }\n    }\n  }\n\n  return metadata;\n}\n\n// 解析文本块\nfunction parseTextChunk(chunk) {\n  try {\n    const data = chunk.data;\n    \n    if (chunk.type === 'tEXt') {\n      const nullIndex = data.indexOf(0);\n      if (nullIndex === -1) return {};\n\n      const keyword = decodeLatin1(data.slice(0, nullIndex));\n      const text = decodeLatin1(data.slice(nullIndex + 1));\n      return { keyword, text };\n    }\n    \n    if (chunk.type === 'iTXt') {\n      const nullIndices = [];\n      for (let i = 0; i < data.length; i++) {\n        if (data[i] === 0) {\n          nullIndices.push(i);\n          if (nullIndices.length >= 4) break;\n        }\n      }\n\n      if (nullIndices.length < 4) return {};\n\n      const keyword = decodeUTF8(data.slice(0, nullIndices[0]));\n      const text = decodeUTF8(data.slice(nullIndices[3] + 1));\n      return { keyword, text };\n    }\n    \n    return {};\n  } catch (error) {\n    console.warn('文本块解析失败:', error);\n    return {};\n  }\n}\n\n// 安全的字符解码\nfunction decodeLatin1(data) {\n  let result = '';\n  for (let i = 0; i < data.length; i++) {\n    result += String.fromCharCode(data[i]);\n  }\n  return result;\n}\n\nfunction decodeUTF8(data) {\n  try {\n    return new TextDecoder('utf-8', { fatal: false }).decode(data);\n  } catch (error) {\n    return decodeLatin1(data);\n  }\n}\n\n// 检测AUTOMATIC1111格式\nfunction isAutomatic1111Format(text) {\n  const lowerText = text.toLowerCase();\n  return lowerText.includes('steps:') || \n         lowerText.includes('cfg scale:') || \n         lowerText.includes('sampler:') || \n         lowerText.includes('negative prompt:');\n}\n\n// 解析AUTOMATIC1111数据\nfunction parseAutomatic1111(text) {\n  const result = {\n    positive: '',\n    negative: '',\n    parameters: {}\n  };\n\n  try {\n    const negativeIndex = text.indexOf('Negative prompt:');\n    \n    if (negativeIndex !== -1) {\n      result.positive = text.substring(0, negativeIndex).trim();\n      \n      const afterNegative = text.substring(negativeIndex + 16);\n      const lines = afterNegative.split('\\n');\n      \n      let negativePrompt = '';\n      let parameterLines = [];\n      let foundParams = false;\n      \n      for (const line of lines) {\n        const trimmed = line.trim();\n        if (isParameterLine(trimmed)) {\n          foundParams = true;\n          parameterLines.push(trimmed);\n        } else if (!foundParams && trimmed) {\n          negativePrompt += (negativePrompt ? '\\n' : '') + trimmed;\n        } else if (foundParams) {\n          parameterLines.push(trimmed);\n        }\n      }\n      \n      result.negative = negativePrompt.trim();\n      \n      if (parameterLines.length > 0) {\n        result.parameters = parseParameters(parameterLines.join(', '));\n      }\n    } else {\n      // 没有负向提示词的情况\n      const lines = text.split('\\n');\n      let positiveLines = [];\n      let parameterLines = [];\n      let foundParams = false;\n      \n      for (const line of lines) {\n        const trimmed = line.trim();\n        if (isParameterLine(trimmed)) {\n          foundParams = true;\n          parameterLines.push(trimmed);\n        } else if (!foundParams && trimmed) {\n          positiveLines.push(trimmed);\n        } else if (foundParams) {\n          parameterLines.push(trimmed);\n        }\n      }\n      \n      result.positive = positiveLines.join(' ').trim();\n      \n      if (parameterLines.length > 0) {\n        result.parameters = parseParameters(parameterLines.join(', '));\n      }\n    }\n  } catch (error) {\n    console.warn('AUTOMATIC1111解析警告:', error);\n    result.positive = text;\n  }\n\n  return result;\n}\n\n// 检测参数行\nfunction isParameterLine(line) {\n  return /\\b(Steps|Sampler|CFG scale|Seed|Size|Model):/i.test(line);\n}\n\n// 解析参数\nfunction parseParameters(paramText) {\n  const parameters = {};\n  const regex = /(\\w+(?:\\s+\\w+)*)\\s*:\\s*([^,]+?)(?=,\\s*\\w+\\s*:|$)/g;\n  let match;\n\n  while ((match = regex.exec(paramText)) !== null) {\n    const key = match[1].trim().toLowerCase().replace(/\\s+/g, '');\n    const value = match[2].trim();\n    \n    const numValue = parseFloat(value);\n    parameters[key] = !isNaN(numValue) && isFinite(numValue) ? numValue : value;\n  }\n\n  return parameters;\n}\n\n// 解析ComfyUI数据\nfunction parseComfyUI(text) {\n  const result = {\n    positive: '',\n    negative: '',\n    parameters: {}\n  };\n\n  try {\n    const data = JSON.parse(text);\n    \n    if (Array.isArray(data?.nodes)) {\n      // 工作流格式\n      const prompts = extractFromComfyWorkflow(data);\n      result.positive = prompts.positive;\n      result.negative = prompts.negative;\n    } else if (typeof data === 'object') {\n      // 提示格式\n      const prompts = extractFromComfyPrompt(data);\n      result.positive = prompts.positive;\n      result.negative = prompts.negative;\n    }\n  } catch (error) {\n    console.warn('ComfyUI解析失败:', error);\n  }\n\n  return result;\n}\n\n// 从ComfyUI工作流提取\nfunction extractFromComfyWorkflow(workflow) {\n  const positivePrompts = [];\n  const negativePrompts = [];\n  const parameters = {};\n\n  console.log('🔍 分析ComfyUI工作流，节点数量:', workflow.nodes?.length || 0);\n\n  for (const node of workflow.nodes || []) {\n    console.log(`📝 检查节点: ${node.type} (${node.title || 'untitled'})`);\n    \n    // 扩展支持的文本编码节点类型\n    const textEncoderTypes = [\n      'CLIPTextEncode', \n      'CLIPTextEncodeSDXL',\n      'BNK_CLIPTextEncoder',  // BNK系列节点\n      'WeiLin-ComfyUI-prompt-all-in-one',  // WeiLin插件\n      'TIPO',  // TIPO节点\n      'PromptWithStyle',  // 样式提示词节点\n      'StringFunction',  // 字符串处理节点\n      'Text',  // 通用文本节点\n      'TextInput',  // 文本输入节点\n      'PromptBuilder',  // 提示词构建器\n      'AdvancedCLIPTextEncode',  // 高级CLIP编码器\n      'CLIPTextEncodeFlux',  // Flux模型编码器\n      'ShowText',  // 显示文本节点\n      'StringConstant',  // 字符串常量\n      'MultilineStringLiteral'  // 多行字符串\n    ];\n\n    if (textEncoderTypes.includes(node.type)) {\n      console.log(`✅ 找到文本编码节点: ${node.type}`);\n      \n      // 尝试多种方式获取文本内容\n      let text = null;\n      \n      // 方式1: widgets_values数组\n      if (node.widgets_values && Array.isArray(node.widgets_values)) {\n        for (const value of node.widgets_values) {\n          if (typeof value === 'string' && value.trim().length > 0) {\n            text = value.trim();\n            console.log(`📄 从widgets_values获取文本: ${text.substring(0, 50)}...`);\n            break;\n          }\n        }\n      }\n      \n      // 方式2: 直接的text属性\n      if (!text && node.text && typeof node.text === 'string') {\n        text = node.text.trim();\n        console.log(`📄 从text属性获取文本: ${text.substring(0, 50)}...`);\n      }\n      \n      // 方式3: inputs中的text\n      if (!text && node.inputs) {\n        for (const input of node.inputs) {\n          if (input.name === 'text' && input.widget && input.widget.value) {\n            text = input.widget.value.trim();\n            console.log(`📄 从inputs获取文本: ${text.substring(0, 50)}...`);\n            break;\n          }\n        }\n      }\n      \n      // 方式4: properties中查找\n      if (!text && node.properties) {\n        if (node.properties.text) {\n          text = node.properties.text.trim();\n          console.log(`📄 从properties获取文本: ${text.substring(0, 50)}...`);\n        }\n      }\n      \n      if (text && text.length > 0) {\n        // 智能判断是否为负向提示词\n        const isNegative = isNegativePrompt(text) || \n                          node.title?.toLowerCase().includes('negative') ||\n                          node.title?.toLowerCase().includes('负向') ||\n                          node.title?.toLowerCase().includes('反向') ||\n                          (node.color && (node.color === '#ff6b6b' || node.color === '#e74c3c')); // 红色通常表示负向\n        \n        if (isNegative) {\n          negativePrompts.push(text);\n          console.log(`➖ 识别为负向提示词: ${text.substring(0, 30)}...`);\n        } else {\n          positivePrompts.push(text);\n          console.log(`➕ 识别为正向提示词: ${text.substring(0, 30)}...`);\n        }\n      }\n    }\n    \n    // 提取采样器参数\n    if (['KSampler', 'KSamplerAdvanced', 'SamplerCustom'].includes(node.type)) {\n      if (node.widgets_values) {\n        const [seed, steps, cfg, sampler_name, scheduler, denoise] = node.widgets_values;\n        if (seed !== undefined) parameters.seed = seed;\n        if (steps !== undefined) parameters.steps = steps;\n        if (cfg !== undefined) parameters.cfg_scale = cfg;\n        if (sampler_name !== undefined) parameters.sampler = sampler_name;\n        if (scheduler !== undefined) parameters.scheduler = scheduler;\n        if (denoise !== undefined) parameters.denoise = denoise;\n        console.log(`⚙️ 提取采样器参数: steps=${steps}, cfg=${cfg}, sampler=${sampler_name}`);\n      }\n    }\n    \n    // 提取模型信息\n    if (['CheckpointLoaderSimple', 'CheckpointLoader'].includes(node.type)) {\n      if (node.widgets_values && node.widgets_values[0]) {\n        parameters.model = node.widgets_values[0];\n        console.log(`🎯 提取模型: ${parameters.model}`);\n      }\n    }\n    \n    // 提取图像尺寸\n    if (['EmptyLatentImage', 'LatentUpscale'].includes(node.type)) {\n      if (node.widgets_values) {\n        const [width, height] = node.widgets_values;\n        if (width !== undefined) parameters.width = width;\n        if (height !== undefined) parameters.height = height;\n        console.log(`📐 提取尺寸: ${width}x${height}`);\n      }\n    }\n  }\n\n  // 智能合并提示词\n  const finalPositive = smartMergePrompts(positivePrompts);\n  const finalNegative = smartMergePrompts(negativePrompts);\n  \n  console.log(`🎯 最终结果: 正向提示词${finalPositive.length}字符, 负向提示词${finalNegative.length}字符`);\n\n  return {\n    positive: finalPositive,\n    negative: finalNegative,\n    parameters\n  };\n}\n\n// 智能合并提示词\nfunction smartMergePrompts(prompts) {\n  if (prompts.length === 0) return '';\n  if (prompts.length === 1) return prompts[0];\n  \n  // 去重并按长度排序，优先选择更完整的提示词\n  const uniquePrompts = [...new Set(prompts)];\n  uniquePrompts.sort((a, b) => b.length - a.length);\n  \n  // 如果最长的提示词明显比其他的长很多，可能是最终合成的结果\n  const longest = uniquePrompts[0];\n  const secondLongest = uniquePrompts[1] || '';\n  \n  if (longest.length > secondLongest.length * 2) {\n    console.log(`🎯 选择最长提示词作为最终结果: ${longest.length} vs ${secondLongest.length}`);\n    return longest;\n  }\n  \n  // 否则合并所有唯一的提示词\n  return uniquePrompts.join(', ');\n}\n\n// 从ComfyUI提示提取\nfunction extractFromComfyPrompt(prompt) {\n  const positivePrompts = [];\n  const negativePrompts = [];\n  const parameters = {};\n\n  console.log('🔍 分析ComfyUI提示格式，节点数量:', Object.keys(prompt).length);\n\n  for (const [nodeId, nodeData] of Object.entries(prompt)) {\n    console.log(`📝 检查节点 ${nodeId}: ${nodeData.class_type}`);\n    \n    // 扩展支持的节点类型\n    const textEncoderTypes = [\n      'CLIPTextEncode', \n      'CLIPTextEncodeSDXL',\n      'BNK_CLIPTextEncoder',\n      'WeiLin-ComfyUI-prompt-all-in-one',\n      'TIPO',\n      'PromptWithStyle',\n      'StringFunction',\n      'Text',\n      'TextInput',\n      'PromptBuilder',\n      'AdvancedCLIPTextEncode',\n      'CLIPTextEncodeFlux',\n      'ShowText',\n      'StringConstant',\n      'MultilineStringLiteral'\n    ];\n    \n    if (textEncoderTypes.includes(nodeData.class_type)) {\n      console.log(`✅ 找到文本编码节点: ${nodeData.class_type}`);\n      \n      // 尝试多种方式获取文本\n      let text = null;\n      \n      if (nodeData.inputs?.text && typeof nodeData.inputs.text === 'string') {\n        text = nodeData.inputs.text.trim();\n        console.log(`📄 从inputs.text获取: ${text.substring(0, 50)}...`);\n      } else if (nodeData.inputs?.prompt && typeof nodeData.inputs.prompt === 'string') {\n        text = nodeData.inputs.prompt.trim();\n        console.log(`📄 从inputs.prompt获取: ${text.substring(0, 50)}...`);\n      } else if (nodeData.inputs?.string && typeof nodeData.inputs.string === 'string') {\n        text = nodeData.inputs.string.trim();\n        console.log(`📄 从inputs.string获取: ${text.substring(0, 50)}...`);\n      }\n      \n      if (text && text.length > 0) {\n        if (isNegativePrompt(text)) {\n          negativePrompts.push(text);\n          console.log(`➖ 识别为负向提示词`);\n        } else {\n          positivePrompts.push(text);\n          console.log(`➕ 识别为正向提示词`);\n        }\n      }\n    }\n    \n    // 提取其他参数...\n    if (['KSampler', 'KSamplerAdvanced', 'SamplerCustom'].includes(nodeData.class_type)) {\n      const inputs = nodeData.inputs;\n      if (inputs.seed !== undefined) parameters.seed = inputs.seed;\n      if (inputs.steps !== undefined) parameters.steps = inputs.steps;\n      if (inputs.cfg !== undefined) parameters.cfg_scale = inputs.cfg;\n      if (inputs.sampler_name !== undefined) parameters.sampler = inputs.sampler_name;\n      if (inputs.scheduler !== undefined) parameters.scheduler = inputs.scheduler;\n      if (inputs.denoise !== undefined) parameters.denoise = inputs.denoise;\n    }\n  }\n\n  const finalPositive = smartMergePrompts(positivePrompts);\n  const finalNegative = smartMergePrompts(negativePrompts);\n  \n  console.log(`🎯 最终结果: 正向提示词${finalPositive.length}字符, 负向提示词${finalNegative.length}字符`);\n\n  return {\n    positive: finalPositive,\n    negative: finalNegative,\n    parameters\n  };\n}\n\n// 检测负向提示词\nfunction isNegativePrompt(text) {\n  const lowerText = text.toLowerCase();\n  \n  // 扩展负向关键词列表\n  const negativeKeywords = [\n    // 质量相关\n    'worst quality', 'bad quality', 'low quality', 'poor quality',\n    'bad anatomy', 'bad proportions', 'bad hands', 'bad fingers',\n    'ugly', 'deformed', 'disfigured', 'mutated', 'malformed',\n    'blurry', 'blur', 'out of focus', 'unfocused', 'soft focus',\n    'lowres', 'low resolution', 'pixelated', 'jpeg artifacts',\n    \n    // 技术问题\n    'error', 'glitch', 'artifact', 'noise', 'grain', 'distorted',\n    'cropped', 'cut off', 'truncated', 'incomplete',\n    'watermark', 'signature', 'text', 'logo', 'username',\n    'border', 'frame', 'black bars', 'letterbox',\n    \n    // 解剖问题\n    'extra limbs', 'missing limbs', 'extra fingers', 'missing fingers',\n    'extra arms', 'extra legs', 'fused fingers', 'too many fingers',\n    'long neck', 'long body', 'elongated', 'stretched',\n    'duplicate', 'multiple', 'conjoined', 'merged',\n    \n    // 风格问题\n    'amateur', 'sketch', 'draft', 'unfinished', 'rough',\n    'simple', 'basic', 'plain', 'boring', 'dull',\n    'monochrome', 'grayscale', 'black and white', 'sepia',\n    \n    // 内容问题\n    'nsfw', 'nude', 'naked', 'explicit', 'sexual',\n    'violence', 'blood', 'gore', 'disturbing', 'scary',\n    'dark', 'horror', 'nightmare', 'creepy', 'evil',\n    \n    // 中文负向词\n    '最差质量', '糟糕质量', '低质量', '差质量',\n    '糟糕解剖', '变形', '畸形', '丑陋', '模糊',\n    '低分辨率', '像素化', '噪点', '伪影',\n    '水印', '签名', '文字', '标志', '用户名',\n    '多余的', '缺失的', '融合的', '重复的',\n    '业余', '草图', '未完成', '粗糙', '简单',\n    '单色', '灰度', '黑白', '暗色调'\n  ];\n  \n  // 检查是否包含负向关键词\n  const hasNegativeKeywords = negativeKeywords.some(keyword => \n    lowerText.includes(keyword.toLowerCase())\n  );\n  \n  // 检查负向提示词的比例\n  const negativeWordCount = negativeKeywords.filter(keyword => \n    lowerText.includes(keyword.toLowerCase())\n  ).length;\n  \n  const totalWords = text.split(/\\s+/).length;\n  const negativeRatio = negativeWordCount / totalWords;\n  \n  // 如果负向词汇比例超过30%，很可能是负向提示词\n  const isHighNegativeRatio = negativeRatio > 0.3;\n  \n  // 检查是否以负向词开头\n  const startsWithNegative = negativeKeywords.some(keyword => \n    lowerText.startsWith(keyword.toLowerCase())\n  );\n  \n  console.log(`🔍 负向检测: 关键词=${hasNegativeKeywords}, 比例=${negativeRatio.toFixed(2)}, 开头=${startsWithNegative}`);\n  \n  return hasNegativeKeywords || isHighNegativeRatio || startsWithNegative;\n}\n\n// 解析NovelAI数据\nfunction parseNovelAI(text) {\n  const result = {\n    positive: '',\n    negative: '',\n    parameters: {}\n  };\n\n  try {\n    const data = JSON.parse(text);\n    result.positive = data.prompt || '';\n    result.negative = data.uc || '';\n    \n    ['steps', 'scale', 'seed', 'sampler', 'width', 'height'].forEach(key => {\n      if (data[key] !== undefined) {\n        result.parameters[key] = data[key];\n      }\n    });\n  } catch (error) {\n    console.warn('NovelAI解析失败:', error);\n  }\n\n  return result;\n}\n\n// EXIF数据提取\nasync function extractFromEXIF(file) {\n  try {\n    // 动态导入exifr\n    const exifr = await import('exifr');\n    \n    const exifData = await exifr.parse(file, {\n      userComment: true,\n      imageDescription: true,\n      software: true\n    });\n\n    if (!exifData) return null;\n\n    return {\n      type: 'EXIF',\n      confidence: 'medium',\n      data: {\n        software: exifData.Software,\n        description: exifData.ImageDescription,\n        userComment: exifData.UserComment,\n        positive: exifData.UserComment || exifData.ImageDescription || '',\n        negative: '',\n        parameters: {}\n      }\n    };\n  } catch (error) {\n    console.warn('EXIF提取失败:', error);\n    return null;\n  }\n}\n\n// 标准化数据\nfunction standardizeData(extractedData) {\n  const standardized = {\n    generationTool: 'Unknown',\n    positive: '',\n    negative: '',\n    parameters: {}\n  };\n\n  // 优先级顺序\n  const sources = ['PNG', 'EXIF'];\n  \n  for (const source of sources) {\n    const data = extractedData[source];\n    if (!data) continue;\n\n    if (data.data.generationTool) {\n      standardized.generationTool = data.data.generationTool;\n    }\n\n    if (data.data.positive && !standardized.positive) {\n      standardized.positive = data.data.positive;\n    }\n\n    if (data.data.negative && !standardized.negative) {\n      standardized.negative = data.data.negative;\n    }\n\n    Object.assign(standardized.parameters, data.data.parameters || {});\n  }\n\n  return standardized;\n}\n\n// 导出主要函数\nexport const imageMetadataExtractor = {\n  extractMetadata\n};\n\nexport default imageMetadataExtractor; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}