{"ast":null,"code":"/**\n * ç®€åŒ–çš„å›¾åƒå…ƒæ•°æ®æå–å™¨\n * å‚è€ƒstable-diffusion-inspectorçš„å®ç°æ–¹å¼\n */\n\n// ä¸»è¦çš„æå–å‡½æ•°\nexport async function extractMetadata(file) {\n  console.log('ğŸš€ å¼€å§‹æå–å›¾åƒå…ƒæ•°æ®...');\n  const result = {\n    success: false,\n    filename: file.name,\n    extractedData: {},\n    standardizedData: null,\n    timestamp: new Date().toISOString()\n  };\n  try {\n    // åŸºæœ¬æ–‡ä»¶ä¿¡æ¯\n    result.basicInfo = {\n      size: file.size,\n      sizeFormatted: `${(file.size / 1024).toFixed(1)} KB`,\n      type: file.type,\n      lastModified: new Date(file.lastModified).toLocaleString()\n    };\n\n    // æ ¹æ®æ–‡ä»¶ç±»å‹é€‰æ‹©æå–æ–¹æ³•\n    if (file.type === 'image/png') {\n      const pngData = await extractFromPNG(file);\n      if (pngData) {\n        result.extractedData.PNG = pngData;\n      }\n    }\n\n    // å°è¯•EXIFæå–\n    try {\n      const exifData = await extractFromEXIF(file);\n      if (exifData) {\n        result.extractedData.EXIF = exifData;\n      }\n    } catch (error) {\n      console.warn('EXIFæå–å¤±è´¥:', error);\n    }\n\n    // æ ‡å‡†åŒ–æ•°æ®\n    result.standardizedData = standardizeData(result.extractedData);\n    result.success = Object.keys(result.extractedData).length > 0;\n\n    // æ·»åŠ æå–æ–¹æ³•ä¿¡æ¯\n    result.extractionMethods = Object.keys(result.extractedData).map(method => {\n      var _result$extractedData;\n      return {\n        method: method,\n        confidence: ((_result$extractedData = result.extractedData[method]) === null || _result$extractedData === void 0 ? void 0 : _result$extractedData.confidence) || 'unknown'\n      };\n    });\n    return result;\n  } catch (error) {\n    console.error('âŒ å…ƒæ•°æ®æå–å¤±è´¥:', error);\n    result.error = error.message;\n    throw error;\n  }\n}\n\n// PNGæ–‡ä»¶è§£æ - å‚è€ƒstable-diffusion-inspectorçš„ç®€æ´å®ç°\nasync function extractFromPNG(file) {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = e => {\n      try {\n        const buffer = e.target.result;\n        const chunks = parsePNGChunks(buffer);\n        const metadata = extractMetadataFromChunks(chunks);\n        resolve({\n          type: 'PNG',\n          confidence: metadata.confidence || 'medium',\n          data: metadata\n        });\n      } catch (error) {\n        console.warn('PNGè§£æå¤±è´¥:', error);\n        resolve(null);\n      }\n    };\n    reader.onerror = () => resolve(null);\n    reader.readAsArrayBuffer(file);\n  });\n}\n\n// ç®€åŒ–çš„PNGå—è§£æ\nfunction parsePNGChunks(buffer) {\n  const view = new DataView(buffer);\n  const chunks = [];\n  let offset = 8; // è·³è¿‡PNGç­¾å\n\n  // éªŒè¯PNGç­¾å\n  const signature = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A];\n  for (let i = 0; i < 8; i++) {\n    if (view.getUint8(i) !== signature[i]) {\n      throw new Error('ä¸æ˜¯æœ‰æ•ˆçš„PNGæ–‡ä»¶');\n    }\n  }\n  while (offset < buffer.byteLength - 8) {\n    try {\n      const length = view.getUint32(offset);\n      offset += 4;\n      const type = String.fromCharCode(view.getUint8(offset), view.getUint8(offset + 1), view.getUint8(offset + 2), view.getUint8(offset + 3));\n      offset += 4;\n      const data = new Uint8Array(buffer, offset, length);\n      offset += length;\n      const crc = view.getUint32(offset);\n      offset += 4;\n      chunks.push({\n        type,\n        length,\n        data,\n        crc\n      });\n      if (type === 'IEND') break;\n    } catch (error) {\n      console.warn('PNGå—è§£æè­¦å‘Š:', error);\n      break;\n    }\n  }\n  return chunks;\n}\n\n// ä»PNGå—æå–å…ƒæ•°æ®\nfunction extractMetadataFromChunks(chunks) {\n  const textChunks = chunks.filter(chunk => ['tEXt', 'iTXt', 'zTXt'].includes(chunk.type));\n  const metadata = {\n    confidence: 'low',\n    generationTool: 'Unknown',\n    positive: '',\n    negative: '',\n    parameters: {}\n  };\n  for (const chunk of textChunks) {\n    const textData = parseTextChunk(chunk);\n    if (!textData.keyword || !textData.text) continue;\n    console.log('è§£ææ–‡æœ¬å—:', textData.keyword, 'é•¿åº¦:', textData.text.length);\n\n    // æ£€æµ‹ä¸åŒæ ¼å¼\n    if (textData.keyword === 'parameters' && isAutomatic1111Format(textData.text)) {\n      const parsed = parseAutomatic1111(textData.text);\n      Object.assign(metadata, parsed);\n      metadata.generationTool = 'AUTOMATIC1111';\n      metadata.confidence = 'high';\n    } else if (['workflow', 'prompt'].includes(textData.keyword)) {\n      try {\n        const parsed = parseComfyUI(textData.text);\n        Object.assign(metadata, parsed);\n        metadata.generationTool = 'ComfyUI';\n        metadata.confidence = 'high';\n      } catch (error) {\n        console.warn('ComfyUIè§£æå¤±è´¥:', error);\n      }\n    } else if (['Description', 'Comment'].includes(textData.keyword)) {\n      try {\n        const parsed = parseNovelAI(textData.text);\n        Object.assign(metadata, parsed);\n        metadata.generationTool = 'NovelAI';\n        metadata.confidence = 'high';\n      } catch (error) {\n        console.warn('NovelAIè§£æå¤±è´¥:', error);\n      }\n    }\n  }\n  return metadata;\n}\n\n// è§£ææ–‡æœ¬å—\nfunction parseTextChunk(chunk) {\n  try {\n    const data = chunk.data;\n    if (chunk.type === 'tEXt') {\n      const nullIndex = data.indexOf(0);\n      if (nullIndex === -1) return {};\n      const keyword = decodeLatin1(data.slice(0, nullIndex));\n      const text = decodeLatin1(data.slice(nullIndex + 1));\n      return {\n        keyword,\n        text\n      };\n    }\n    if (chunk.type === 'iTXt') {\n      const nullIndices = [];\n      for (let i = 0; i < data.length; i++) {\n        if (data[i] === 0) {\n          nullIndices.push(i);\n          if (nullIndices.length >= 4) break;\n        }\n      }\n      if (nullIndices.length < 4) return {};\n      const keyword = decodeUTF8(data.slice(0, nullIndices[0]));\n      const text = decodeUTF8(data.slice(nullIndices[3] + 1));\n      return {\n        keyword,\n        text\n      };\n    }\n    return {};\n  } catch (error) {\n    console.warn('æ–‡æœ¬å—è§£æå¤±è´¥:', error);\n    return {};\n  }\n}\n\n// å®‰å…¨çš„å­—ç¬¦è§£ç \nfunction decodeLatin1(data) {\n  let result = '';\n  for (let i = 0; i < data.length; i++) {\n    result += String.fromCharCode(data[i]);\n  }\n  return result;\n}\nfunction decodeUTF8(data) {\n  try {\n    return new TextDecoder('utf-8', {\n      fatal: false\n    }).decode(data);\n  } catch (error) {\n    return decodeLatin1(data);\n  }\n}\n\n// æ£€æµ‹AUTOMATIC1111æ ¼å¼\nfunction isAutomatic1111Format(text) {\n  const lowerText = text.toLowerCase();\n  return lowerText.includes('steps:') || lowerText.includes('cfg scale:') || lowerText.includes('sampler:') || lowerText.includes('negative prompt:');\n}\n\n// è§£æAUTOMATIC1111æ•°æ®\nfunction parseAutomatic1111(text) {\n  const result = {\n    positive: '',\n    negative: '',\n    parameters: {}\n  };\n  try {\n    const negativeIndex = text.indexOf('Negative prompt:');\n    if (negativeIndex !== -1) {\n      result.positive = text.substring(0, negativeIndex).trim();\n      const afterNegative = text.substring(negativeIndex + 16);\n      const lines = afterNegative.split('\\n');\n      let negativePrompt = '';\n      let parameterLines = [];\n      let foundParams = false;\n      for (const line of lines) {\n        const trimmed = line.trim();\n        if (isParameterLine(trimmed)) {\n          foundParams = true;\n          parameterLines.push(trimmed);\n        } else if (!foundParams && trimmed) {\n          negativePrompt += (negativePrompt ? '\\n' : '') + trimmed;\n        } else if (foundParams) {\n          parameterLines.push(trimmed);\n        }\n      }\n      result.negative = negativePrompt.trim();\n      if (parameterLines.length > 0) {\n        result.parameters = parseParameters(parameterLines.join(', '));\n      }\n    } else {\n      // æ²¡æœ‰è´Ÿå‘æç¤ºè¯çš„æƒ…å†µ\n      const lines = text.split('\\n');\n      let positiveLines = [];\n      let parameterLines = [];\n      let foundParams = false;\n      for (const line of lines) {\n        const trimmed = line.trim();\n        if (isParameterLine(trimmed)) {\n          foundParams = true;\n          parameterLines.push(trimmed);\n        } else if (!foundParams && trimmed) {\n          positiveLines.push(trimmed);\n        } else if (foundParams) {\n          parameterLines.push(trimmed);\n        }\n      }\n      result.positive = positiveLines.join(' ').trim();\n      if (parameterLines.length > 0) {\n        result.parameters = parseParameters(parameterLines.join(', '));\n      }\n    }\n  } catch (error) {\n    console.warn('AUTOMATIC1111è§£æè­¦å‘Š:', error);\n    result.positive = text;\n  }\n  return result;\n}\n\n// æ£€æµ‹å‚æ•°è¡Œ\nfunction isParameterLine(line) {\n  return /\\b(Steps|Sampler|CFG scale|Seed|Size|Model):/i.test(line);\n}\n\n// è§£æå‚æ•°\nfunction parseParameters(paramText) {\n  const parameters = {};\n  const regex = /(\\w+(?:\\s+\\w+)*)\\s*:\\s*([^,]+?)(?=,\\s*\\w+\\s*:|$)/g;\n  let match;\n  while ((match = regex.exec(paramText)) !== null) {\n    const key = match[1].trim().toLowerCase().replace(/\\s+/g, '');\n    const value = match[2].trim();\n    const numValue = parseFloat(value);\n    parameters[key] = !isNaN(numValue) && isFinite(numValue) ? numValue : value;\n  }\n  return parameters;\n}\n\n// è§£æComfyUIæ•°æ®\nfunction parseComfyUI(text) {\n  const result = {\n    positive: '',\n    negative: '',\n    parameters: {}\n  };\n  try {\n    const data = JSON.parse(text);\n    if (Array.isArray(data === null || data === void 0 ? void 0 : data.nodes)) {\n      // å·¥ä½œæµæ ¼å¼\n      const prompts = extractFromComfyWorkflow(data);\n      result.positive = prompts.positive;\n      result.negative = prompts.negative;\n    } else if (typeof data === 'object') {\n      // æç¤ºæ ¼å¼\n      const prompts = extractFromComfyPrompt(data);\n      result.positive = prompts.positive;\n      result.negative = prompts.negative;\n    }\n  } catch (error) {\n    console.warn('ComfyUIè§£æå¤±è´¥:', error);\n  }\n  return result;\n}\n\n// ä»ComfyUIå·¥ä½œæµæå–\nfunction extractFromComfyWorkflow(workflow) {\n  var _workflow$nodes;\n  const positivePrompts = [];\n  const negativePrompts = [];\n  const parameters = {};\n  console.log('ğŸ” åˆ†æComfyUIå·¥ä½œæµï¼ŒèŠ‚ç‚¹æ•°é‡:', ((_workflow$nodes = workflow.nodes) === null || _workflow$nodes === void 0 ? void 0 : _workflow$nodes.length) || 0);\n  for (const node of workflow.nodes || []) {\n    console.log(`ğŸ“ æ£€æŸ¥èŠ‚ç‚¹: ${node.type} (${node.title || 'untitled'})`);\n\n    // æ‰©å±•æ”¯æŒçš„æ–‡æœ¬ç¼–ç èŠ‚ç‚¹ç±»å‹\n    const textEncoderTypes = ['CLIPTextEncode', 'CLIPTextEncodeSDXL', 'BNK_CLIPTextEncoder',\n    // BNKç³»åˆ—èŠ‚ç‚¹\n    'WeiLin-ComfyUI-prompt-all-in-one',\n    // WeiLinæ’ä»¶\n    'TIPO',\n    // TIPOèŠ‚ç‚¹\n    'PromptWithStyle',\n    // æ ·å¼æç¤ºè¯èŠ‚ç‚¹\n    'StringFunction',\n    // å­—ç¬¦ä¸²å¤„ç†èŠ‚ç‚¹\n    'Text',\n    // é€šç”¨æ–‡æœ¬èŠ‚ç‚¹\n    'TextInput',\n    // æ–‡æœ¬è¾“å…¥èŠ‚ç‚¹\n    'PromptBuilder',\n    // æç¤ºè¯æ„å»ºå™¨\n    'AdvancedCLIPTextEncode',\n    // é«˜çº§CLIPç¼–ç å™¨\n    'CLIPTextEncodeFlux',\n    // Fluxæ¨¡å‹ç¼–ç å™¨\n    'ShowText',\n    // æ˜¾ç¤ºæ–‡æœ¬èŠ‚ç‚¹\n    'StringConstant',\n    // å­—ç¬¦ä¸²å¸¸é‡\n    'MultilineStringLiteral' // å¤šè¡Œå­—ç¬¦ä¸²\n    ];\n    if (textEncoderTypes.includes(node.type)) {\n      console.log(`âœ… æ‰¾åˆ°æ–‡æœ¬ç¼–ç èŠ‚ç‚¹: ${node.type}`);\n\n      // å°è¯•å¤šç§æ–¹å¼è·å–æ–‡æœ¬å†…å®¹\n      let text = null;\n\n      // æ–¹å¼1: widgets_valuesæ•°ç»„\n      if (node.widgets_values && Array.isArray(node.widgets_values)) {\n        for (const value of node.widgets_values) {\n          if (typeof value === 'string' && value.trim().length > 0) {\n            text = value.trim();\n            console.log(`ğŸ“„ ä»widgets_valuesè·å–æ–‡æœ¬: ${text.substring(0, 50)}...`);\n            break;\n          }\n        }\n      }\n\n      // æ–¹å¼2: ç›´æ¥çš„textå±æ€§\n      if (!text && node.text && typeof node.text === 'string') {\n        text = node.text.trim();\n        console.log(`ğŸ“„ ä»textå±æ€§è·å–æ–‡æœ¬: ${text.substring(0, 50)}...`);\n      }\n\n      // æ–¹å¼3: inputsä¸­çš„text\n      if (!text && node.inputs) {\n        for (const input of node.inputs) {\n          if (input.name === 'text' && input.widget && input.widget.value) {\n            text = input.widget.value.trim();\n            console.log(`ğŸ“„ ä»inputsè·å–æ–‡æœ¬: ${text.substring(0, 50)}...`);\n            break;\n          }\n        }\n      }\n\n      // æ–¹å¼4: propertiesä¸­æŸ¥æ‰¾\n      if (!text && node.properties) {\n        if (node.properties.text) {\n          text = node.properties.text.trim();\n          console.log(`ğŸ“„ ä»propertiesè·å–æ–‡æœ¬: ${text.substring(0, 50)}...`);\n        }\n      }\n      if (text && text.length > 0) {\n        var _node$title, _node$title2, _node$title3;\n        // æ™ºèƒ½åˆ¤æ–­æ˜¯å¦ä¸ºè´Ÿå‘æç¤ºè¯\n        const isNegative = isNegativePrompt(text) || ((_node$title = node.title) === null || _node$title === void 0 ? void 0 : _node$title.toLowerCase().includes('negative')) || ((_node$title2 = node.title) === null || _node$title2 === void 0 ? void 0 : _node$title2.toLowerCase().includes('è´Ÿå‘')) || ((_node$title3 = node.title) === null || _node$title3 === void 0 ? void 0 : _node$title3.toLowerCase().includes('åå‘')) || node.color && (node.color === '#ff6b6b' || node.color === '#e74c3c'); // çº¢è‰²é€šå¸¸è¡¨ç¤ºè´Ÿå‘\n\n        if (isNegative) {\n          negativePrompts.push(text);\n          console.log(`â– è¯†åˆ«ä¸ºè´Ÿå‘æç¤ºè¯: ${text.substring(0, 30)}...`);\n        } else {\n          positivePrompts.push(text);\n          console.log(`â• è¯†åˆ«ä¸ºæ­£å‘æç¤ºè¯: ${text.substring(0, 30)}...`);\n        }\n      }\n    }\n\n    // æå–é‡‡æ ·å™¨å‚æ•°\n    if (['KSampler', 'KSamplerAdvanced', 'SamplerCustom'].includes(node.type)) {\n      if (node.widgets_values) {\n        const [seed, steps, cfg, sampler_name, scheduler, denoise] = node.widgets_values;\n        if (seed !== undefined) parameters.seed = seed;\n        if (steps !== undefined) parameters.steps = steps;\n        if (cfg !== undefined) parameters.cfg_scale = cfg;\n        if (sampler_name !== undefined) parameters.sampler = sampler_name;\n        if (scheduler !== undefined) parameters.scheduler = scheduler;\n        if (denoise !== undefined) parameters.denoise = denoise;\n        console.log(`âš™ï¸ æå–é‡‡æ ·å™¨å‚æ•°: steps=${steps}, cfg=${cfg}, sampler=${sampler_name}`);\n      }\n    }\n\n    // æå–æ¨¡å‹ä¿¡æ¯\n    if (['CheckpointLoaderSimple', 'CheckpointLoader'].includes(node.type)) {\n      if (node.widgets_values && node.widgets_values[0]) {\n        parameters.model = node.widgets_values[0];\n        console.log(`ğŸ¯ æå–æ¨¡å‹: ${parameters.model}`);\n      }\n    }\n\n    // æå–å›¾åƒå°ºå¯¸\n    if (['EmptyLatentImage', 'LatentUpscale'].includes(node.type)) {\n      if (node.widgets_values) {\n        const [width, height] = node.widgets_values;\n        if (width !== undefined) parameters.width = width;\n        if (height !== undefined) parameters.height = height;\n        console.log(`ğŸ“ æå–å°ºå¯¸: ${width}x${height}`);\n      }\n    }\n  }\n\n  // æ™ºèƒ½åˆå¹¶æç¤ºè¯\n  const finalPositive = smartMergePrompts(positivePrompts);\n  const finalNegative = smartMergePrompts(negativePrompts);\n  console.log(`ğŸ¯ æœ€ç»ˆç»“æœ: æ­£å‘æç¤ºè¯${finalPositive.length}å­—ç¬¦, è´Ÿå‘æç¤ºè¯${finalNegative.length}å­—ç¬¦`);\n  return {\n    positive: finalPositive,\n    negative: finalNegative,\n    parameters\n  };\n}\n\n// æ™ºèƒ½åˆå¹¶æç¤ºè¯\nfunction smartMergePrompts(prompts) {\n  if (prompts.length === 0) return '';\n  if (prompts.length === 1) return prompts[0];\n\n  // å»é‡å¹¶æŒ‰é•¿åº¦æ’åºï¼Œä¼˜å…ˆé€‰æ‹©æ›´å®Œæ•´çš„æç¤ºè¯\n  const uniquePrompts = [...new Set(prompts)];\n  uniquePrompts.sort((a, b) => b.length - a.length);\n\n  // å¦‚æœæœ€é•¿çš„æç¤ºè¯æ˜æ˜¾æ¯”å…¶ä»–çš„é•¿å¾ˆå¤šï¼Œå¯èƒ½æ˜¯æœ€ç»ˆåˆæˆçš„ç»“æœ\n  const longest = uniquePrompts[0];\n  const secondLongest = uniquePrompts[1] || '';\n  if (longest.length > secondLongest.length * 2) {\n    console.log(`ğŸ¯ é€‰æ‹©æœ€é•¿æç¤ºè¯ä½œä¸ºæœ€ç»ˆç»“æœ: ${longest.length} vs ${secondLongest.length}`);\n    return longest;\n  }\n\n  // å¦åˆ™åˆå¹¶æ‰€æœ‰å”¯ä¸€çš„æç¤ºè¯\n  return uniquePrompts.join(', ');\n}\n\n// ä»ComfyUIæç¤ºæå–\nfunction extractFromComfyPrompt(prompt) {\n  const positivePrompts = [];\n  const negativePrompts = [];\n  const parameters = {};\n  console.log('ğŸ” åˆ†æComfyUIæç¤ºæ ¼å¼ï¼ŒèŠ‚ç‚¹æ•°é‡:', Object.keys(prompt).length);\n  for (const [nodeId, nodeData] of Object.entries(prompt)) {\n    console.log(`ğŸ“ æ£€æŸ¥èŠ‚ç‚¹ ${nodeId}: ${nodeData.class_type}`);\n\n    // æ‰©å±•æ”¯æŒçš„èŠ‚ç‚¹ç±»å‹\n    const textEncoderTypes = ['CLIPTextEncode', 'CLIPTextEncodeSDXL', 'BNK_CLIPTextEncoder', 'WeiLin-ComfyUI-prompt-all-in-one', 'TIPO', 'PromptWithStyle', 'StringFunction', 'Text', 'TextInput', 'PromptBuilder', 'AdvancedCLIPTextEncode', 'CLIPTextEncodeFlux', 'ShowText', 'StringConstant', 'MultilineStringLiteral'];\n    if (textEncoderTypes.includes(nodeData.class_type)) {\n      var _nodeData$inputs, _nodeData$inputs2, _nodeData$inputs3;\n      console.log(`âœ… æ‰¾åˆ°æ–‡æœ¬ç¼–ç èŠ‚ç‚¹: ${nodeData.class_type}`);\n\n      // å°è¯•å¤šç§æ–¹å¼è·å–æ–‡æœ¬\n      let text = null;\n      if ((_nodeData$inputs = nodeData.inputs) !== null && _nodeData$inputs !== void 0 && _nodeData$inputs.text && typeof nodeData.inputs.text === 'string') {\n        text = nodeData.inputs.text.trim();\n        console.log(`ğŸ“„ ä»inputs.textè·å–: ${text.substring(0, 50)}...`);\n      } else if ((_nodeData$inputs2 = nodeData.inputs) !== null && _nodeData$inputs2 !== void 0 && _nodeData$inputs2.prompt && typeof nodeData.inputs.prompt === 'string') {\n        text = nodeData.inputs.prompt.trim();\n        console.log(`ğŸ“„ ä»inputs.promptè·å–: ${text.substring(0, 50)}...`);\n      } else if ((_nodeData$inputs3 = nodeData.inputs) !== null && _nodeData$inputs3 !== void 0 && _nodeData$inputs3.string && typeof nodeData.inputs.string === 'string') {\n        text = nodeData.inputs.string.trim();\n        console.log(`ğŸ“„ ä»inputs.stringè·å–: ${text.substring(0, 50)}...`);\n      }\n      if (text && text.length > 0) {\n        if (isNegativePrompt(text)) {\n          negativePrompts.push(text);\n          console.log(`â– è¯†åˆ«ä¸ºè´Ÿå‘æç¤ºè¯`);\n        } else {\n          positivePrompts.push(text);\n          console.log(`â• è¯†åˆ«ä¸ºæ­£å‘æç¤ºè¯`);\n        }\n      }\n    }\n\n    // æå–å…¶ä»–å‚æ•°...\n    if (['KSampler', 'KSamplerAdvanced', 'SamplerCustom'].includes(nodeData.class_type)) {\n      const inputs = nodeData.inputs;\n      if (inputs.seed !== undefined) parameters.seed = inputs.seed;\n      if (inputs.steps !== undefined) parameters.steps = inputs.steps;\n      if (inputs.cfg !== undefined) parameters.cfg_scale = inputs.cfg;\n      if (inputs.sampler_name !== undefined) parameters.sampler = inputs.sampler_name;\n      if (inputs.scheduler !== undefined) parameters.scheduler = inputs.scheduler;\n      if (inputs.denoise !== undefined) parameters.denoise = inputs.denoise;\n    }\n  }\n  const finalPositive = smartMergePrompts(positivePrompts);\n  const finalNegative = smartMergePrompts(negativePrompts);\n  console.log(`ğŸ¯ æœ€ç»ˆç»“æœ: æ­£å‘æç¤ºè¯${finalPositive.length}å­—ç¬¦, è´Ÿå‘æç¤ºè¯${finalNegative.length}å­—ç¬¦`);\n  return {\n    positive: finalPositive,\n    negative: finalNegative,\n    parameters\n  };\n}\n\n// æ£€æµ‹è´Ÿå‘æç¤ºè¯\nfunction isNegativePrompt(text) {\n  const lowerText = text.toLowerCase();\n\n  // æ‰©å±•è´Ÿå‘å…³é”®è¯åˆ—è¡¨\n  const negativeKeywords = [\n  // è´¨é‡ç›¸å…³\n  'worst quality', 'bad quality', 'low quality', 'poor quality', 'bad anatomy', 'bad proportions', 'bad hands', 'bad fingers', 'ugly', 'deformed', 'disfigured', 'mutated', 'malformed', 'blurry', 'blur', 'out of focus', 'unfocused', 'soft focus', 'lowres', 'low resolution', 'pixelated', 'jpeg artifacts',\n  // æŠ€æœ¯é—®é¢˜\n  'error', 'glitch', 'artifact', 'noise', 'grain', 'distorted', 'cropped', 'cut off', 'truncated', 'incomplete', 'watermark', 'signature', 'text', 'logo', 'username', 'border', 'frame', 'black bars', 'letterbox',\n  // è§£å‰–é—®é¢˜\n  'extra limbs', 'missing limbs', 'extra fingers', 'missing fingers', 'extra arms', 'extra legs', 'fused fingers', 'too many fingers', 'long neck', 'long body', 'elongated', 'stretched', 'duplicate', 'multiple', 'conjoined', 'merged',\n  // é£æ ¼é—®é¢˜\n  'amateur', 'sketch', 'draft', 'unfinished', 'rough', 'simple', 'basic', 'plain', 'boring', 'dull', 'monochrome', 'grayscale', 'black and white', 'sepia',\n  // å†…å®¹é—®é¢˜\n  'nsfw', 'nude', 'naked', 'explicit', 'sexual', 'violence', 'blood', 'gore', 'disturbing', 'scary', 'dark', 'horror', 'nightmare', 'creepy', 'evil',\n  // ä¸­æ–‡è´Ÿå‘è¯\n  'æœ€å·®è´¨é‡', 'ç³Ÿç³•è´¨é‡', 'ä½è´¨é‡', 'å·®è´¨é‡', 'ç³Ÿç³•è§£å‰–', 'å˜å½¢', 'ç•¸å½¢', 'ä¸‘é™‹', 'æ¨¡ç³Š', 'ä½åˆ†è¾¨ç‡', 'åƒç´ åŒ–', 'å™ªç‚¹', 'ä¼ªå½±', 'æ°´å°', 'ç­¾å', 'æ–‡å­—', 'æ ‡å¿—', 'ç”¨æˆ·å', 'å¤šä½™çš„', 'ç¼ºå¤±çš„', 'èåˆçš„', 'é‡å¤çš„', 'ä¸šä½™', 'è‰å›¾', 'æœªå®Œæˆ', 'ç²—ç³™', 'ç®€å•', 'å•è‰²', 'ç°åº¦', 'é»‘ç™½', 'æš—è‰²è°ƒ'];\n\n  // æ£€æŸ¥æ˜¯å¦åŒ…å«è´Ÿå‘å…³é”®è¯\n  const hasNegativeKeywords = negativeKeywords.some(keyword => lowerText.includes(keyword.toLowerCase()));\n\n  // æ£€æŸ¥è´Ÿå‘æç¤ºè¯çš„æ¯”ä¾‹\n  const negativeWordCount = negativeKeywords.filter(keyword => lowerText.includes(keyword.toLowerCase())).length;\n  const totalWords = text.split(/\\s+/).length;\n  const negativeRatio = negativeWordCount / totalWords;\n\n  // å¦‚æœè´Ÿå‘è¯æ±‡æ¯”ä¾‹è¶…è¿‡30%ï¼Œå¾ˆå¯èƒ½æ˜¯è´Ÿå‘æç¤ºè¯\n  const isHighNegativeRatio = negativeRatio > 0.3;\n\n  // æ£€æŸ¥æ˜¯å¦ä»¥è´Ÿå‘è¯å¼€å¤´\n  const startsWithNegative = negativeKeywords.some(keyword => lowerText.startsWith(keyword.toLowerCase()));\n  console.log(`ğŸ” è´Ÿå‘æ£€æµ‹: å…³é”®è¯=${hasNegativeKeywords}, æ¯”ä¾‹=${negativeRatio.toFixed(2)}, å¼€å¤´=${startsWithNegative}`);\n  return hasNegativeKeywords || isHighNegativeRatio || startsWithNegative;\n}\n\n// è§£æNovelAIæ•°æ®\nfunction parseNovelAI(text) {\n  const result = {\n    positive: '',\n    negative: '',\n    parameters: {}\n  };\n  try {\n    const data = JSON.parse(text);\n    result.positive = data.prompt || '';\n    result.negative = data.uc || '';\n    ['steps', 'scale', 'seed', 'sampler', 'width', 'height'].forEach(key => {\n      if (data[key] !== undefined) {\n        result.parameters[key] = data[key];\n      }\n    });\n  } catch (error) {\n    console.warn('NovelAIè§£æå¤±è´¥:', error);\n  }\n  return result;\n}\n\n// EXIFæ•°æ®æå–\nasync function extractFromEXIF(file) {\n  try {\n    // åŠ¨æ€å¯¼å…¥exifr\n    const exifr = await import('exifr');\n    const exifData = await exifr.parse(file, {\n      userComment: true,\n      imageDescription: true,\n      software: true\n    });\n    if (!exifData) return null;\n    return {\n      type: 'EXIF',\n      confidence: 'medium',\n      data: {\n        software: exifData.Software,\n        description: exifData.ImageDescription,\n        userComment: exifData.UserComment,\n        positive: exifData.UserComment || exifData.ImageDescription || '',\n        negative: '',\n        parameters: {}\n      }\n    };\n  } catch (error) {\n    console.warn('EXIFæå–å¤±è´¥:', error);\n    return null;\n  }\n}\n\n// æ ‡å‡†åŒ–æ•°æ®\nfunction standardizeData(extractedData) {\n  const standardized = {\n    generationTool: 'Unknown',\n    positive: '',\n    negative: '',\n    parameters: {}\n  };\n\n  // ä¼˜å…ˆçº§é¡ºåº\n  const sources = ['PNG', 'EXIF'];\n  for (const source of sources) {\n    const data = extractedData[source];\n    if (!data) continue;\n    if (data.data.generationTool) {\n      standardized.generationTool = data.data.generationTool;\n    }\n    if (data.data.positive && !standardized.positive) {\n      standardized.positive = data.data.positive;\n    }\n    if (data.data.negative && !standardized.negative) {\n      standardized.negative = data.data.negative;\n    }\n    Object.assign(standardized.parameters, data.data.parameters || {});\n  }\n  return standardized;\n}\n\n// å¯¼å‡ºä¸»è¦å‡½æ•°\nexport const imageMetadataExtractor = {\n  extractMetadata\n};\nexport default imageMetadataExtractor;","map":{"version":3,"names":["extractMetadata","file","console","log","result","success","filename","name","extractedData","standardizedData","timestamp","Date","toISOString","basicInfo","size","sizeFormatted","toFixed","type","lastModified","toLocaleString","pngData","extractFromPNG","PNG","exifData","extractFromEXIF","EXIF","error","warn","standardizeData","Object","keys","length","extractionMethods","map","method","_result$extractedData","confidence","message","Promise","resolve","reject","reader","FileReader","onload","e","buffer","target","chunks","parsePNGChunks","metadata","extractMetadataFromChunks","data","onerror","readAsArrayBuffer","view","DataView","offset","signature","i","getUint8","Error","byteLength","getUint32","String","fromCharCode","Uint8Array","crc","push","textChunks","filter","chunk","includes","generationTool","positive","negative","parameters","textData","parseTextChunk","keyword","text","isAutomatic1111Format","parsed","parseAutomatic1111","assign","parseComfyUI","parseNovelAI","nullIndex","indexOf","decodeLatin1","slice","nullIndices","decodeUTF8","TextDecoder","fatal","decode","lowerText","toLowerCase","negativeIndex","substring","trim","afterNegative","lines","split","negativePrompt","parameterLines","foundParams","line","trimmed","isParameterLine","parseParameters","join","positiveLines","test","paramText","regex","match","exec","key","replace","value","numValue","parseFloat","isNaN","isFinite","JSON","parse","Array","isArray","nodes","prompts","extractFromComfyWorkflow","extractFromComfyPrompt","workflow","_workflow$nodes","positivePrompts","negativePrompts","node","title","textEncoderTypes","widgets_values","inputs","input","widget","properties","_node$title","_node$title2","_node$title3","isNegative","isNegativePrompt","color","seed","steps","cfg","sampler_name","scheduler","denoise","undefined","cfg_scale","sampler","model","width","height","finalPositive","smartMergePrompts","finalNegative","uniquePrompts","Set","sort","a","b","longest","secondLongest","prompt","nodeId","nodeData","entries","class_type","_nodeData$inputs","_nodeData$inputs2","_nodeData$inputs3","string","negativeKeywords","hasNegativeKeywords","some","negativeWordCount","totalWords","negativeRatio","isHighNegativeRatio","startsWithNegative","startsWith","uc","forEach","exifr","userComment","imageDescription","software","Software","description","ImageDescription","UserComment","standardized","sources","source","imageMetadataExtractor"],"sources":["C:/Users/wjx19/Documents/GitHub/I-Prompt/src/utils/imageMetadataExtractor.js"],"sourcesContent":["/**\n * ç®€åŒ–çš„å›¾åƒå…ƒæ•°æ®æå–å™¨\n * å‚è€ƒstable-diffusion-inspectorçš„å®ç°æ–¹å¼\n */\n\n// ä¸»è¦çš„æå–å‡½æ•°\nexport async function extractMetadata(file) {\n  console.log('ğŸš€ å¼€å§‹æå–å›¾åƒå…ƒæ•°æ®...');\n  \n  const result = {\n    success: false,\n    filename: file.name,\n    extractedData: {},\n    standardizedData: null,\n    timestamp: new Date().toISOString()\n  };\n\n  try {\n    // åŸºæœ¬æ–‡ä»¶ä¿¡æ¯\n    result.basicInfo = {\n      size: file.size,\n      sizeFormatted: `${(file.size / 1024).toFixed(1)} KB`,\n      type: file.type,\n      lastModified: new Date(file.lastModified).toLocaleString()\n    };\n\n    // æ ¹æ®æ–‡ä»¶ç±»å‹é€‰æ‹©æå–æ–¹æ³•\n    if (file.type === 'image/png') {\n      const pngData = await extractFromPNG(file);\n      if (pngData) {\n        result.extractedData.PNG = pngData;\n      }\n    }\n\n    // å°è¯•EXIFæå–\n    try {\n      const exifData = await extractFromEXIF(file);\n      if (exifData) {\n        result.extractedData.EXIF = exifData;\n      }\n    } catch (error) {\n      console.warn('EXIFæå–å¤±è´¥:', error);\n    }\n\n    // æ ‡å‡†åŒ–æ•°æ®\n    result.standardizedData = standardizeData(result.extractedData);\n    result.success = Object.keys(result.extractedData).length > 0;\n\n    // æ·»åŠ æå–æ–¹æ³•ä¿¡æ¯\n    result.extractionMethods = Object.keys(result.extractedData).map(method => ({\n      method: method,\n      confidence: result.extractedData[method]?.confidence || 'unknown'\n    }));\n\n    return result;\n    \n  } catch (error) {\n    console.error('âŒ å…ƒæ•°æ®æå–å¤±è´¥:', error);\n    result.error = error.message;\n    throw error;\n  }\n}\n\n// PNGæ–‡ä»¶è§£æ - å‚è€ƒstable-diffusion-inspectorçš„ç®€æ´å®ç°\nasync function extractFromPNG(file) {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    \n    reader.onload = (e) => {\n      try {\n        const buffer = e.target.result;\n        const chunks = parsePNGChunks(buffer);\n        const metadata = extractMetadataFromChunks(chunks);\n        \n        resolve({\n          type: 'PNG',\n          confidence: metadata.confidence || 'medium',\n          data: metadata\n        });\n      } catch (error) {\n        console.warn('PNGè§£æå¤±è´¥:', error);\n        resolve(null);\n      }\n    };\n    \n    reader.onerror = () => resolve(null);\n    reader.readAsArrayBuffer(file);\n  });\n}\n\n// ç®€åŒ–çš„PNGå—è§£æ\nfunction parsePNGChunks(buffer) {\n  const view = new DataView(buffer);\n  const chunks = [];\n  let offset = 8; // è·³è¿‡PNGç­¾å\n\n  // éªŒè¯PNGç­¾å\n  const signature = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A];\n  for (let i = 0; i < 8; i++) {\n    if (view.getUint8(i) !== signature[i]) {\n      throw new Error('ä¸æ˜¯æœ‰æ•ˆçš„PNGæ–‡ä»¶');\n    }\n  }\n\n  while (offset < buffer.byteLength - 8) {\n    try {\n      const length = view.getUint32(offset);\n      offset += 4;\n\n      const type = String.fromCharCode(\n        view.getUint8(offset),\n        view.getUint8(offset + 1),\n        view.getUint8(offset + 2),\n        view.getUint8(offset + 3)\n      );\n      offset += 4;\n\n      const data = new Uint8Array(buffer, offset, length);\n      offset += length;\n\n      const crc = view.getUint32(offset);\n      offset += 4;\n\n      chunks.push({ type, length, data, crc });\n\n      if (type === 'IEND') break;\n    } catch (error) {\n      console.warn('PNGå—è§£æè­¦å‘Š:', error);\n      break;\n    }\n  }\n\n  return chunks;\n}\n\n// ä»PNGå—æå–å…ƒæ•°æ®\nfunction extractMetadataFromChunks(chunks) {\n  const textChunks = chunks.filter(chunk => \n    ['tEXt', 'iTXt', 'zTXt'].includes(chunk.type)\n  );\n\n  const metadata = {\n    confidence: 'low',\n    generationTool: 'Unknown',\n    positive: '',\n    negative: '',\n    parameters: {}\n  };\n\n  for (const chunk of textChunks) {\n    const textData = parseTextChunk(chunk);\n    if (!textData.keyword || !textData.text) continue;\n\n    console.log('è§£ææ–‡æœ¬å—:', textData.keyword, 'é•¿åº¦:', textData.text.length);\n\n    // æ£€æµ‹ä¸åŒæ ¼å¼\n    if (textData.keyword === 'parameters' && isAutomatic1111Format(textData.text)) {\n      const parsed = parseAutomatic1111(textData.text);\n      Object.assign(metadata, parsed);\n      metadata.generationTool = 'AUTOMATIC1111';\n      metadata.confidence = 'high';\n    } else if (['workflow', 'prompt'].includes(textData.keyword)) {\n      try {\n        const parsed = parseComfyUI(textData.text);\n        Object.assign(metadata, parsed);\n        metadata.generationTool = 'ComfyUI';\n        metadata.confidence = 'high';\n      } catch (error) {\n        console.warn('ComfyUIè§£æå¤±è´¥:', error);\n      }\n    } else if (['Description', 'Comment'].includes(textData.keyword)) {\n      try {\n        const parsed = parseNovelAI(textData.text);\n        Object.assign(metadata, parsed);\n        metadata.generationTool = 'NovelAI';\n        metadata.confidence = 'high';\n      } catch (error) {\n        console.warn('NovelAIè§£æå¤±è´¥:', error);\n      }\n    }\n  }\n\n  return metadata;\n}\n\n// è§£ææ–‡æœ¬å—\nfunction parseTextChunk(chunk) {\n  try {\n    const data = chunk.data;\n    \n    if (chunk.type === 'tEXt') {\n      const nullIndex = data.indexOf(0);\n      if (nullIndex === -1) return {};\n\n      const keyword = decodeLatin1(data.slice(0, nullIndex));\n      const text = decodeLatin1(data.slice(nullIndex + 1));\n      return { keyword, text };\n    }\n    \n    if (chunk.type === 'iTXt') {\n      const nullIndices = [];\n      for (let i = 0; i < data.length; i++) {\n        if (data[i] === 0) {\n          nullIndices.push(i);\n          if (nullIndices.length >= 4) break;\n        }\n      }\n\n      if (nullIndices.length < 4) return {};\n\n      const keyword = decodeUTF8(data.slice(0, nullIndices[0]));\n      const text = decodeUTF8(data.slice(nullIndices[3] + 1));\n      return { keyword, text };\n    }\n    \n    return {};\n  } catch (error) {\n    console.warn('æ–‡æœ¬å—è§£æå¤±è´¥:', error);\n    return {};\n  }\n}\n\n// å®‰å…¨çš„å­—ç¬¦è§£ç \nfunction decodeLatin1(data) {\n  let result = '';\n  for (let i = 0; i < data.length; i++) {\n    result += String.fromCharCode(data[i]);\n  }\n  return result;\n}\n\nfunction decodeUTF8(data) {\n  try {\n    return new TextDecoder('utf-8', { fatal: false }).decode(data);\n  } catch (error) {\n    return decodeLatin1(data);\n  }\n}\n\n// æ£€æµ‹AUTOMATIC1111æ ¼å¼\nfunction isAutomatic1111Format(text) {\n  const lowerText = text.toLowerCase();\n  return lowerText.includes('steps:') || \n         lowerText.includes('cfg scale:') || \n         lowerText.includes('sampler:') || \n         lowerText.includes('negative prompt:');\n}\n\n// è§£æAUTOMATIC1111æ•°æ®\nfunction parseAutomatic1111(text) {\n  const result = {\n    positive: '',\n    negative: '',\n    parameters: {}\n  };\n\n  try {\n    const negativeIndex = text.indexOf('Negative prompt:');\n    \n    if (negativeIndex !== -1) {\n      result.positive = text.substring(0, negativeIndex).trim();\n      \n      const afterNegative = text.substring(negativeIndex + 16);\n      const lines = afterNegative.split('\\n');\n      \n      let negativePrompt = '';\n      let parameterLines = [];\n      let foundParams = false;\n      \n      for (const line of lines) {\n        const trimmed = line.trim();\n        if (isParameterLine(trimmed)) {\n          foundParams = true;\n          parameterLines.push(trimmed);\n        } else if (!foundParams && trimmed) {\n          negativePrompt += (negativePrompt ? '\\n' : '') + trimmed;\n        } else if (foundParams) {\n          parameterLines.push(trimmed);\n        }\n      }\n      \n      result.negative = negativePrompt.trim();\n      \n      if (parameterLines.length > 0) {\n        result.parameters = parseParameters(parameterLines.join(', '));\n      }\n    } else {\n      // æ²¡æœ‰è´Ÿå‘æç¤ºè¯çš„æƒ…å†µ\n      const lines = text.split('\\n');\n      let positiveLines = [];\n      let parameterLines = [];\n      let foundParams = false;\n      \n      for (const line of lines) {\n        const trimmed = line.trim();\n        if (isParameterLine(trimmed)) {\n          foundParams = true;\n          parameterLines.push(trimmed);\n        } else if (!foundParams && trimmed) {\n          positiveLines.push(trimmed);\n        } else if (foundParams) {\n          parameterLines.push(trimmed);\n        }\n      }\n      \n      result.positive = positiveLines.join(' ').trim();\n      \n      if (parameterLines.length > 0) {\n        result.parameters = parseParameters(parameterLines.join(', '));\n      }\n    }\n  } catch (error) {\n    console.warn('AUTOMATIC1111è§£æè­¦å‘Š:', error);\n    result.positive = text;\n  }\n\n  return result;\n}\n\n// æ£€æµ‹å‚æ•°è¡Œ\nfunction isParameterLine(line) {\n  return /\\b(Steps|Sampler|CFG scale|Seed|Size|Model):/i.test(line);\n}\n\n// è§£æå‚æ•°\nfunction parseParameters(paramText) {\n  const parameters = {};\n  const regex = /(\\w+(?:\\s+\\w+)*)\\s*:\\s*([^,]+?)(?=,\\s*\\w+\\s*:|$)/g;\n  let match;\n\n  while ((match = regex.exec(paramText)) !== null) {\n    const key = match[1].trim().toLowerCase().replace(/\\s+/g, '');\n    const value = match[2].trim();\n    \n    const numValue = parseFloat(value);\n    parameters[key] = !isNaN(numValue) && isFinite(numValue) ? numValue : value;\n  }\n\n  return parameters;\n}\n\n// è§£æComfyUIæ•°æ®\nfunction parseComfyUI(text) {\n  const result = {\n    positive: '',\n    negative: '',\n    parameters: {}\n  };\n\n  try {\n    const data = JSON.parse(text);\n    \n    if (Array.isArray(data?.nodes)) {\n      // å·¥ä½œæµæ ¼å¼\n      const prompts = extractFromComfyWorkflow(data);\n      result.positive = prompts.positive;\n      result.negative = prompts.negative;\n    } else if (typeof data === 'object') {\n      // æç¤ºæ ¼å¼\n      const prompts = extractFromComfyPrompt(data);\n      result.positive = prompts.positive;\n      result.negative = prompts.negative;\n    }\n  } catch (error) {\n    console.warn('ComfyUIè§£æå¤±è´¥:', error);\n  }\n\n  return result;\n}\n\n// ä»ComfyUIå·¥ä½œæµæå–\nfunction extractFromComfyWorkflow(workflow) {\n  const positivePrompts = [];\n  const negativePrompts = [];\n  const parameters = {};\n\n  console.log('ğŸ” åˆ†æComfyUIå·¥ä½œæµï¼ŒèŠ‚ç‚¹æ•°é‡:', workflow.nodes?.length || 0);\n\n  for (const node of workflow.nodes || []) {\n    console.log(`ğŸ“ æ£€æŸ¥èŠ‚ç‚¹: ${node.type} (${node.title || 'untitled'})`);\n    \n    // æ‰©å±•æ”¯æŒçš„æ–‡æœ¬ç¼–ç èŠ‚ç‚¹ç±»å‹\n    const textEncoderTypes = [\n      'CLIPTextEncode', \n      'CLIPTextEncodeSDXL',\n      'BNK_CLIPTextEncoder',  // BNKç³»åˆ—èŠ‚ç‚¹\n      'WeiLin-ComfyUI-prompt-all-in-one',  // WeiLinæ’ä»¶\n      'TIPO',  // TIPOèŠ‚ç‚¹\n      'PromptWithStyle',  // æ ·å¼æç¤ºè¯èŠ‚ç‚¹\n      'StringFunction',  // å­—ç¬¦ä¸²å¤„ç†èŠ‚ç‚¹\n      'Text',  // é€šç”¨æ–‡æœ¬èŠ‚ç‚¹\n      'TextInput',  // æ–‡æœ¬è¾“å…¥èŠ‚ç‚¹\n      'PromptBuilder',  // æç¤ºè¯æ„å»ºå™¨\n      'AdvancedCLIPTextEncode',  // é«˜çº§CLIPç¼–ç å™¨\n      'CLIPTextEncodeFlux',  // Fluxæ¨¡å‹ç¼–ç å™¨\n      'ShowText',  // æ˜¾ç¤ºæ–‡æœ¬èŠ‚ç‚¹\n      'StringConstant',  // å­—ç¬¦ä¸²å¸¸é‡\n      'MultilineStringLiteral'  // å¤šè¡Œå­—ç¬¦ä¸²\n    ];\n\n    if (textEncoderTypes.includes(node.type)) {\n      console.log(`âœ… æ‰¾åˆ°æ–‡æœ¬ç¼–ç èŠ‚ç‚¹: ${node.type}`);\n      \n      // å°è¯•å¤šç§æ–¹å¼è·å–æ–‡æœ¬å†…å®¹\n      let text = null;\n      \n      // æ–¹å¼1: widgets_valuesæ•°ç»„\n      if (node.widgets_values && Array.isArray(node.widgets_values)) {\n        for (const value of node.widgets_values) {\n          if (typeof value === 'string' && value.trim().length > 0) {\n            text = value.trim();\n            console.log(`ğŸ“„ ä»widgets_valuesè·å–æ–‡æœ¬: ${text.substring(0, 50)}...`);\n            break;\n          }\n        }\n      }\n      \n      // æ–¹å¼2: ç›´æ¥çš„textå±æ€§\n      if (!text && node.text && typeof node.text === 'string') {\n        text = node.text.trim();\n        console.log(`ğŸ“„ ä»textå±æ€§è·å–æ–‡æœ¬: ${text.substring(0, 50)}...`);\n      }\n      \n      // æ–¹å¼3: inputsä¸­çš„text\n      if (!text && node.inputs) {\n        for (const input of node.inputs) {\n          if (input.name === 'text' && input.widget && input.widget.value) {\n            text = input.widget.value.trim();\n            console.log(`ğŸ“„ ä»inputsè·å–æ–‡æœ¬: ${text.substring(0, 50)}...`);\n            break;\n          }\n        }\n      }\n      \n      // æ–¹å¼4: propertiesä¸­æŸ¥æ‰¾\n      if (!text && node.properties) {\n        if (node.properties.text) {\n          text = node.properties.text.trim();\n          console.log(`ğŸ“„ ä»propertiesè·å–æ–‡æœ¬: ${text.substring(0, 50)}...`);\n        }\n      }\n      \n      if (text && text.length > 0) {\n        // æ™ºèƒ½åˆ¤æ–­æ˜¯å¦ä¸ºè´Ÿå‘æç¤ºè¯\n        const isNegative = isNegativePrompt(text) || \n                          node.title?.toLowerCase().includes('negative') ||\n                          node.title?.toLowerCase().includes('è´Ÿå‘') ||\n                          node.title?.toLowerCase().includes('åå‘') ||\n                          (node.color && (node.color === '#ff6b6b' || node.color === '#e74c3c')); // çº¢è‰²é€šå¸¸è¡¨ç¤ºè´Ÿå‘\n        \n        if (isNegative) {\n          negativePrompts.push(text);\n          console.log(`â– è¯†åˆ«ä¸ºè´Ÿå‘æç¤ºè¯: ${text.substring(0, 30)}...`);\n        } else {\n          positivePrompts.push(text);\n          console.log(`â• è¯†åˆ«ä¸ºæ­£å‘æç¤ºè¯: ${text.substring(0, 30)}...`);\n        }\n      }\n    }\n    \n    // æå–é‡‡æ ·å™¨å‚æ•°\n    if (['KSampler', 'KSamplerAdvanced', 'SamplerCustom'].includes(node.type)) {\n      if (node.widgets_values) {\n        const [seed, steps, cfg, sampler_name, scheduler, denoise] = node.widgets_values;\n        if (seed !== undefined) parameters.seed = seed;\n        if (steps !== undefined) parameters.steps = steps;\n        if (cfg !== undefined) parameters.cfg_scale = cfg;\n        if (sampler_name !== undefined) parameters.sampler = sampler_name;\n        if (scheduler !== undefined) parameters.scheduler = scheduler;\n        if (denoise !== undefined) parameters.denoise = denoise;\n        console.log(`âš™ï¸ æå–é‡‡æ ·å™¨å‚æ•°: steps=${steps}, cfg=${cfg}, sampler=${sampler_name}`);\n      }\n    }\n    \n    // æå–æ¨¡å‹ä¿¡æ¯\n    if (['CheckpointLoaderSimple', 'CheckpointLoader'].includes(node.type)) {\n      if (node.widgets_values && node.widgets_values[0]) {\n        parameters.model = node.widgets_values[0];\n        console.log(`ğŸ¯ æå–æ¨¡å‹: ${parameters.model}`);\n      }\n    }\n    \n    // æå–å›¾åƒå°ºå¯¸\n    if (['EmptyLatentImage', 'LatentUpscale'].includes(node.type)) {\n      if (node.widgets_values) {\n        const [width, height] = node.widgets_values;\n        if (width !== undefined) parameters.width = width;\n        if (height !== undefined) parameters.height = height;\n        console.log(`ğŸ“ æå–å°ºå¯¸: ${width}x${height}`);\n      }\n    }\n  }\n\n  // æ™ºèƒ½åˆå¹¶æç¤ºè¯\n  const finalPositive = smartMergePrompts(positivePrompts);\n  const finalNegative = smartMergePrompts(negativePrompts);\n  \n  console.log(`ğŸ¯ æœ€ç»ˆç»“æœ: æ­£å‘æç¤ºè¯${finalPositive.length}å­—ç¬¦, è´Ÿå‘æç¤ºè¯${finalNegative.length}å­—ç¬¦`);\n\n  return {\n    positive: finalPositive,\n    negative: finalNegative,\n    parameters\n  };\n}\n\n// æ™ºèƒ½åˆå¹¶æç¤ºè¯\nfunction smartMergePrompts(prompts) {\n  if (prompts.length === 0) return '';\n  if (prompts.length === 1) return prompts[0];\n  \n  // å»é‡å¹¶æŒ‰é•¿åº¦æ’åºï¼Œä¼˜å…ˆé€‰æ‹©æ›´å®Œæ•´çš„æç¤ºè¯\n  const uniquePrompts = [...new Set(prompts)];\n  uniquePrompts.sort((a, b) => b.length - a.length);\n  \n  // å¦‚æœæœ€é•¿çš„æç¤ºè¯æ˜æ˜¾æ¯”å…¶ä»–çš„é•¿å¾ˆå¤šï¼Œå¯èƒ½æ˜¯æœ€ç»ˆåˆæˆçš„ç»“æœ\n  const longest = uniquePrompts[0];\n  const secondLongest = uniquePrompts[1] || '';\n  \n  if (longest.length > secondLongest.length * 2) {\n    console.log(`ğŸ¯ é€‰æ‹©æœ€é•¿æç¤ºè¯ä½œä¸ºæœ€ç»ˆç»“æœ: ${longest.length} vs ${secondLongest.length}`);\n    return longest;\n  }\n  \n  // å¦åˆ™åˆå¹¶æ‰€æœ‰å”¯ä¸€çš„æç¤ºè¯\n  return uniquePrompts.join(', ');\n}\n\n// ä»ComfyUIæç¤ºæå–\nfunction extractFromComfyPrompt(prompt) {\n  const positivePrompts = [];\n  const negativePrompts = [];\n  const parameters = {};\n\n  console.log('ğŸ” åˆ†æComfyUIæç¤ºæ ¼å¼ï¼ŒèŠ‚ç‚¹æ•°é‡:', Object.keys(prompt).length);\n\n  for (const [nodeId, nodeData] of Object.entries(prompt)) {\n    console.log(`ğŸ“ æ£€æŸ¥èŠ‚ç‚¹ ${nodeId}: ${nodeData.class_type}`);\n    \n    // æ‰©å±•æ”¯æŒçš„èŠ‚ç‚¹ç±»å‹\n    const textEncoderTypes = [\n      'CLIPTextEncode', \n      'CLIPTextEncodeSDXL',\n      'BNK_CLIPTextEncoder',\n      'WeiLin-ComfyUI-prompt-all-in-one',\n      'TIPO',\n      'PromptWithStyle',\n      'StringFunction',\n      'Text',\n      'TextInput',\n      'PromptBuilder',\n      'AdvancedCLIPTextEncode',\n      'CLIPTextEncodeFlux',\n      'ShowText',\n      'StringConstant',\n      'MultilineStringLiteral'\n    ];\n    \n    if (textEncoderTypes.includes(nodeData.class_type)) {\n      console.log(`âœ… æ‰¾åˆ°æ–‡æœ¬ç¼–ç èŠ‚ç‚¹: ${nodeData.class_type}`);\n      \n      // å°è¯•å¤šç§æ–¹å¼è·å–æ–‡æœ¬\n      let text = null;\n      \n      if (nodeData.inputs?.text && typeof nodeData.inputs.text === 'string') {\n        text = nodeData.inputs.text.trim();\n        console.log(`ğŸ“„ ä»inputs.textè·å–: ${text.substring(0, 50)}...`);\n      } else if (nodeData.inputs?.prompt && typeof nodeData.inputs.prompt === 'string') {\n        text = nodeData.inputs.prompt.trim();\n        console.log(`ğŸ“„ ä»inputs.promptè·å–: ${text.substring(0, 50)}...`);\n      } else if (nodeData.inputs?.string && typeof nodeData.inputs.string === 'string') {\n        text = nodeData.inputs.string.trim();\n        console.log(`ğŸ“„ ä»inputs.stringè·å–: ${text.substring(0, 50)}...`);\n      }\n      \n      if (text && text.length > 0) {\n        if (isNegativePrompt(text)) {\n          negativePrompts.push(text);\n          console.log(`â– è¯†åˆ«ä¸ºè´Ÿå‘æç¤ºè¯`);\n        } else {\n          positivePrompts.push(text);\n          console.log(`â• è¯†åˆ«ä¸ºæ­£å‘æç¤ºè¯`);\n        }\n      }\n    }\n    \n    // æå–å…¶ä»–å‚æ•°...\n    if (['KSampler', 'KSamplerAdvanced', 'SamplerCustom'].includes(nodeData.class_type)) {\n      const inputs = nodeData.inputs;\n      if (inputs.seed !== undefined) parameters.seed = inputs.seed;\n      if (inputs.steps !== undefined) parameters.steps = inputs.steps;\n      if (inputs.cfg !== undefined) parameters.cfg_scale = inputs.cfg;\n      if (inputs.sampler_name !== undefined) parameters.sampler = inputs.sampler_name;\n      if (inputs.scheduler !== undefined) parameters.scheduler = inputs.scheduler;\n      if (inputs.denoise !== undefined) parameters.denoise = inputs.denoise;\n    }\n  }\n\n  const finalPositive = smartMergePrompts(positivePrompts);\n  const finalNegative = smartMergePrompts(negativePrompts);\n  \n  console.log(`ğŸ¯ æœ€ç»ˆç»“æœ: æ­£å‘æç¤ºè¯${finalPositive.length}å­—ç¬¦, è´Ÿå‘æç¤ºè¯${finalNegative.length}å­—ç¬¦`);\n\n  return {\n    positive: finalPositive,\n    negative: finalNegative,\n    parameters\n  };\n}\n\n// æ£€æµ‹è´Ÿå‘æç¤ºè¯\nfunction isNegativePrompt(text) {\n  const lowerText = text.toLowerCase();\n  \n  // æ‰©å±•è´Ÿå‘å…³é”®è¯åˆ—è¡¨\n  const negativeKeywords = [\n    // è´¨é‡ç›¸å…³\n    'worst quality', 'bad quality', 'low quality', 'poor quality',\n    'bad anatomy', 'bad proportions', 'bad hands', 'bad fingers',\n    'ugly', 'deformed', 'disfigured', 'mutated', 'malformed',\n    'blurry', 'blur', 'out of focus', 'unfocused', 'soft focus',\n    'lowres', 'low resolution', 'pixelated', 'jpeg artifacts',\n    \n    // æŠ€æœ¯é—®é¢˜\n    'error', 'glitch', 'artifact', 'noise', 'grain', 'distorted',\n    'cropped', 'cut off', 'truncated', 'incomplete',\n    'watermark', 'signature', 'text', 'logo', 'username',\n    'border', 'frame', 'black bars', 'letterbox',\n    \n    // è§£å‰–é—®é¢˜\n    'extra limbs', 'missing limbs', 'extra fingers', 'missing fingers',\n    'extra arms', 'extra legs', 'fused fingers', 'too many fingers',\n    'long neck', 'long body', 'elongated', 'stretched',\n    'duplicate', 'multiple', 'conjoined', 'merged',\n    \n    // é£æ ¼é—®é¢˜\n    'amateur', 'sketch', 'draft', 'unfinished', 'rough',\n    'simple', 'basic', 'plain', 'boring', 'dull',\n    'monochrome', 'grayscale', 'black and white', 'sepia',\n    \n    // å†…å®¹é—®é¢˜\n    'nsfw', 'nude', 'naked', 'explicit', 'sexual',\n    'violence', 'blood', 'gore', 'disturbing', 'scary',\n    'dark', 'horror', 'nightmare', 'creepy', 'evil',\n    \n    // ä¸­æ–‡è´Ÿå‘è¯\n    'æœ€å·®è´¨é‡', 'ç³Ÿç³•è´¨é‡', 'ä½è´¨é‡', 'å·®è´¨é‡',\n    'ç³Ÿç³•è§£å‰–', 'å˜å½¢', 'ç•¸å½¢', 'ä¸‘é™‹', 'æ¨¡ç³Š',\n    'ä½åˆ†è¾¨ç‡', 'åƒç´ åŒ–', 'å™ªç‚¹', 'ä¼ªå½±',\n    'æ°´å°', 'ç­¾å', 'æ–‡å­—', 'æ ‡å¿—', 'ç”¨æˆ·å',\n    'å¤šä½™çš„', 'ç¼ºå¤±çš„', 'èåˆçš„', 'é‡å¤çš„',\n    'ä¸šä½™', 'è‰å›¾', 'æœªå®Œæˆ', 'ç²—ç³™', 'ç®€å•',\n    'å•è‰²', 'ç°åº¦', 'é»‘ç™½', 'æš—è‰²è°ƒ'\n  ];\n  \n  // æ£€æŸ¥æ˜¯å¦åŒ…å«è´Ÿå‘å…³é”®è¯\n  const hasNegativeKeywords = negativeKeywords.some(keyword => \n    lowerText.includes(keyword.toLowerCase())\n  );\n  \n  // æ£€æŸ¥è´Ÿå‘æç¤ºè¯çš„æ¯”ä¾‹\n  const negativeWordCount = negativeKeywords.filter(keyword => \n    lowerText.includes(keyword.toLowerCase())\n  ).length;\n  \n  const totalWords = text.split(/\\s+/).length;\n  const negativeRatio = negativeWordCount / totalWords;\n  \n  // å¦‚æœè´Ÿå‘è¯æ±‡æ¯”ä¾‹è¶…è¿‡30%ï¼Œå¾ˆå¯èƒ½æ˜¯è´Ÿå‘æç¤ºè¯\n  const isHighNegativeRatio = negativeRatio > 0.3;\n  \n  // æ£€æŸ¥æ˜¯å¦ä»¥è´Ÿå‘è¯å¼€å¤´\n  const startsWithNegative = negativeKeywords.some(keyword => \n    lowerText.startsWith(keyword.toLowerCase())\n  );\n  \n  console.log(`ğŸ” è´Ÿå‘æ£€æµ‹: å…³é”®è¯=${hasNegativeKeywords}, æ¯”ä¾‹=${negativeRatio.toFixed(2)}, å¼€å¤´=${startsWithNegative}`);\n  \n  return hasNegativeKeywords || isHighNegativeRatio || startsWithNegative;\n}\n\n// è§£æNovelAIæ•°æ®\nfunction parseNovelAI(text) {\n  const result = {\n    positive: '',\n    negative: '',\n    parameters: {}\n  };\n\n  try {\n    const data = JSON.parse(text);\n    result.positive = data.prompt || '';\n    result.negative = data.uc || '';\n    \n    ['steps', 'scale', 'seed', 'sampler', 'width', 'height'].forEach(key => {\n      if (data[key] !== undefined) {\n        result.parameters[key] = data[key];\n      }\n    });\n  } catch (error) {\n    console.warn('NovelAIè§£æå¤±è´¥:', error);\n  }\n\n  return result;\n}\n\n// EXIFæ•°æ®æå–\nasync function extractFromEXIF(file) {\n  try {\n    // åŠ¨æ€å¯¼å…¥exifr\n    const exifr = await import('exifr');\n    \n    const exifData = await exifr.parse(file, {\n      userComment: true,\n      imageDescription: true,\n      software: true\n    });\n\n    if (!exifData) return null;\n\n    return {\n      type: 'EXIF',\n      confidence: 'medium',\n      data: {\n        software: exifData.Software,\n        description: exifData.ImageDescription,\n        userComment: exifData.UserComment,\n        positive: exifData.UserComment || exifData.ImageDescription || '',\n        negative: '',\n        parameters: {}\n      }\n    };\n  } catch (error) {\n    console.warn('EXIFæå–å¤±è´¥:', error);\n    return null;\n  }\n}\n\n// æ ‡å‡†åŒ–æ•°æ®\nfunction standardizeData(extractedData) {\n  const standardized = {\n    generationTool: 'Unknown',\n    positive: '',\n    negative: '',\n    parameters: {}\n  };\n\n  // ä¼˜å…ˆçº§é¡ºåº\n  const sources = ['PNG', 'EXIF'];\n  \n  for (const source of sources) {\n    const data = extractedData[source];\n    if (!data) continue;\n\n    if (data.data.generationTool) {\n      standardized.generationTool = data.data.generationTool;\n    }\n\n    if (data.data.positive && !standardized.positive) {\n      standardized.positive = data.data.positive;\n    }\n\n    if (data.data.negative && !standardized.negative) {\n      standardized.negative = data.data.negative;\n    }\n\n    Object.assign(standardized.parameters, data.data.parameters || {});\n  }\n\n  return standardized;\n}\n\n// å¯¼å‡ºä¸»è¦å‡½æ•°\nexport const imageMetadataExtractor = {\n  extractMetadata\n};\n\nexport default imageMetadataExtractor; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}